---
id: 2023-03-15
created_date: 15/03/2023
updated_date: 15/03/2023
type: note
---

# 2023-03-15

## üìù Notes

15/03/2023:03:30

@nathan -->

@eli -->

`IRModelRuns` --> two more fields

```python

def calculateIRHeatmapMetrics(this):
    this = this.getMissing("id, name, data, data.heatmap, data.timestamp")
    # startTime is currently getting js ms from the first time stamp
    # it then subtracts this from an epoch-adjusted reference date of 1/1/2020
    # this implementation will change in future releases
    refTime = datetime(2020, 1, 1)
    startDatetime = jsGetTime(datetime(2020, 1, 1)) - jsGetTime(refTime)

    
    trajectoryIrDataSet = np.array([irPoint.heatmap for irPoint in this.data])
    numMeasurements = trajectoryIrDataSet.shape[0]
    trajectoryIrDataSet = trajectoryIrDataSet.reshape(numMeasurements, 16, 8)

    aspectAngles = np.array(
        [0, 5, 10, 15, 20, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180]
    )
    azimuthAngles = np.array([0, 45, 90, 135, 180, 225, 270, 315])

    # container to hold thread return values    
    result = dict()

    def thread_1(trajectoryIrDataSet: np.array, result: dict):
        result["maxVals"] = np.ceil(np.asarray(trajectoryIrDataSet).max(axis=(1, 2)))
    
    def thread_2(trajectoryIrDataSet: np.array, result: dict):
        result["broadsideIntensity"] = np.sum(trajectoryIrDataSet, axis=2)

    def thread_3(result: dict):
		trajectoryIrDataSet = np.array([irPoint.heatmap for irPoint in this.data])
    numMeasurements = trajectoryIrDataSet.shape[0]
    trajectoryIrDataSet = trajectoryIrDataSet.reshape(numMeasurements, 16, 8)

	    aspectAngles = np.array(
	        [0, 5, 10, 15, 20, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180]
	    )
	    azimuthAngles = np.array([0, 45, 90, 135, 180, 225, 270, 315])

        labels = [
            [str(azimuth) + ", " + str(aspect) for azimuth in azimuthAngles]
            for aspect in aspectAngles[::-1]
        ]
        # missing = [0] * (len(aspectAngles) * len(azimuthAngles))

        data = []
        # minVals = np.floor(trajectoryIrDataSet.min(axis=(1,2)))

        # TODO: Replace triple nesting with np operation
        for irPoint in np.asarray(trajectoryIrDataSet):
            paramData = []
            for aspectInd, aspect in enumerate(aspectAngles):
                reverseAspectInd = len(aspectAngles) - 1 - aspectInd
                for azimuthInd, azimuth in enumerate(azimuthAngles):
                    irValue = irPoint[aspectInd, azimuthInd]
                    paramData.append(
                        {
                            "value": [azimuthInd, reverseAspectInd, irValue],
                            "label": labels[reverseAspectInd][azimuthInd],
                        }
                    )
            data.append(paramData)
        result["data"] = data
    
    # TODO: Reintroduce sphere with similar threading logic
    # sphereData = generate_echart_c3_map(
    #     np.asarray(trajectoryIrDataSet), aspectAngles, azimuthAngles
    # )

    t_1 = threading.Thread(target=thread_1, args=(trajectoryIrDataSet,result))
    t_2 = threading.Thread(target=thread_2, args=(trajectoryIrDataSet,result))
    t_3 = threading.Thread(target=thread_3, args=(trajectoryIrDataSet,result))

    t_1.start()
    t_2.start()
    t_3.start()

    t_1.join()
    t_2.join()
    t_3.join()

    # print(result)

    return {
        "xLabels": azimuthAngles.tolist(),
        "yLabels": aspectAngles[::-1].tolist(),
        "series": {
            "data": result["data"],
            # "minVals": minVals,
            "maxVals": result["maxVals"].tolist(),
            "id": this.id,
            "name": this.name,
        },
        # "sphereData": sphereData,
        "barchartData": result["broadsideIntensity"],
        "barchartXLabels": aspectAngles,
        # "missing": missing,
        "startTime": startDatetime,
    }

```


```python

def thread_3(result: dict):
    trajectoryIrDataSet = np.array([irPoint.heatmap for irPoint in this.data])
    numMeasurements = trajectoryIrDataSet.shape[0]
    trajectoryIrDataSet = trajectoryIrDataSet.reshape(numMeasurements, 16, 8)

    aspectAngles = np.array(
        [0, 5, 10, 15, 20, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180]
    )
    azimuthAngles = np.array([0, 45, 90, 135, 180, 225, 270, 315])

    labels = np.array(
        [
            [f"{azimuth}, {aspect}" for azimuth in azimuthAngles]
            for aspect in aspectAngles[::-1]
        ]
    )

    # Use np.meshgrid to generate 2D arrays of aspect and azimuth angles
    aspect, azimuth = np.meshgrid(aspectAngles, azimuthAngles)

    # Use np.transpose to flip the aspect array to match the ordering in the labels array
    aspect = np.transpose(aspect)[::-1]

    # Use np.reshape to flatten the trajectoryIrDataSet into a 2D array of size (numMeasurements, numAngles)
    flattenedDataSet = trajectoryIrDataSet.reshape(numMeasurements, -1)

    # Use np.stack to create a 3D array of size (numMeasurements, numAngles, 3)
    # where the last dimension contains the azimuth index, aspect index, and IR value
    data = np.stack([np.vstack([azimuth, aspect, flattenedDataSet[:, i]]).T for i in range(flattenedDataSet.shape[1])])

    # Use np.broadcast_to to replicate the labels array along the first axis to match the shape of the data array
    labels = np.broadcast_to(labels[:, :, np.newaxis], (numMeasurements, aspect.shape[1], 1))

    # Use np.concatenate to combine the data and labels arrays along the last axis
    result["data"] = np.concatenate([data, labels], axis=-1)  At

```

```python

# Reshape the trajectoryIrDataSet to have a third axis representing the azimuth angles
# This allows us to use numpy indexing to access the values corresponding to the azimuth and aspect angles
trajectoryIrDataSet = trajectoryIrDataSet.reshape(numMeasurements, len(aspectAngles), len(azimuthAngles))

# Use np.meshgrid to generate 2D arrays of aspect and azimuth angles
aspect, azimuth = np.meshgrid(aspectAngles, azimuthAngles)

# Use np.transpose to flip the aspect array to match the ordering in the labels array
aspect = np.transpose(aspect)[::-1]

# Use np.indices to generate an array of indices corresponding to the (azimuth, aspect) pairs
azimuthInd, aspectInd = np.indices(aspect.shape)

# Use numpy indexing to extract the IR values corresponding to the (azimuth, aspect) pairs
irValues = trajectoryIrDataSet[:, aspectInd, azimuthInd]

# Reshape the IR values to a 3D array of size (numMeasurements, numAngles, 1)
irValues = irValues.reshape(numMeasurements, aspect.shape[1], 1)

# Use np.stack to create a 3D array of size (numMeasurements, numAngles, 3)
# where the last dimension contains the azimuth index, aspect index, and IR value
data = np.stack([azimuthInd, aspect, irValues], axis=-1)

# Use np.broadcast_to to replicate the labels array along the first axis to match the shape of the data array
labels = np.broadcast_to(labels[:, :, np.newaxis], (numMeasurements, aspect.shape[1], 1))

# Use np.concatenate to combine the data and labels arrays along the last axis
result["data"] = np.concatenate([data, labels], axis=-1).tolist()


```

## üîó Links

## **üè∑Ô∏èTags**

- 
