Hello everyone, and welcome back. In our last video, we introduced the concept of semantics. We introduced three different things that you typically will find in a semantic system. We talked about judgments, which are assertions about a syntactic object. We talked about proof rules, which are a way of expressing when a judgement is true or valid. We also talked about proof trees, which are a way of using the proof rules on a specific syntactic object approval property about it. So, in this video, we're going to talk about a specific kind of semantics called Big Step Semantics. Now, what big step semantics does is, if you give it a program expression or statement, it'll tell you the result of evaluating that in whatever system you're currently using. So, it's a mathematical way of expressing the eval function that you've already written in Haskell. So, if you've written eval, then you're already kind of know big step semantics. All this is going to be a mathematical notation that corresponds to that. The reason we're teaching you this now is that in the machine problems, we're going to want you to write eval and our thought is, if we can give you the mathematical notation that represents what we're asking you to do, it I'll make it a lot easier for you. So, hopefully, you find that to be the case. So, your objectives, you're going to want to be able to describe what the components of the big semantic rule look like and be able to use that to document a simple programming language. So, let's introduce the language now. So, this is called the simple imperative programming language. It's been around for a long, long time. It's a toy example language for documenting things. Well, by things, what I mean is mathematical constructs that we use to discuss languages. It's not really used in real life. So, we have five different statements in this language. Now, a statement is different than an expression. We haven't really talked about them yet in this class, but a statement is something that has an effect on the world. In our language, the only real effective consequence is that we have assignments. So, we have this u := A. So, that just means we've updated a variable to have a new value. We have four other statements, which are really just ways of combining statements together. We have skip, which means do nothing, and it turns out that's surprisingly useful. We have semicolon, which is a statement separator. It's a way of combining two statements into a single one. Now, make a note, it's not a statement terminator, like it is in many languages, but a separator. We also have "if" and "while," which are conditions and repetitions. Again, these are statements in this language. You know that in Haskell, "if" is an expression. Now, expressions, we have E and B. Those are both kinds of expressions, but the B1 is for Booleans and the e_1 is for integers. So, we'll use tilde to represent all the relational symbols. We'll use circle plus to represent all the arithmetic. So, let's look at judgments now. We have three different kinds of judgments corresponding to the three different kinds of syntactic objects we had. So, statements, the way we're going to do with the judgment is, on the left-hand side of the down arrow, we have these angle brackets, the less than and greater than looking things, and inside, we have S,Sigma. So, S represents a statement, Sigma represents an environment, it's just a mapping from variables to their corresponding values. We're going to treat it kind of like a set. I'll show you some more concrete examples of that in the next slide. So, then you have the down arrow, which means to evaluate that statement in that particular environment. The result is going to be a new environment because that's what statements do. They make changes to the world. Correspondingly, we have expressions and Booleans. We have down arrow e to evaluate an expression and get us back a value v, which we're going to just assume as an integer for now. We also have Booleans. We evaluate that using down arrow b, and get a Boolean value back. So, now let's look at the rules that explain when these things are valid. For expressions, we have three different rules. We have one for constants. If you have a constant i, which is an integer, and you evaluate that, you'll be happy to know you get the same integer back. For variables, if we evaluate that in a particular environment, then what we want to do is see if there is an assignment in that environment. So, the way we notate this, we pretend Sigma is a set, and the elements of the set are going to have this forum u := v, which just says variable u is assigned to value v. So, we just assume there's a bunch of those inside of Sigma. If this particularly u := v is a member of that, then we go ahead and let that be the value. It's an error, if you have two different instances of u := inside of Sigma for the same variable, you're only supposed to have one of those. In a way, it behaves kind of like a HashMap. So, finally, we have operations, where your circle plus to represent plus times, et cetera. So, if we want to do something, some operation to e_1 and e_2, the first thing we have to do is look at e_1 and evaluate that to get v_1, then we have to take e_2 and evaluate that to get v_2. So, those are our premises. Then with the v_1 and v_2, we combine them with that operation we specified to get our final result. Now, for Booleans, it's pretty much the same thing, except we're using down arrow b instead of down arrow e, because it's going to be convenient later on to specify that we're expecting a Boolean value back versus specifying integer value back, and so that's why we make this distinction. So, the Boolean constant and the Boolean variable rule are pretty much identical. What is a little different is a relational operations. So, you see the conclusion of the relational operation. We have e_1 compared to e_2. We use down arrow b, and then the result is going to be the result of comparing v_1 and v_2. But when you look at the premises, we're still using down arrow e because we're assuming that these things are integers. Now, we don't have "and" and "or." There's logical connectives in this language. If you wanted to add those two, then you need to add another rule for that. It's not that hard, but we prove the point with what we have in this language, so we don't bother adding them. Now, the statement rules are more complex. The first one is skip, which is fairly straightforward. It just takes the environment, and it doesn't do anything. Skip is used in several different circumstances. In the simple imperative programming language, the most common actually is to have a "if" statement that doesn't have an "else" branch because we noticed that the rule for "if," some language we can say if something, then do something, and then that's the end of it. We don't have that. You must specify both of them in an "else" branch. If you'd rather not have an "else" branch, skip is how you get away with it. The other thing that skip is used for in language theory is that sometimes you want to say that a statement evaluates to become the same thing as a skip statement. We're not going to do too much of that here. That might show up another semantic rules when we get further along in the course though. Now, for our assignment, we have the statement x := e, so e is an expression. So, we have to evaluate that to get v. That's what you see in the premise here. Then we have this notation Sigma and then these brackets x := v. So, what that means to do is have that x := something is a member of Sigma, we're going to replace it with this thing. If x := something is not a member of Sigma, we're simply going to add this to the set. So, it's kind of like a variable reassignment notation. So, next one we want to talk about is the sequencing. So, you've seen these two rules now. So, what I want you to do is think about what would the sequence rule look like. So, go ahead and pause, and when you're ready to see it, just hit on pause. All right, so, here's sequencing. We have an S1 and an S2 and we start off with sum environment Sigma. So, the first thing we have to do is evaluate S1. That's going to change our environment from Sigma to Sigma prime. It's going to be something. Then, next, we're going to evaluate S2 inside of Sigma prime. That's going to get us yet another environment Sigma prime prime, and that is going to be the result of our entire statement. So, the next are "if" statements. So, again, I wanted to see if you can guess what they will look like. So, here "if" statements, there are two of them. So, the first thing, you have if B, then S1 else S2. So, B is our condition. So, the first thing we have to do is evaluate that condition. So, the b down arrow, B true. So, if B is true, then we want to evaluate S1 to get Sigma prime. That's going to be the final result. So, that's the first "if" rule. The second "if" rule is the same, except that our B turns out to be false. So, we evaluate S2 instead. So, the final one is "while." Again, there are two rules. Because we have a guard, it could be true or it could be false. So, see if you can guess what they look like. The second one is kind of recursive. It's a here "while" statements. The first one, we have a guard. If the guard turns out to be false, then the whole "while" statement doesn't do anything to an environment. So, we return the original environment back. The second one, if the guard turns out to be true, then we're going to evaluate the body of the "while" statement, and that's going to do something, as Sigma turn into a Sigma prime. Then, what we want to do after that is rerun the "while" loop. So, we're going to run it again, this time, in Sigma prime. That's going to go off and do whatever it does until it terminates in which case, we're going to get Sigma prime prime back, and that's going to be the result of the whole thing. So, now we've done that, let's take a couple of examples of proof trees. So, the first one, we want just to evaluate an expression. So, we have 2 x y + 9 x x inside of Sigma and let's just use the standard rules for precedences here to break this up. So, that means the kind of expression this is is going to be a plus expression. We didn't give you precedence rules and there are several different ways you could have broken this up, and it's going to give you different results. So, the first thing we're going to do is we're going to take the 2 x y, and the 9 x x, and evaluate both of those. Those give us 8 and 27 respectively. Then, in order to evaluate those, since those are also more complicated expressions, are not axioms, so we need to break those apart too. So, this is what the full proof tree will look like. So, 2 and 9, both use the constant rule, y and x both use the variable rule and the combinations use the arithmetic rule. Here's another one. This is going to use all three versions of down arrow. So, say if x is greater than y, then m is equal to x, else m is equal to two times x, which is-, I don't know, it doesn't really do anything interesting, but it makes a good proof tree. So, this is the "if" statement. So, we're going to have to evaluate x greater than y and Sigma. We just happen to know that turns out to be false, we'll read out the proof in a minute. Then, we're going to evaluate the then part of the branch or the else part of the branch. So, m is going to be equal to two times x. Again, expanding out those. X and y, both these are variable rule, and the two uses constant. Again, we have x using the variable rule. One kind of painful thing about proof trees is you see there are two instantiations of the variable rule for x here. You can't get away from it. You got to write them both down. That's just the way math is. When you have a formal system, you have to follow the rules, which is to say you have to follow the forums. Otherwise, you can't be sure that you have a valid expression. So, let's connect this to interpreters, this down arrow that we've been talking about, it's really just eval. You notice when you wrote eval for plus, you had a e_1 and e_2 and you evaluated those first to get your values, and then you added them together to get the final result. The Sigma is just the environment parameter that you also pass into eval. In a sense, you've seen this already just not using this notation. So, hopefully, this will help out when you are doing a machine problem. In our next lectures, we'll talk about another concept called Lambda calculus.