1
00:00:02,140 --> 00:00:05,975
Hello everyone. Welcome to CS 421,

2
00:00:05,975 --> 00:00:08,650
and this series of lectures we're going to talk about

3
00:00:08,650 --> 00:00:11,045
a theoretical language called lambda calculus.

4
00:00:11,045 --> 00:00:14,450
So, in this first video, we're just going to introduce the constructs.

5
00:00:14,450 --> 00:00:15,700
There are only three constructs.

6
00:00:15,700 --> 00:00:17,380
It's a very simple language,

7
00:00:17,380 --> 00:00:21,065
and we'll talk about how to build syntax tree diagrams for them.

8
00:00:21,065 --> 00:00:23,855
We'll look at what different constructs look like.

9
00:00:23,855 --> 00:00:25,940
We'll also talk about something called beta-reduction,

10
00:00:25,940 --> 00:00:29,210
which is this fancy way of saying function application.

11
00:00:29,210 --> 00:00:31,770
Now, lambda calculus is important.

12
00:00:31,770 --> 00:00:37,955
It was designed to study how function application works and what functions can do,

13
00:00:37,955 --> 00:00:39,980
and in our context,

14
00:00:39,980 --> 00:00:43,895
it's important because it's used extensively in programming language search.

15
00:00:43,895 --> 00:00:45,815
You'll notice that functional languages like

16
00:00:45,815 --> 00:00:48,500
Haskell are actually built around lambda calculus.

17
00:00:48,500 --> 00:00:49,865
I'll show you that in a minute.

18
00:00:49,865 --> 00:00:53,395
Now, there's three things in lambda calculus: first is variables.

19
00:00:53,395 --> 00:00:56,590
We are typically going to assume that they are one-letter long,

20
00:00:56,590 --> 00:01:00,715
and the reason for that is that when we write down lambda calculus terms,

21
00:01:00,715 --> 00:01:02,920
we tend not to use spaces at all,

22
00:01:02,920 --> 00:01:05,560
and the only way that that makes any sense is if

23
00:01:05,560 --> 00:01:08,275
all variable names are exactly one letter.

24
00:01:08,275 --> 00:01:12,235
So, sometimes we'll use decorations like subscripts or prime marks.

25
00:01:12,235 --> 00:01:15,080
Function application, like in Haskell,

26
00:01:15,080 --> 00:01:17,530
is done by juxtaposing.

27
00:01:17,530 --> 00:01:20,325
So, the first example is f applied to y.

28
00:01:20,325 --> 00:01:22,855
The second example is a applied to b,

29
00:01:22,855 --> 00:01:25,170
and then that whole thing applied to c. So,

30
00:01:25,170 --> 00:01:26,370
you can think of that two ways.

31
00:01:26,370 --> 00:01:30,415
You can think of it as a being applied to two parameters, b and c,

32
00:01:30,415 --> 00:01:33,270
or you can think of it as a being applied to b first and then

33
00:01:33,270 --> 00:01:37,640
that whole thing being applied to c,and this is the same as it is in Haskell.

34
00:01:37,640 --> 00:01:42,330
The third example. We have x applied to two things: the first is f applied to y,

35
00:01:42,330 --> 00:01:44,690
the second is f applied to g. So,

36
00:01:44,690 --> 00:01:49,794
you'll notice that we use parentheses if we want to change the default groupings.

37
00:01:49,794 --> 00:01:53,965
You can't have function application unless you have a way of making functions.

38
00:01:53,965 --> 00:01:55,610
So, here's how to do that.

39
00:01:55,610 --> 00:01:58,220
You write down the character lambda,

40
00:01:58,220 --> 00:02:01,640
then you write down whatever parameters you want,

41
00:02:01,640 --> 00:02:04,135
and then a dot and then the body of the function.

42
00:02:04,135 --> 00:02:09,545
Now, the body of the function extends as far as syntactically possible.

43
00:02:09,545 --> 00:02:12,760
So, if you want to limit the scope of a function,

44
00:02:12,760 --> 00:02:14,535
then you have to use parentheses.

45
00:02:14,535 --> 00:02:19,625
So, the first one, we have a function of one variable x and just returning x.

46
00:02:19,625 --> 00:02:22,030
The second, we have a function ab.

47
00:02:22,030 --> 00:02:24,440
A function that takes two parameters ab and then

48
00:02:24,440 --> 00:02:27,190
applies this parameters to f. The third one,

49
00:02:27,190 --> 00:02:32,180
we have a function that takes two parameters x and y and then the body of

50
00:02:32,180 --> 00:02:34,240
it takes g and applies three things to it:

51
00:02:34,240 --> 00:02:38,270
the first one is itself a function and then y and x.

52
00:02:38,270 --> 00:02:42,460
So, the reason why lambda calculus is used so extensively

53
00:02:42,460 --> 00:02:46,050
in research is that if you want to be a programming language theorists,

54
00:02:46,050 --> 00:02:47,650
one of the things that you will tend to

55
00:02:47,650 --> 00:02:49,820
do is you'll come up with a new language construct,

56
00:02:49,820 --> 00:02:53,595
then you want to write proofs about what it does or explain what it does.

57
00:02:53,595 --> 00:02:58,625
These proofs will tend to be structured over the terms that you have in your language.

58
00:02:58,625 --> 00:03:00,080
So, if you have a large language,

59
00:03:00,080 --> 00:03:02,560
like C++, which has, I don't know,

60
00:03:02,560 --> 00:03:05,480
how many different kinds of language constructs it has,

61
00:03:05,480 --> 00:03:08,560
but each one of those need to be mentioned in your proof.

62
00:03:08,560 --> 00:03:10,020
In a language like lambda calculus,

63
00:03:10,020 --> 00:03:11,485
we only have three things,

64
00:03:11,485 --> 00:03:15,000
and then maybe have your language constructs and maybe you have a couple of things more.

65
00:03:15,000 --> 00:03:16,830
So, the proofs tend to be shorter.

66
00:03:16,830 --> 00:03:20,300
The other thing that's kind of interesting about lambda calculus is that it

67
00:03:20,300 --> 00:03:23,620
does become the foundation for the functional programming languages.

68
00:03:23,620 --> 00:03:26,770
So, in Haskell, you see this backslash.

69
00:03:26,770 --> 00:03:29,425
You've heard me call it lambda before and now you know why.

70
00:03:29,425 --> 00:03:32,475
So, lambda calculus, lambda x.x, in Haskell,

71
00:03:32,475 --> 00:03:36,275
we can put backslash x arrow x and it's the same thing.

72
00:03:36,275 --> 00:03:38,660
So, in a sense, you've already seen them to calculus.

73
00:03:38,660 --> 00:03:40,400
We just weren't calling it that.

74
00:03:40,400 --> 00:03:42,945
Now, here's a few examples to look at.

75
00:03:42,945 --> 00:03:44,650
The first two are rather famous.

76
00:03:44,650 --> 00:03:46,855
The first one's called the identity function.

77
00:03:46,855 --> 00:03:48,490
The second one is called delta,

78
00:03:48,490 --> 00:03:50,350
which is used in some proofs.

79
00:03:50,350 --> 00:03:52,785
If you've ever seen a proof of the halting problem,

80
00:03:52,785 --> 00:03:57,640
you know that taking a function and applying it to itself is one of the steps.

81
00:03:57,640 --> 00:03:59,770
Examples three and four,

82
00:03:59,770 --> 00:04:03,060
the first example is a function that takes two parameters a and

83
00:04:03,060 --> 00:04:06,680
b and just applies a bunch of things to f for different things,

84
00:04:06,680 --> 00:04:09,200
but example four the letters are the same,

85
00:04:09,200 --> 00:04:10,735
but I've used parentheses;

86
00:04:10,735 --> 00:04:12,870
and so now the function, lambda ab,

87
00:04:12,870 --> 00:04:14,880
only extends as far as fab,

88
00:04:14,880 --> 00:04:19,945
and then after that the x and y are applied to that whole thing and not to f anymore.

89
00:04:19,945 --> 00:04:22,165
Fifth example, it's the same as a fourth,

90
00:04:22,165 --> 00:04:26,820
only I've expanded out the lambdas instead of keeping it together,

91
00:04:26,820 --> 00:04:28,920
but those are actually the same term.

92
00:04:28,920 --> 00:04:33,820
So, one thing that's important to be able to do is build syntax trees.

93
00:04:33,820 --> 00:04:40,260
So, here's some examples of lambda calculus terms and their corresponding trees.

94
00:04:40,260 --> 00:04:42,635
So, the first one is just the identity again.

95
00:04:42,635 --> 00:04:44,850
So, you see that there's a lambda x on top,

96
00:04:44,850 --> 00:04:49,740
and then we have an arrow that goes to the body of the function x.

97
00:04:49,740 --> 00:04:53,290
We use the at symbol to represent function application.

98
00:04:53,290 --> 00:04:55,485
So, the thing on the left is a function.

99
00:04:55,485 --> 00:04:57,800
That thing on the right is the application.

100
00:04:57,800 --> 00:05:00,615
If we have a function with multiple things being applied,

101
00:05:00,615 --> 00:05:04,235
each of those is its own function applications.

102
00:05:04,235 --> 00:05:05,510
Seen in example three,

103
00:05:05,510 --> 00:05:09,795
the function is lambda y dot y and then it's applied to x,

104
00:05:09,795 --> 00:05:12,040
and then that whole thing is applied to z,

105
00:05:12,040 --> 00:05:14,880
and then the fourth example is something a little bit larger.

106
00:05:14,880 --> 00:05:16,090
So, if you want,

107
00:05:16,090 --> 00:05:20,935
hit pause and look at the parts and see how they line up with the tree.

108
00:05:20,935 --> 00:05:27,090
Now, one important concept that happens whenever you write down lambdas and then a term,

109
00:05:27,090 --> 00:05:29,240
so like lambda z here,

110
00:05:29,240 --> 00:05:32,885
then any occurrence of z that appears underneath that lambda

111
00:05:32,885 --> 00:05:37,185
in the body of the function is considered bound to that lambda.

112
00:05:37,185 --> 00:05:41,360
So, there's a little bit of a disclaimer which we'll talk about later,

113
00:05:41,360 --> 00:05:43,020
but for now let's just call it that.

114
00:05:43,020 --> 00:05:44,345
So, in the first example,

115
00:05:44,345 --> 00:05:49,635
you see a z at the bottom and that's bound to the lambda z at the very top.

116
00:05:49,635 --> 00:05:51,470
You see the x here,

117
00:05:51,470 --> 00:05:54,785
which is bound to the lambda x and you see a y.

118
00:05:54,785 --> 00:05:57,300
So, all of these different variables that are

119
00:05:57,300 --> 00:05:59,955
inside are bound to the various lambdas that occur.

120
00:05:59,955 --> 00:06:02,120
Now, it can happen, that you can write down

121
00:06:02,120 --> 00:06:05,825
a variable and that variable is not bound to anything.

122
00:06:05,825 --> 00:06:07,310
So, in the second example,

123
00:06:07,310 --> 00:06:09,650
you see this z here,

124
00:06:09,650 --> 00:06:12,160
and if you go up you look that it's inside of

125
00:06:12,160 --> 00:06:16,280
a lambda y function and that itself inside of a lambda x function.

126
00:06:16,280 --> 00:06:18,580
So, this z is not bound to anything.

127
00:06:18,580 --> 00:06:20,505
That's called a free variable.

128
00:06:20,505 --> 00:06:24,875
You can think of it as kind of a global variable in a normal language.

129
00:06:24,875 --> 00:06:26,515
It's just sort of out there,

130
00:06:26,515 --> 00:06:30,355
and the program that you're writing doesn't have anything to say about that.

131
00:06:30,355 --> 00:06:32,180
Sometimes in some systems,

132
00:06:32,180 --> 00:06:34,235
people will forbid you from using these,

133
00:06:34,235 --> 00:06:36,290
but knowing whether or not a variable is

134
00:06:36,290 --> 00:06:40,345
free inside of a certain function is going to turn out to be important.

135
00:06:40,345 --> 00:06:42,300
So, that was a quick introduction to

136
00:06:42,300 --> 00:06:45,750
the three different kinds of terms that you'll see in lambda calculus.

137
00:06:45,750 --> 00:06:46,950
And the next video,

138
00:06:46,950 --> 00:06:50,490
we will go for a bunch of examples of function applications

139
00:06:50,490 --> 00:06:55,070
actually being done and some of the complications that result.