Hello everyone. Welcome back. In this video, we're going to talk about something called the Y Combinator which is way of implementing recursion in pure lambda calculus. So, our objective is of course to know what the Y Combinator is, and to see how it uses self-application to allow functions to call themselves. Now, to get started, let's suppose we want to implement this function, f of n is equal to f at n plus one. Now, leave aside for the moment the minor detail that this doesn't terminate. What we want to do is find a way in pure lambda calculus, so we can't use this equal thing to define something that behaves like f. To get started, we might do something like this, so the definition of f is lambda n.f applied to inc applied to n, but the problem is we need to find a way of letting f know what is on code is, how does that get to know itself? There's a old saying that if the only tool you have is a hammer, then every problem begins to look like a nail. There's a related saying actually that if the only tool you have is C++, and every problem begins to look like a thumb, but that's a different thing. In our case, the only tool we have is a function. So, we're going to have to use function calls to do this. So, here's what we're going to do, we're going to make f take as its first argument, its own name as a parameter. So, we're going to add this lambda f to the beginning, and then to make use of this, we're going to have two copies of f, and we're going to pass the first copy into the second copy. That way, the first copy has its source code that I can call recursively. We need to make one other little change here because since f now is going to have to take itself as its first parameter, we can't just leave f by itself. So, you see in this code, we have f applied to inc again, still we're going to change that to f applied to f applied to inc n. So, once we have this, now we have a properly recursive function that can call itself, and expand itself out as much as it needs to. It's ugly though because whenever we want to use recursion, we have to have two copies of this thing. How are we going to fix this? So, there's another way of doing this, we could have a function build the two copies for us. So, to see how that works, I want you to consider these Church numerals. So, let's say that f with a subscript is a Church numeral represented in that particular number. So, we have f5, we can unfold it once to get f applied to f4. We can fold that again to get f applied to f applied to f3, so on and so forth. So, what we really want is something that behaves a lot like an f of infinity. So, here's what f of infinity looks like. We have f infinity applied to f applied to x is equal to f applied to f infinity f applied to x. So, f then takes a string as its first argument and then expands it out again if necessary. This thing is called the Y Combinator, this f of infinity. A Combinator is simply a function that doesn't use anything outside of itself, it just uses the things that's passed in and combines them in order to get its result. So, here's the Y Combinator, the source code to it. It takes f as its argument, the thing that you want to make repeated, and then you have that 2.5 thing going on inside where y is taking its own name as its argument then playing f applied to yy. Now, if you look at this, if you expand out this YF down here, you see first that it takes f as its argument. So you have lambda y and then you have the two halves, you have the f of yy. The first half takes the second half so you get f applied to this thing. If you look at that thing that F is applied to, that's just the original source code that we hadn't aligned before, so, that's equal to f applied to YF, and this is what we wanted. Now, this function is very famous in the programming language community, there's actually a startup company called Y Combinator or they're a company that fund startup companies. I actually knew a professor who had this source code, this Y Combinator tattooed on his arm. He's a better geek than I am, I'm ashamed to admit. So let's see an example of what this might look like. If we want this factorial function, that's in Haskell, we could rewrite it in lambda calculus, it might look like this. So, we'd have lambda f for factorial, and then what we would do is we just feed this factorial function to the Y Combinator. This way the factorial whenever it calls itself recursively can just re-expand one more level out. So, that's it. You have seen now that with lambda calculus, we can implement integers using Church numerals, we can implement Booleans using a similar technique, and even implement other data structures. We've seen that you can use this Y combinator to implement recursion, and hopefully all of this is enough to convince you that, yes, in fact, this is a train complete language. Here's a interesting paper you might want to read if this is interesting to you about using lambda calculus to represent itself, Efficient Self-Interpretation in Lambda Calculus in the Journal of Functional Programming. This author has written several other papers that are similar to that.