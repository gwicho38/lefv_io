Hello everyone, and welcome back. In this video, we're going to talk about evaluation orders. So, your objectives, they're these four terms you want to know, there's evaluation orders called normal order and applicative order, then there's two different forums to know, called normal form and weak head normal form. The reason why we want to learn these terms, is they answer these two questions. If there's more than one Beta reduction, does it matter which one you do first, or is there an always right next one to do? Also, if you have some Beta reductions, is it ever permissible to leave one unreduced? Sometimes, actually the answer is yes to that question. So, let's start with evaluation order. The first one we want to talk about is called applicative order, and in many programming languages, the way a function call works, is that you take all the arguments to the function, and then you evaluate them first, and then the values or results or what you pass into the function call, is called call by value, we're going to have a future video where we talk more about this. So, the way applicative order works, is you start with the leftmost outermost application, that's this application here, because it's the outermost one. You could look inside and see that fx if that were something that could be a Beta reduction, then we would not want to do that because that's not an outermost one. So, we want to do this outermost thing, and then you look at any arguments and you evaluate them first before you do the Beta reduction. So, in this example, the leftmost outermost application this is Lambda X term applied to the Lambda Z term. Lambda Z is already evaluated as much as it can go, so we just pass it in, and we get this result. Next, we want the lambda F to consume the Lambda Q applied to Lambda R term. Now, that one can be evaluated. So, we're going to evaluate that first, and Lambda Q is going to consume the Lambda R term, we're going get this. Finally now, we can pass that into the Lambda F, so we get this thing, so, the body was F applied to Lambda z.z, so now we have Lambda r.r applied to Lambda z.z, the lambda R is going to consume the lambda Z term, and we're going to get this final result. Next is normal order, which is kind of like what the C pre-processor uses, if you're familiar with that. It's called call by name, and the idea, is that when you do the substitution, it's like a cut and paste. You don't evaluate the term before you substitute it in. This is going to have some effects which we'll talk about later. So, again we're going to start with the leftmost outermost application, but we're going do the Beta reduction right away, instead of trying to reduce the argument first. So here, the first step is the same as the last time, but the second step, we have this Lambda Q applied to Lambda R term, and we're going to feed that into the Lambda F right away. So, it gives us this term now. So, now the Lambda Q Lambda R is the thing we want to reduce, so we get this as our result, and finally we do the Lambda R. So we get this. So, you'll notice, that we got the same result. You may be wondering if that's always true. So, we'll talk about that. So, there's interesting effects, when you choose these two application orders. Applicative order usually has fewer reductions, we think of usually being in quotes, because it's not like we run statistics to figure out what Lambda calculus terms there are, but the intuition is that, if you have more than one occurrence of the variable inside the function body, well, applicative order means you get the value and then pass that in, if you did normal order, then you have the computation passing, every time you see the variable, you're going to have to redo the computation. So here, this Lambda A applied to Lambda B, we'd want to do that first before passing it in because the variable X occurs four times inside that body. We don't want to do that four times, we'd rather just do it one time. However, sometimes normal order wins. So, here, x does not occur in the body at all, believe it or not, sometimes that's a useful thing to have happen, and so we don't want to do this computation. So, normal order won't even do the Lambda A applied to Lambda B, it'll just leave it alone, and throw it away. Now, and I answer the question, do they yield the same result? Yes, but with one caveat. The term must terminate. Sometimes there are Lambda calculate sequences that don't terminate, you'll see one in your activities, but if it doesn't terminate, of course, we can't say that it gives you the same answer because sometimes one will terminate and the other one will not. So, now let's talk about, when is it okay to stop. To do that, I want you to look at this haskell code. You see this anonymous function Lambda z.z, when do you expect it to occur? Typically, you'd expect that to happen after foo has been called. We think that foo should get its variables first, and then we're going do that. Now, if you're looking at this, you might say, "well you know, we can optimize this out. We could do this right away. Couldn't we?" In this case, it's a simple example, we could, but, it doesn't always work out that way. If your answer is, "I'm going to do this right away, even though I don't know what the value of Y is," then what you've got is something called normal order, or normal form, but if you're going to wait until the function gets called first, then what you have is something called weak head normal form. In weak head normal form, the root of the term is a Lambda, and everything else is the body of the function. There may be Beta reductions that are doable inside there, but if you're reducing the weak head normal form, you stop. This is what most real programming languages do. You don't want to evaluate inside the body of a function until you know what all the variables are. In normal form, you go ahead and descend into the body and you keep going. This gives you smaller expressions usually, and they're called normalized. Well, there's a couple of problems with doing normal form. One is, sometimes you end up having things that don't terminate, that would've terminated if you had waited, if you've done weak head normal form instead. The other, is that it's possible to get Alpha capture. So, here we have this example, Lambda Y, and inside there's this Lambda xy.x applied to Y, that's going to cause that Y to get captured. That doesn't happen if you just do weak head normal form. So, what are we going to do in class? We're usually going to use normal form, just because it reveals the structure of what's going on in the computations. We're not using this in a practical manner, we're using it more of understanding what's happening with our functions. And as far as the order of evaluation, we'd like you to know both applicative and normal order. We'll tell you which one we want you to use. Sometimes it makes a difference, but thankfully, many times it doesn't. So, you could be good on that. So, in our next couple of videos after this, I'm going to show you some very strange things you can do with Lambda calculus, because I told you before that it's string complete, so I'm going to show you how to build, how to represent numbers and linked lists, and even recursion in just pure Lambda calculus.