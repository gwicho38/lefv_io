1
00:00:00,000 --> 00:00:02,835
Hello, everyone. Welcome back.

2
00:00:02,835 --> 00:00:05,610
In the last video, we discussed regular expressions

3
00:00:05,610 --> 00:00:08,220
and a bit about what we could do with them.

4
00:00:08,220 --> 00:00:10,920
It turns out that the grammar notation we went over

5
00:00:10,920 --> 00:00:13,830
previously in the introduction to grammars lecture,

6
00:00:13,830 --> 00:00:17,580
can encode regular expressions very simply using right-linear grammars.

7
00:00:17,580 --> 00:00:18,960
So, when you're done with this video,

8
00:00:18,960 --> 00:00:23,010
you'll be able to convert between regular expressions and write linear grammars.

9
00:00:23,010 --> 00:00:26,070
Now, we talked briefly about this in

10
00:00:26,070 --> 00:00:28,890
the introduction to grammar's lecture, but to review.

11
00:00:28,890 --> 00:00:34,080
A right-linear grammar is a grammar in which every production has the form A goes to X,

12
00:00:34,080 --> 00:00:36,150
where X is a terminal symbol,

13
00:00:36,150 --> 00:00:39,345
or A goes to xB, where B is another non-terminal.

14
00:00:39,345 --> 00:00:43,050
We can also have rules like A goes to B directly.

15
00:00:43,050 --> 00:00:44,890
Now, here's the point,

16
00:00:44,890 --> 00:00:47,030
you can think of the non-terminal symbols as

17
00:00:47,030 --> 00:00:51,520
a state machine and terminal symbols as transitions.

18
00:00:51,520 --> 00:00:56,370
The A production, A writer xB means that in state A,

19
00:00:56,370 --> 00:00:57,825
if we see an input X,

20
00:00:57,825 --> 00:01:00,480
we transition to state B.

21
00:01:00,480 --> 00:01:02,670
Let's look at an example.

22
00:01:02,670 --> 00:01:06,995
Here's a state machine that accepts an input string ASDF,

23
00:01:06,995 --> 00:01:08,390
and as states q_0,

24
00:01:08,390 --> 00:01:11,200
q_1, and all the way to q_4.

25
00:01:11,200 --> 00:01:15,480
Now, below is an equivalent right-linear grammar with non terminals, S_1,

26
00:01:15,480 --> 00:01:20,755
S_2, etc., correspond exactly to the states enable state machine.

27
00:01:20,755 --> 00:01:25,675
Here's a more complicated regular expression and its corresponding state machine.

28
00:01:25,675 --> 00:01:29,370
The representation as a right-linear grammar is similar.

29
00:01:29,370 --> 00:01:34,285
Each state becomes a non-terminal and each transition is a terminal symbol.

30
00:01:34,285 --> 00:01:37,680
We briefly covered how to convert a regular expression to

31
00:01:37,680 --> 00:01:41,535
a Non-Deterministic Finite Automata using Thompson's construction.

32
00:01:41,535 --> 00:01:44,580
Now, CS 374 offers how to convert

33
00:01:44,580 --> 00:01:49,575
a Non-Deterministic Finite Automata to a Deterministic Finite Automata or DFA.

34
00:01:49,575 --> 00:01:53,045
We have a DFA, it's easy convert that into a right-linear grammar,

35
00:01:53,045 --> 00:01:58,300
though in fact, the conversion to DFA is optional.

36
00:01:58,640 --> 00:02:01,620
We can also convert from

37
00:02:01,620 --> 00:02:05,595
regular expression directly by building up a right-linear grammar.

38
00:02:05,595 --> 00:02:08,590
Individual letter becomes a production in the grammar.

39
00:02:08,590 --> 00:02:11,665
So, here we have two regular expressions, A and B,

40
00:02:11,665 --> 00:02:15,875
and they become productions S_1 goes to A and S_2 goes to B.

41
00:02:15,875 --> 00:02:18,375
Now, to make the regular expression AB,

42
00:02:18,375 --> 00:02:21,945
we just have the S_1 production include S_2.

43
00:02:21,945 --> 00:02:24,810
Now, to choose between two regular expressions,

44
00:02:24,810 --> 00:02:28,000
we can just create a new production that gives us a choice between the two,

45
00:02:28,000 --> 00:02:30,300
like the S production we have here.

46
00:02:30,300 --> 00:02:32,920
To implement repetition, all you have to do is

47
00:02:32,920 --> 00:02:35,650
have a production that goes back to the initial symbol.

48
00:02:35,650 --> 00:02:41,945
There's an example here with A or B and A or B repeated that shows how to do that.

49
00:02:41,945 --> 00:02:44,595
If you want star instead of plus,

50
00:02:44,595 --> 00:02:47,950
you can add an Epsilon production to the start symbol.

51
00:02:48,080 --> 00:02:50,370
That's actually it.

52
00:02:50,370 --> 00:02:52,890
It's a pretty simple algorithm,

53
00:02:52,890 --> 00:02:55,240
but to give credit where credit is due,

54
00:02:55,240 --> 00:02:57,380
this particular way of presenting it is partly

55
00:02:57,380 --> 00:03:00,185
based on this discussion I found at this website.

56
00:03:00,185 --> 00:03:02,640
Found that to be very helpful.