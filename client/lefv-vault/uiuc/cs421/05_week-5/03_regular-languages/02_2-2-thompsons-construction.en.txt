Hello, everyone. Welcome back. In the last video, we discussed regular expressions and a bit about what we could do with them. It turns out that the grammar notation we went over previously in the introduction to grammars lecture, can encode regular expressions very simply using right-linear grammars. So, when you're done with this video, you'll be able to convert between regular expressions and write linear grammars. Now, we talked briefly about this in the introduction to grammar's lecture, but to review. A right-linear grammar is a grammar in which every production has the form A goes to X, where X is a terminal symbol, or A goes to xB, where B is another non-terminal. We can also have rules like A goes to B directly. Now, here's the point, you can think of the non-terminal symbols as a state machine and terminal symbols as transitions. The A production, A writer xB means that in state A, if we see an input X, we transition to state B. Let's look at an example. Here's a state machine that accepts an input string ASDF, and as states q_0, q_1, and all the way to q_4. Now, below is an equivalent right-linear grammar with non terminals, S_1, S_2, etc., correspond exactly to the states enable state machine. Here's a more complicated regular expression and its corresponding state machine. The representation as a right-linear grammar is similar. Each state becomes a non-terminal and each transition is a terminal symbol. We briefly covered how to convert a regular expression to a Non-Deterministic Finite Automata using Thompson's construction. Now, CS 374 offers how to convert a Non-Deterministic Finite Automata to a Deterministic Finite Automata or DFA. We have a DFA, it's easy convert that into a right-linear grammar, though in fact, the conversion to DFA is optional. We can also convert from regular expression directly by building up a right-linear grammar. Individual letter becomes a production in the grammar. So, here we have two regular expressions, A and B, and they become productions S_1 goes to A and S_2 goes to B. Now, to make the regular expression AB, we just have the S_1 production include S_2. Now, to choose between two regular expressions, we can just create a new production that gives us a choice between the two, like the S production we have here. To implement repetition, all you have to do is have a production that goes back to the initial symbol. There's an example here with A or B and A or B repeated that shows how to do that. If you want star instead of plus, you can add an Epsilon production to the start symbol. That's actually it. It's a pretty simple algorithm, but to give credit where credit is due, this particular way of presenting it is partly based on this discussion I found at this website. Found that to be very helpful.