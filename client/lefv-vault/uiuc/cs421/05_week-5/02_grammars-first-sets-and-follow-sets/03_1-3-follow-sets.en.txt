Hello and welcome back. In the last video, we talked about FIRST sets which tell us the first thing that we could be looking at when trying to parse a non-terminal symbol. Now we're going to ask a different question. How do I know if I'm done with the symbol? We can tell we are done by having a list of symbols that follow a non-terminal. So when you're done with this video, you'll be able to compute the FOLLOW set for all the non-terminal symbols in a grammar. Now, the first thing to understand about FOLLOW sets is that this is a list of symbols that occur after you've completed parsing the non-terminal. The symbol is not part of the parse tree for that non-terminal. Since the symbols have a parser which is often implemented as a state machine, it's going to know that it's done. A formula that is simpler than for first sets but in my opinion it's a bit more subtle at the same time. Now, at the start, you put the dollar sign symbol in the FOLLOW set of your start symbol. The dollar sign here stands for the end of input. It simply says that after the start symbol is done, there should be no more input. For the next two rules, I should mention that the Greek letters alpha and beta represent arbitrary strings of both terminal and non-terminal symbols. Now, for rule two, you take all the productions of the form X goes to alpha Y beta and add the FIRST set of beta to the FOLLOW set of Y. This is because whatever beta starts with, it comes after Y. Also, we do not propagate epsilon sent to FOLLOW sets. Rule three takes care of that though. If we have a production of the form X goes to alpha Y, either because there's nothing after Y or because there is a beta after Y and epsilon is a member of beta's FIRST set, then we add X's FOLLOW set to Y's FOLLOW set. I find that this third rule sometimes confuses people, so in the next slide, I have a picture to illustrate what's going on. Example one here shows the rule X go to alpha Y beta. You see that the beta follows Y. Example two shows what happens when we have X goes to alpha Y. If we know that when X is done we could see Z, then that means Y is done, we could see Z. My favorite analogy is this, suppose you know that after the weekend is over, it will be Monday. So, Monday is to FOLLOW set of weekend. Well, a weekend consists of Saturday and Sunday, so that means after Sunday is over, we can see a Monday. But because Monday is in the FOLLOW set of weekend, it also gets to be in the FOLLOW set of Sunday. Here's some small examples. In example one, we would have a dollar sign in the FOLLOW set of S. I've not bothered putting that here. We see in the rule that y comes after A, so y is a member of A's FOLLOW set. Example two, we have a B at the end of the A rule and since A's FOLLOW set is y, we add y to B's FOLLOW set. In example three, we have B goes to C, E, D. If we assume the FIRST set of D is a and b, then we have to add B's FOLLOW set to D and D's FOLLOW set to E. In example four, let's see what happens if we also add an epsilon to the FIRST set of D. That case, we add B's FOLLOW set to D as before but we would also have to add it to E's FOLLOW sets since the D could drop out. Let's take the FOLLOW sets of those examples from the last video. Like the FIRST set algorithm, the FOLLOW set algorithm is iterative and builds up its answer. We start by adding dollar sign to S's FOLLOW set. The first rule gives us then following E and semicolon following S. The second and third rules give us semicolon and plus following E. The fourth rule has ID following P. The fourth rule also has a P at the end of an E production. So we add E's FOLLOW set to P. We would then want to iterate over the rules again to be sure nothing has changed but in our case nothing has so we're done. Now, let's look at the crazy example. We start by adding dollar sign to the FOLLOW set of S. Now, x comes after A, so we add x to A's FOLLOW set, y follows B so we add y to B's FOLLOW set. These four rules don't add anything to any of the FOLLOW sets so we're done with them. We have a B at the end of an A production. So add A's FOLLOW set to B. B can become epsilon, so we add A's FOLLOW set to see as well. Finally, since C is at the end of the B production, we add B's FOLLOW set to C. That's it for FIRST and FOLLOW sets. We will use them in the coming parsing lectures as part of our algorithms in order to do LO and LR parsing. So, that's why we need to compute these things.