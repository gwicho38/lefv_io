Hello and welcome back. In the last video, we introduced our notation for grammars and discussed some of the properties that grammars could have. Now we're gonna talk about how to get started parsing them. The full process of parsing is quite complex, so we're going to break it down into more manageable steps. In this video we're going talk about first sets, it is: What is the first terminal symbol you could encounter, while parsing a particular non-terminal. Your objectives are simple enough to state, you should be able to compute the first set for the non terminal symbols of a given grammar. Now the big picture, is that we have some grammar for a language L that we want to parse. Grammar consists of a bunch of productions that tell us how to construct a non-terminal from other symbols. We can't just look at a stream of tokens and tell them on a glance, whether or not it correctly constructs that non-terminal symbol, but we can make a list of the first symbols we would see in a correct construction. As example what I mean, consider the grammar on this slide. The two E rules say that, an E is a Z followed by another E, are also Q. In English, this means that E is a series of zero more Z's followed by a Q, the actual number of Z's is arbitrary. To simplify things, we can see that the first set of E is Z and Q. If we are trying to parse an E, we can check to see if the next token being parsed is a Z or Q. If it is, we carry on with the parse, otherwise we abort with an error message. The algorithm to compute first sets is an iterative one. We build up our list of first sets, until there's nothing more left to add. We start by assuming that the first set of each symbol is empty, and then for each symbol X in our grammar, we have one of three cases. First, X might be a terminal symbol, in that case X is its own first set. Second, there might be a production of the form X goes to Epsilon. In that case we add epsilon to first of X. Remember, this epsilon rule means that X is optional and that it could just drop out. The third case, suppose there is a production of the form X goes to Y one, Y two, et cetera, what we do is we take the first set of Y one, Y two, et cetera, and add that to the first set of X. How do we do that? Well, we have to look at the first symbol in the string of Ys. There are three things that could happen there. It maybe that Y one does not contain epsilon. In that case, we just use the first set of Y one. None of the other symbols will contribute it to the FIRST set since Y one is blocking them. The second sub-case, it may be that first of Y one does contain epsilon. When that happens, we just add the first set of Y one excluding epsilon, to the first set of X. Then we take the first set of the rest of the symbols starting from Y two, and add that to the first of X. This accounts for when Y one disappears. The final sub-case is interesting. It may be that all of those Y's contain epsilon. When that happens, we add epsilon to first of X directly. Here's a diagram I like to use to understand that third case. Suppose we have a symbol X, that has a production taking it to Y zero, Y one, Y two. To parse an X, we must first parcel Y zero. Whatever is in Y zero's first set, must also be in X's first set. Now, if Y zero has an epsilon production, then Y zero could disappear leaving Y one as the first symbol of X. Finally, it could happen that all of Y zero, Y one and Y two become epsilon, which mean that X itself could become epsilon. Here's some small examples. In example one we have a production S goes to xAB, since X is a terminal symbol, the first set of xAB is simply x. So, therefore the first set of S is also simply X. In example two, we have three A productions, we add Y and Z to the first set of A, because of the second and third productions, and we add epsilon to the first set of A because of the first production. In example three, we have these two B productions, which make use of the A symbol from example two. We had R to the first set of B because of the second production, and we add the first set of A to B, because of the first production, but we leave out epsilon, instead we add the Q that comes after the A. Finally in example four, we had the first set of A to C, because of the first production, and since both of these A symbols can become epsilon, we add epsilon to C's first set as well. The second production causes us to add B's first set to C's first set. Let's go through a more complete example now. We'll use this grammar which describes the language with if, then statements, print statements, and expressions that have identifiers pointers and plus. The way I like to do this is create a table, with the empty sets off to the side. The first thing I do, is go through their productions and identify all the ones that start with a terminal symbol. I add these symbols to the corresponding first sets, and then I know I'm done with those productions for the rest of the calculation. The next thing I do, is go from the top of the grammar to the bottom, and process each production one at a time. I can skip all the ones that begin with the terminal symbol since we took care of that on the last slide. The first rule we would look at is, E goes to E plus E, which doesn't do anything for us right now since we haven't added anything to E's first set yet. The next production is E goes to PID. We add P's first set to E's, omitting the epsilon and advancing to add the ID symbol. Once you've gone down the list, you do it again to see if anything you've changed has an effect on the previous rule. The only one that could change is the E goes to E plus E rule, but since E doesn't have an epsilon production, this doesn't add anything new. Therefore, we're done. Let's look at a more complicated grammar. This one doesn't have any meaning, it's just a complicated enough grammar to demonstrate all the weird things that can happen while computing a first set. The first step is to add all the initial terminals and epsilon rules. This leaves us with just three rules to check. Let's check S goes to Ax. The first set of A has 1 and 2 in it, we need to add those to the first set of S. Now let's check S goes to BY. This makes us need to add three from B's first set to A's first set. Now, let's check B goes to C. We have to add four and epsilon. Before I told you that you should emit epsilon new copy from another first set, but in this case we keep it because C's the only symbol there is. This is that third sub-case from earlier when all the symbols on the right hand side could become epsilon. Now you might be thinking wait a minute, we added these First set to A one step ago, but now we've added more stuff to B. This is correct, and this is why we need to iterate through the rules again. We start from the top with S goes to Ax again, but this doesn't do anything. Next, we check S goes to BY, and we add the four. Since there is an epsilon, we have to go forward to the next symbol, which means we also have to add the Y. Finally, we check B goes to C, and this doesn't add anything new. At this point, your algorithm would take one more pass through the whole thing, but that wouldn't add any new symbols, so now we are done. There you have it. In the next video we'll talk about a related concept called the FOLLOW set.