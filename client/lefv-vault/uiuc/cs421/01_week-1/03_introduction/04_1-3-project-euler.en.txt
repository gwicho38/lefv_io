Hello everyone, welcome to CS 421. In this video, I want to talk about those Project Euler problems that we mentioned. I am going to split this up into two videos just so that it's not too long. This first one, we will just talk about how to set up your environment a little bit and go over first of the Euler problems. The whole point of this video is not really to be like a Haskell tutorial, it's more of a just have you be able to see what the language looks like. So, we are going to go a little bit fast. The point is not that you get a deep understanding, but just kind of get a flavor for what the language looks like. You will get to see a lot more of the language as we go. So, the first thing you want to do is create a file called euler.hs, and usually I like to put it in its own directory just to keep everything separate, but however you want to do that, and I want you to put these two lines in there. So the first line, it says inc the double colon integer arrow integer. That double colon is usually read has type. So, this is a type declaration. It says inc has type integer arrow integer. So, it's a function that takes an integer as input and returns an integer as its output. The next line is the definition of the function. So inc applied to x is equal to x plus one. So, you will notice that in Haskell function applications we don't use parentheses around the parameter list like you do in many other languages. Instead we will use juxtaposition to do this. So, once you have gone ahead and added those two lines, if you are using the Haskell stack framework you type stack repl euler.hs; repl, that's a word you are are going to hear a lot in this class. It means Read-Eval-Print-Loop. What it basically is it's an interactive environment that you can program in, you can type stuff in it, or execute it right away. So, if you type this on a system like the one I am using then you will get a bunch of output and then finally if all goes well, you will get this prompt the star main. It tells you that it's loaded the main module. There will be other lines too but I deleted them because they won't fit on the slide and you might even get a warning or something like that, but as long as you get this prompt back then everything is well. So, one of the first things we might want to do is you can use this colon T command and what that does is ask Haskell to tell you what the type of something is. So, here we can say colon T inc and then it comes back and says that increment has type integer arrow integer. We can run inc. So type inc 10 and hit return and it comes back with 11. The other command which is super useful is this colon R. That means reload. So what I would like to do is have one window open that has my program in it in the editor, and then another window that has a stack, has Haskell repl in it, and that way you can very easily make a change and then reload the file and see what happens. So, let's go ahead and try the first euler problem, the multiples of three or five. So what we want to do is take all the numbers that are either a multiple of three or five, and you have to be a little bit careful how you do this because otherwise you can double count. We could get all the multiples of three and all the multiples of five but then numbers like 15 would be double counted. So, we don't want to do that. So, how can we do this? The first thing you need is a modulus function. So in Haskell it's mod, and that takes two parameters so mod applied to 10 and three gives us back one. Now, one thing that is often done with arithmetic type functions is, if you put back ticks around the name of a function that means the function is infix. So, you can say 10 mod three and it's a little bit more natural way of doing it. Double equal is the comparison like in most languages and the double bars or so here we can say 10 mod three is zero or 10 mod five is equal to zero and then we can go ahead and build that into a function. So, I will create this function mod3or5 by the x is equal to either x mod three is zero or x mod five equals zero. So go ahead and write this into your euler.hs and go ahead and make that function definition. Now, one thing you will notice, we didn't actually get around to giving the type declaration for this. So one of the nice things about Haskell is that Haskell will infer the type of things if you don't specify them manually. So, we can use the colon T to check mod3or5 and see what Haskell doubt. You will get this slightly more complicated type signature. So, the part before the equal greater than, the double arrow looking thing, this is called the type constraint. It says we have some type A which is a type variable, we don't know what it is, but we do know it's type Integral. So, that's basically integers. There's two different kinds of integers in Haskell. We will talk about that in a little bit, but whatever, as long as you have that so basically saying that modulus is defined for this type and then we get a Boolean back. So, next thing we wanted to be able to do is build up a list. One of the ways we do that in Haskell is you have the square brackets and then you list out all of the numbers inside of them separated by commas. If you are familiar with Python it's very similar syntax. Now, lists are used very very frequently in Haskell. So there's a lot of built-in functions that work on them. Two of them are map and filter. What map does is it takes a function and applies that function to every element of a list and gives you back a new list with that result. So, if I see map inc three, five, seven, nine then I get four, six, eight, 10 back. If I map mod3or5 then it's going to give me a bunch of Booleans, right? True, true, false, true. Now, filter is similar to map except what it does is that anything that the function returns true for, it keeps that and anything that returns false for, it throws out. So, if I say filter mod3or5 on this then I keep the three, five and nine. So finally once we have that all we have to do is take the sum and we are good to go. So only thing that we need to do now is get a list from one to 999 and you could write a recursive function to do that, but there's also another built-in syntax which makes that easy for us. So, here's a few examples here. I can get the list of one through 20. If you put a comma and specify a step then that will tell us like one, three, five, it will go by twos or by fours what have you. We don't see that very often. But anyway, we can do a list from one to 999 and then just go ahead and put that into sumMods and we are good to go. So go ahead and add that to our file reload. Type euler1 and then there's the solution. So, you can go to the Project Euler website and type that in if you want. If you typed all that into the file, your file probably looks something like this now. One thing that you will often see happen in Haskell is that if people have helper functions we tend not to want them at the top level. So, we have this thing called a where clause, and it's supposed to look kind of like mathematics. So, euler1 is equal to sumMods where and then we have these two helper functions on line seven and eight. Now, one thing to understand about Haskell is indentation counts. The scope of a function is determined by its indentation. So that sumMods, if you were to un-indent that, then it wouldn't be part of the where clause anymore. It would be considered top level. But one really big got you in this language, gets beginners a lot, is some people use editors that have tab characters in them and if you do that then it's very easy to get these weird syntax errors because different editors interpret the tab character for different number of spaces. Sometimes it's four, sometimes it's eight, and Haskell I believe goes by eight. If you use tab in your editor then there's a good chance that when you go to load it in Haskell you are going to get some strange error messages about things not being in scope. So what I highly recommend you do is change your editor so it doesn't use tab characters at all. Only let it use spaces. And that will actually make things go a lot more smoothly for you. All right, so that's problem one and the next video I will go over the other two problems.