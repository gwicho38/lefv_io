1
00:00:00,000 --> 00:00:01,950
Hello everyone, welcome back.

2
00:00:01,950 --> 00:00:03,930
Just want to go over a few slides about

3
00:00:03,930 --> 00:00:06,690
the language we're going to use in this course called Haskell.

4
00:00:06,690 --> 00:00:10,380
So, how do you go about picking a language for programming language course?

5
00:00:10,380 --> 00:00:13,410
One of the things that I assume is that you already know

6
00:00:13,410 --> 00:00:16,980
a lot about the imperative languages like Java, or C++,

7
00:00:16,980 --> 00:00:21,870
and object-oriented languages, but you're not as likely to have seen

8
00:00:21,870 --> 00:00:24,255
a functional programming language which is

9
00:00:24,255 --> 00:00:27,530
where the Haskell is part of that language family.

10
00:00:27,530 --> 00:00:30,315
It turns out in industry and research,

11
00:00:30,315 --> 00:00:33,290
the functional languages are becoming increasingly important.

12
00:00:33,290 --> 00:00:37,820
They are actually very good at things involving say multi-core.

13
00:00:37,820 --> 00:00:40,280
They also tend to be more mathematically

14
00:00:40,280 --> 00:00:43,670
pure than the imperative object-oriented languages,

15
00:00:43,670 --> 00:00:45,280
so it's easier to reason about them.

16
00:00:45,280 --> 00:00:49,220
There's been studies shown that programmer productivity is much,

17
00:00:49,220 --> 00:00:51,800
much higher in a functional programming language.

18
00:00:51,800 --> 00:00:53,730
So we're going to use language Haskell.

19
00:00:53,730 --> 00:00:56,030
Haskell has been around for a little while now.

20
00:00:56,030 --> 00:00:59,960
There was a time when programming language researchers they would

21
00:00:59,960 --> 00:01:04,040
try to publish your ideas and there'd be all different languages needed for this,

22
00:01:04,040 --> 00:01:06,739
and it became increasingly difficult to communicate,

23
00:01:06,739 --> 00:01:11,270
so they decided that it would be nice to have a single language and they can all use.

24
00:01:11,270 --> 00:01:15,355
So, late 80s they began putting together this language.

25
00:01:15,355 --> 00:01:17,330
One of the things that they really wanted was

26
00:01:17,330 --> 00:01:19,570
this language not to become very successful.

27
00:01:19,570 --> 00:01:22,940
They didn't want there to be a large community of people using it,

28
00:01:22,940 --> 00:01:26,280
they wanted it to be somewhat small so that they could change the language a lot.

29
00:01:26,280 --> 00:01:28,645
They didn't want to have to deal with legacy code.

30
00:01:28,645 --> 00:01:31,500
Unfortunately for them, the language didn't become popular,

31
00:01:31,500 --> 00:01:33,335
reached a certain critical mass,

32
00:01:33,335 --> 00:01:36,580
the language is actually used even in industry now like,

33
00:01:36,580 --> 00:01:40,120
for example, on Facebook they use it to do their spam filter.

34
00:01:40,120 --> 00:01:42,980
So, some of the features of the language it's called

35
00:01:42,980 --> 00:01:44,990
a higher-order functional language and we'll talk

36
00:01:44,990 --> 00:01:47,395
about what that means in future lectures.

37
00:01:47,395 --> 00:01:50,800
The syntax of Haskell is very concise.

38
00:01:50,800 --> 00:01:53,400
It looks kind of like you're writing in mathematics.

39
00:01:53,400 --> 00:01:56,725
It's a very clean looking language.

40
00:01:56,725 --> 00:01:58,390
They have a type inference,

41
00:01:58,390 --> 00:02:01,560
which means you don't have to declare the type of things if you don't want to,

42
00:02:01,560 --> 00:02:03,660
it's good practice to do so anyway,

43
00:02:03,660 --> 00:02:07,400
but the language was actually infer the types of everything for

44
00:02:07,400 --> 00:02:10,940
you and they will complain if there is something that's mismatching,

45
00:02:10,940 --> 00:02:14,570
but you will find as you get to know this language that if

46
00:02:14,570 --> 00:02:16,550
the compiler says that there's

47
00:02:16,550 --> 00:02:20,405
no type errors and you're probably pretty close to having a working program.

48
00:02:20,405 --> 00:02:24,170
But for our purposes what we really want is that this language is

49
00:02:24,170 --> 00:02:28,065
very good for writing other languages and implementing other languages with them.

50
00:02:28,065 --> 00:02:31,905
So, to give you a demo of what this language is like, what I'd like you to do,

51
00:02:31,905 --> 00:02:35,810
there is a handout on the website for Project Euler,

52
00:02:35,810 --> 00:02:39,170
there's just three problems that came off that website.

53
00:02:39,170 --> 00:02:42,230
So, I'd like you to try writing them in your favorite language,

54
00:02:42,230 --> 00:02:46,805
and then I'm going to show you a few slides of how to write them in Haskell.

55
00:02:46,805 --> 00:02:49,350
We'll see how that goes.