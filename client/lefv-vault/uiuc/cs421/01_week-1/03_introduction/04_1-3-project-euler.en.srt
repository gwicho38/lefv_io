1
00:00:00,000 --> 00:00:02,290
Hello everyone, welcome to CS 421.

2
00:00:02,290 --> 00:00:06,060
In this video, I want to talk about those Project Euler problems that we mentioned.

3
00:00:06,060 --> 00:00:09,440
I am going to split this up into two videos just so that it's not too long.

4
00:00:09,440 --> 00:00:12,360
This first one, we will just talk about how to set up your environment a

5
00:00:12,360 --> 00:00:15,880
little bit and go over first of the Euler problems.

6
00:00:15,880 --> 00:00:19,919
The whole point of this video is not really to be like a Haskell tutorial,

7
00:00:19,919 --> 00:00:24,125
it's more of a just have you be able to see what the language looks like.

8
00:00:24,125 --> 00:00:26,195
So, we are going to go a little bit fast.

9
00:00:26,195 --> 00:00:29,039
The point is not that you get a deep understanding,

10
00:00:29,039 --> 00:00:32,100
but just kind of get a flavor for what the language looks like.

11
00:00:32,100 --> 00:00:34,550
You will get to see a lot more of the language as we go.

12
00:00:34,550 --> 00:00:38,125
So, the first thing you want to do is create a file called euler.hs,

13
00:00:38,125 --> 00:00:41,900
and usually I like to put it in its own directory just to keep everything separate,

14
00:00:41,900 --> 00:00:43,605
but however you want to do that,

15
00:00:43,605 --> 00:00:46,160
and I want you to put these two lines in there.

16
00:00:46,160 --> 00:00:47,415
So the first line,

17
00:00:47,415 --> 00:00:50,500
it says inc the double colon integer arrow integer.

18
00:00:50,500 --> 00:00:53,035
That double colon is usually read has type.

19
00:00:53,035 --> 00:00:55,120
So, this is a type declaration.

20
00:00:55,120 --> 00:00:57,295
It says inc has type integer arrow integer.

21
00:00:57,295 --> 00:01:01,625
So, it's a function that takes an integer as input and returns an integer as its output.

22
00:01:01,625 --> 00:01:04,575
The next line is the definition of the function.

23
00:01:04,575 --> 00:01:07,840
So inc applied to x is equal to x plus one.

24
00:01:07,840 --> 00:01:11,630
So, you will notice that in Haskell function applications we

25
00:01:11,630 --> 00:01:15,830
don't use parentheses around the parameter list like you do in many other languages.

26
00:01:15,830 --> 00:01:18,970
Instead we will use juxtaposition to do this.

27
00:01:18,970 --> 00:01:21,890
So, once you have gone ahead and added those two lines,

28
00:01:21,890 --> 00:01:26,995
if you are using the Haskell stack framework you type stack repl euler.hs;

29
00:01:26,995 --> 00:01:29,760
repl, that's a word you are are going to hear a lot in this class.

30
00:01:29,760 --> 00:01:32,315
It means Read-Eval-Print-Loop.

31
00:01:32,315 --> 00:01:36,835
What it basically is it's an interactive environment that you can program in,

32
00:01:36,835 --> 00:01:37,980
you can type stuff in it,

33
00:01:37,980 --> 00:01:39,480
or execute it right away.

34
00:01:39,480 --> 00:01:42,830
So, if you type this on a system like the one I am

35
00:01:42,830 --> 00:01:46,570
using then you will get a bunch of output and then finally if all goes well,

36
00:01:46,570 --> 00:01:48,770
you will get this prompt the star main.

37
00:01:48,770 --> 00:01:51,125
It tells you that it's loaded the main module.

38
00:01:51,125 --> 00:01:54,470
There will be other lines too but I deleted them because they won't fit

39
00:01:54,470 --> 00:01:57,710
on the slide and you might even get a warning or something like that,

40
00:01:57,710 --> 00:02:00,345
but as long as you get this prompt back then everything is well.

41
00:02:00,345 --> 00:02:03,920
So, one of the first things we might want to do is you can use

42
00:02:03,920 --> 00:02:06,650
this colon T command and what that does is

43
00:02:06,650 --> 00:02:09,420
ask Haskell to tell you what the type of something is.

44
00:02:09,420 --> 00:02:12,020
So, here we can say colon T inc and then it

45
00:02:12,020 --> 00:02:15,095
comes back and says that increment has type integer arrow integer.

46
00:02:15,095 --> 00:02:16,450
We can run inc.

47
00:02:16,450 --> 00:02:19,805
So type inc 10 and hit return and it comes back with 11.

48
00:02:19,805 --> 00:02:24,350
The other command which is super useful is this colon R. That means reload.

49
00:02:24,350 --> 00:02:27,050
So what I would like to do is have one window open that

50
00:02:27,050 --> 00:02:29,720
has my program in it in the editor,

51
00:02:29,720 --> 00:02:32,110
and then another window that has a stack,

52
00:02:32,110 --> 00:02:33,710
has Haskell repl in it,

53
00:02:33,710 --> 00:02:35,990
and that way you can very easily make

54
00:02:35,990 --> 00:02:38,540
a change and then reload the file and see what happens.

55
00:02:38,540 --> 00:02:41,505
So, let's go ahead and try the first euler problem,

56
00:02:41,505 --> 00:02:42,975
the multiples of three or five.

57
00:02:42,975 --> 00:02:44,900
So what we want to do is take

58
00:02:44,900 --> 00:02:48,110
all the numbers that are either a multiple of three or five,

59
00:02:48,110 --> 00:02:49,820
and you have to be a little bit careful how you do

60
00:02:49,820 --> 00:02:51,940
this because otherwise you can double count.

61
00:02:51,940 --> 00:02:54,800
We could get all the multiples of three and all the multiples of

62
00:02:54,800 --> 00:02:57,990
five but then numbers like 15 would be double counted.

63
00:02:57,990 --> 00:02:59,435
So, we don't want to do that.

64
00:02:59,435 --> 00:03:00,960
So, how can we do this?

65
00:03:00,960 --> 00:03:03,720
The first thing you need is a modulus function.

66
00:03:03,720 --> 00:03:05,480
So in Haskell it's mod,

67
00:03:05,480 --> 00:03:10,395
and that takes two parameters so mod applied to 10 and three gives us back one.

68
00:03:10,395 --> 00:03:14,510
Now, one thing that is often done with arithmetic type functions is,

69
00:03:14,510 --> 00:03:19,435
if you put back ticks around the name of a function that means the function is infix.

70
00:03:19,435 --> 00:03:24,520
So, you can say 10 mod three and it's a little bit more natural way of doing it.

71
00:03:24,520 --> 00:03:30,830
Double equal is the comparison like in most languages and the double bars or so here we

72
00:03:30,830 --> 00:03:34,010
can say 10 mod three is zero or 10 mod five is equal

73
00:03:34,010 --> 00:03:37,265
to zero and then we can go ahead and build that into a function.

74
00:03:37,265 --> 00:03:40,860
So, I will create this function mod3or5 by the x is

75
00:03:40,860 --> 00:03:44,665
equal to either x mod three is zero or x mod five equals zero.

76
00:03:44,665 --> 00:03:46,460
So go ahead and write this into your

77
00:03:46,460 --> 00:03:50,515
euler.hs and go ahead and make that function definition.

78
00:03:50,515 --> 00:03:52,070
Now, one thing you will notice,

79
00:03:52,070 --> 00:03:56,240
we didn't actually get around to giving the type declaration for this.

80
00:03:56,240 --> 00:03:59,810
So one of the nice things about Haskell is that Haskell

81
00:03:59,810 --> 00:04:03,705
will infer the type of things if you don't specify them manually.

82
00:04:03,705 --> 00:04:08,970
So, we can use the colon T to check mod3or5 and see what Haskell doubt.

83
00:04:08,970 --> 00:04:12,110
You will get this slightly more complicated type signature.

84
00:04:12,110 --> 00:04:15,710
So, the part before the equal greater than,

85
00:04:15,710 --> 00:04:17,280
the double arrow looking thing,

86
00:04:17,280 --> 00:04:19,025
this is called the type constraint.

87
00:04:19,025 --> 00:04:22,030
It says we have some type A which is a type variable,

88
00:04:22,030 --> 00:04:23,475
we don't know what it is,

89
00:04:23,475 --> 00:04:25,760
but we do know it's type Integral.

90
00:04:25,760 --> 00:04:28,205
So, that's basically integers.

91
00:04:28,205 --> 00:04:30,130
There's two different kinds of integers in Haskell.

92
00:04:30,130 --> 00:04:32,385
We will talk about that in a little bit, but whatever,

93
00:04:32,385 --> 00:04:35,450
as long as you have that so basically saying that modulus is

94
00:04:35,450 --> 00:04:39,115
defined for this type and then we get a Boolean back.

95
00:04:39,115 --> 00:04:42,170
So, next thing we wanted to be able to do is build up a list.

96
00:04:42,170 --> 00:04:46,190
One of the ways we do that in Haskell is you have the square brackets and then you

97
00:04:46,190 --> 00:04:50,680
list out all of the numbers inside of them separated by commas.

98
00:04:50,680 --> 00:04:54,550
If you are familiar with Python it's very similar syntax.

99
00:04:54,550 --> 00:04:57,365
Now, lists are used very very frequently in Haskell.

100
00:04:57,365 --> 00:05:00,595
So there's a lot of built-in functions that work on them.

101
00:05:00,595 --> 00:05:02,795
Two of them are map and filter.

102
00:05:02,795 --> 00:05:06,530
What map does is it takes a function and applies that function to

103
00:05:06,530 --> 00:05:11,280
every element of a list and gives you back a new list with that result.

104
00:05:11,280 --> 00:05:13,890
So, if I see map inc three, five, seven,

105
00:05:13,890 --> 00:05:15,290
nine then I get four,

106
00:05:15,290 --> 00:05:16,490
six, eight, 10 back.

107
00:05:16,490 --> 00:05:21,620
If I map mod3or5 then it's going to give me a bunch of Booleans, right?

108
00:05:21,620 --> 00:05:23,165
True, true, false, true.

109
00:05:23,165 --> 00:05:25,805
Now, filter is similar to map except what it

110
00:05:25,805 --> 00:05:30,110
does is that anything that the function returns true for,

111
00:05:30,110 --> 00:05:33,515
it keeps that and anything that returns false for, it throws out.

112
00:05:33,515 --> 00:05:38,635
So, if I say filter mod3or5 on this then I keep the three, five and nine.

113
00:05:38,635 --> 00:05:43,310
So finally once we have that all we have to do is take the sum and we are good to go.

114
00:05:43,310 --> 00:05:46,550
So only thing that we need to do now is get a list from one to

115
00:05:46,550 --> 00:05:49,700
999 and you could write a recursive function to do that,

116
00:05:49,700 --> 00:05:53,395
but there's also another built-in syntax which makes that easy for us.

117
00:05:53,395 --> 00:05:55,330
So, here's a few examples here.

118
00:05:55,330 --> 00:05:57,170
I can get the list of one through 20.

119
00:05:57,170 --> 00:06:03,670
If you put a comma and specify a step then that will tell us like one,

120
00:06:03,670 --> 00:06:08,525
three, five, it will go by twos or by fours what have you.

121
00:06:08,525 --> 00:06:10,505
We don't see that very often.

122
00:06:10,505 --> 00:06:13,805
But anyway, we can do a list from one to 999

123
00:06:13,805 --> 00:06:17,645
and then just go ahead and put that into sumMods and we are good to go.

124
00:06:17,645 --> 00:06:21,530
So go ahead and add that to our file reload.

125
00:06:21,530 --> 00:06:24,315
Type euler1 and then there's the solution.

126
00:06:24,315 --> 00:06:27,910
So, you can go to the Project Euler website and type that in if you want.

127
00:06:27,910 --> 00:06:29,465
If you typed all that into the file,

128
00:06:29,465 --> 00:06:31,710
your file probably looks something like this now.

129
00:06:31,710 --> 00:06:35,480
One thing that you will often see happen in Haskell is that if people

130
00:06:35,480 --> 00:06:39,365
have helper functions we tend not to want them at the top level.

131
00:06:39,365 --> 00:06:41,495
So, we have this thing called a where clause,

132
00:06:41,495 --> 00:06:44,225
and it's supposed to look kind of like mathematics.

133
00:06:44,225 --> 00:06:47,060
So, euler1 is equal to sumMods where

134
00:06:47,060 --> 00:06:50,275
and then we have these two helper functions on line seven and eight.

135
00:06:50,275 --> 00:06:54,905
Now, one thing to understand about Haskell is indentation counts.

136
00:06:54,905 --> 00:06:58,070
The scope of a function is determined by its indentation.

137
00:06:58,070 --> 00:07:00,690
So that sumMods, if you were to un-indent that,

138
00:07:00,690 --> 00:07:03,555
then it wouldn't be part of the where clause anymore.

139
00:07:03,555 --> 00:07:05,315
It would be considered top level.

140
00:07:05,315 --> 00:07:08,005
But one really big got you in this language,

141
00:07:08,005 --> 00:07:09,550
gets beginners a lot,

142
00:07:09,550 --> 00:07:16,175
is some people use editors that have tab characters in them and if you do that then it's

143
00:07:16,175 --> 00:07:18,905
very easy to get these weird syntax errors because

144
00:07:18,905 --> 00:07:22,820
different editors interpret the tab character for different number of spaces.

145
00:07:22,820 --> 00:07:24,950
Sometimes it's four, sometimes it's eight,

146
00:07:24,950 --> 00:07:28,330
and Haskell I believe goes by eight.

147
00:07:28,330 --> 00:07:32,540
If you use tab in your editor then there's a good chance that when you go to

148
00:07:32,540 --> 00:07:33,800
load it in Haskell you are going to get

149
00:07:33,800 --> 00:07:37,025
some strange error messages about things not being in scope.

150
00:07:37,025 --> 00:07:39,965
So what I highly recommend you do is

151
00:07:39,965 --> 00:07:42,865
change your editor so it doesn't use tab characters at all.

152
00:07:42,865 --> 00:07:44,250
Only let it use spaces.

153
00:07:44,250 --> 00:07:47,420
And that will actually make things go a lot more smoothly for you.

154
00:07:47,420 --> 00:07:49,370
All right, so that's problem one and

155
00:07:49,370 --> 00:07:53,190
the next video I will go over the other two problems.