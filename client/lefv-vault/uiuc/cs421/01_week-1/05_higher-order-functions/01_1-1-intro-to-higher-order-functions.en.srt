1
00:00:00,000 --> 00:00:02,435
Hello, everyone. Welcome to CS 421.

2
00:00:02,435 --> 00:00:04,965
This lecture, we're going to talk about Higher Order Functions.

3
00:00:04,965 --> 00:00:08,100
You've seen them a little bit already in a couple other examples.

4
00:00:08,100 --> 00:00:10,935
But want to get into a little of it in detail.

5
00:00:10,935 --> 00:00:12,720
So, some of the concepts we're going to cover in

6
00:00:12,720 --> 00:00:15,660
this lecture is about first-class citizens,

7
00:00:15,660 --> 00:00:17,950
in the context of programming languages,

8
00:00:17,950 --> 00:00:20,340
and we're going to talk about how to define functions that

9
00:00:20,340 --> 00:00:23,340
don't have names using sectioning and lambda.

10
00:00:23,340 --> 00:00:25,830
Then we're also going to talk about a function

11
00:00:25,830 --> 00:00:28,325
that can change the interface of another function.

12
00:00:28,325 --> 00:00:31,260
In programming languages things are said to be first-class,

13
00:00:31,260 --> 00:00:33,330
if they can be assigned to variables passed as

14
00:00:33,330 --> 00:00:36,365
parameters or return from functions as a result.

15
00:00:36,365 --> 00:00:39,050
Now most languages there's kind of

16
00:00:39,050 --> 00:00:42,620
a dichotomy between things that are first class and things that are not.

17
00:00:42,620 --> 00:00:44,785
So, for example, in C,

18
00:00:44,785 --> 00:00:47,390
you can have integers be first class.

19
00:00:47,390 --> 00:00:50,450
You can have structs be first class but functions are not.

20
00:00:50,450 --> 00:00:52,985
They have a special syntax to define them

21
00:00:52,985 --> 00:00:55,850
and they kind of have to live in their own top-level part of the world.

22
00:00:55,850 --> 00:01:00,745
Now, different languages make very different choices about which things are first-class,

23
00:01:00,745 --> 00:01:03,380
and that has a huge impact on

24
00:01:03,380 --> 00:01:06,425
the expressive ability of a program written in that language.

25
00:01:06,425 --> 00:01:10,170
In this lecture, we're going to talk about the choice at Haskell, Lisp,

26
00:01:10,170 --> 00:01:11,650
and Ocaml have made,

27
00:01:11,650 --> 00:01:15,165
that functions themselves are first-class things.

28
00:01:15,165 --> 00:01:17,565
I'll show you what that means.

29
00:01:17,565 --> 00:01:23,455
So, just to remind you the syntax of defining a function in a normal way as we have here.

30
00:01:23,455 --> 00:01:24,700
We have the square function.

31
00:01:24,700 --> 00:01:28,970
The square of A is A times A and hypotenuse squared

32
00:01:28,970 --> 00:01:33,890
is square of A plus square of B and then is just a sample run down here.

33
00:01:33,890 --> 00:01:35,630
We can look at the types,

34
00:01:35,630 --> 00:01:40,475
call the functions and they just work like you would normally expect.

35
00:01:40,475 --> 00:01:43,880
I'm going to show you something a little bit different.

36
00:01:43,880 --> 00:01:48,260
I have this function inc and another function double.

37
00:01:48,260 --> 00:01:52,350
Which do what you expect and then there's another function called Compose.

38
00:01:52,350 --> 00:01:54,415
Now look at what's happening here.

39
00:01:54,415 --> 00:01:56,145
Compose takes three arguments,

40
00:01:56,145 --> 00:02:01,465
F G and X and F and G are actually function types.

41
00:02:01,465 --> 00:02:04,455
If you look at the type of compose,

42
00:02:04,455 --> 00:02:12,515
there's the first part is T1 arrow T2 and that's the type of F. The G part is T arrow T1,

43
00:02:12,515 --> 00:02:17,300
and then finally you give it a T. The T is fed to the G which emits a T1.

44
00:02:17,300 --> 00:02:19,865
The T1 is fed to the F which emits

45
00:02:19,865 --> 00:02:24,770
the T2 and then that becomes the return value of this whole thing.

46
00:02:24,770 --> 00:02:29,020
What we can do now is we can take something like double and inc,

47
00:02:29,020 --> 00:02:30,290
you can compose them.

48
00:02:30,290 --> 00:02:32,460
So, if I compose inc doubled 10,

49
00:02:32,460 --> 00:02:35,030
first double is going to be applied to 10 to get 20

50
00:02:35,030 --> 00:02:37,660
and then inc is going to be called to that to get 21.

51
00:02:37,660 --> 00:02:41,990
So, compose is said to be a higher-order function because it takes

52
00:02:41,990 --> 00:02:47,285
two other functions as its arguments and manipulates them.

53
00:02:47,285 --> 00:02:50,630
There's another higher-order function that you will see in

54
00:02:50,630 --> 00:02:53,375
a future lecture, it's called Twice,

55
00:02:53,375 --> 00:02:55,520
takes a function and let's just say

56
00:02:55,520 --> 00:02:59,165
a victim and applies a function two times to the victim.

57
00:02:59,165 --> 00:03:05,400
So, if I twice inc 5 I get seven and twice can take itself as its own argument.

58
00:03:05,400 --> 00:03:08,610
So, twice, twice inc 4 what do you think that will do?

59
00:03:08,610 --> 00:03:13,860
You should actually open up Haskell and try it out see what happens.

60
00:03:13,860 --> 00:03:17,840
Now, another thing that you can do with functions and Haskell,

61
00:03:17,840 --> 00:03:22,860
is you can write down a function in a literal syntax without giving it a name.

62
00:03:22,860 --> 00:03:26,355
Now, if you think about it it's not that weird of a thing to do.

63
00:03:26,355 --> 00:03:27,860
Integers you do that already,

64
00:03:27,860 --> 00:03:30,050
you can write down the number 42 and you don't

65
00:03:30,050 --> 00:03:32,300
have to assign it to a variable in order to use it.

66
00:03:32,300 --> 00:03:35,400
There's this literal representation that we use.

67
00:03:35,400 --> 00:03:40,625
So, for functions there's a literal representation as well near the parts.

68
00:03:40,625 --> 00:03:42,410
First, there's a backslash.

69
00:03:42,410 --> 00:03:45,080
Backslash is often pronounced lambda and

70
00:03:45,080 --> 00:03:48,125
it's supposed to remind you of the Greek letter Lambda.

71
00:03:48,125 --> 00:03:50,510
There's another lecture that we'll go

72
00:03:50,510 --> 00:03:55,334
over called lambda calculus which is a mathematical study of functions.

73
00:03:55,334 --> 00:03:57,785
This was directly inspired by that.

74
00:03:57,785 --> 00:03:59,390
Now, after the backslash,

75
00:03:59,390 --> 00:04:00,995
there's the list of parameters.

76
00:04:00,995 --> 00:04:03,830
The example here we only have one parameter X

77
00:04:03,830 --> 00:04:07,515
but Haskell allows you to put as many as you like there.

78
00:04:07,515 --> 00:04:12,230
Then there is an arrow which separates the parameter Lisp from the body of the function,

79
00:04:12,230 --> 00:04:14,340
and then finally there's the body of the function itself.

80
00:04:14,340 --> 00:04:18,160
This is what will get executed once a function is called.

81
00:04:18,160 --> 00:04:23,000
So, to use it you just put parentheses around the thing so that Haskell knows when

82
00:04:23,000 --> 00:04:27,550
the function ends and then call like you would any other function.

83
00:04:27,550 --> 00:04:33,925
So, here we have lambda X arrow X plus one applied to 41 gives you 42.

84
00:04:33,925 --> 00:04:39,285
Now, if you look at Haskell syntax for defining functions,

85
00:04:39,285 --> 00:04:41,260
now this inc A equal A plus one.

86
00:04:41,260 --> 00:04:47,065
Internally it's the same thing as inc equal lambda A arrow A plus one.

87
00:04:47,065 --> 00:04:50,064
Also, if you have plus AB,

88
00:04:50,064 --> 00:04:54,890
we can write that down as lambda A arrow lambda B arrow A plus B.

89
00:04:54,890 --> 00:04:59,120
Now if you call plus with just one then that feeds into

90
00:04:59,120 --> 00:05:04,620
the A parameter and then you get the function back lambda B one plus B.

91
00:05:04,620 --> 00:05:09,200
So, we can actually define incus equal to plus one if we want.

92
00:05:09,200 --> 00:05:12,590
Now one equivalence you should know about with

93
00:05:12,590 --> 00:05:16,220
these anonymous functions there's something called eta equivalence.

94
00:05:16,220 --> 00:05:19,545
Will go over this again in more detail later.

95
00:05:19,545 --> 00:05:22,290
But suppose you have some function F,

96
00:05:22,290 --> 00:05:25,390
this is lambda X arrow F applied to X,

97
00:05:25,390 --> 00:05:27,940
it's the same thing.

98
00:05:27,940 --> 00:05:33,190
Okay. Suppose you have a function F and then suppose a wrapper lambda around it.

99
00:05:33,190 --> 00:05:35,685
So, lambda F arrow F applied to X,

100
00:05:35,685 --> 00:05:37,490
turns out those are identical.

101
00:05:37,490 --> 00:05:42,120
Right, if I apply F to Z then if I

102
00:05:42,120 --> 00:05:47,340
apply Z to this lambda X then the Z will just be fed into the X

103
00:05:47,340 --> 00:05:55,070
and then that will in turn feed to the F. There's also something you've seen

104
00:05:55,070 --> 00:05:59,240
sectioning before where you can take an arithmetic operator and put

105
00:05:59,240 --> 00:06:03,960
parentheses around it and then treat that as a function.

106
00:06:03,960 --> 00:06:09,800
So, here we have plus AB and I have different versions of plus that I can use for that.

107
00:06:09,800 --> 00:06:14,895
Similarly, for inc we have these other ways of writing down the increment function.

108
00:06:14,895 --> 00:06:18,155
So, the last thing I want to show you in this video.

109
00:06:18,155 --> 00:06:22,550
Sometimes you have a function which takes a pair of integers or a pair of

110
00:06:22,550 --> 00:06:27,030
things and then produces a result and you'd rather had the same form,

111
00:06:27,030 --> 00:06:28,780
that normal Haskell functions had.

112
00:06:28,780 --> 00:06:33,570
Where it takes one argument and then returns a function that takes the other argument.

113
00:06:33,570 --> 00:06:38,710
So, there's a function called Curry which will take a function like T plus,

114
00:06:38,710 --> 00:06:43,765
and then return a new function that behaves in the normal way.

115
00:06:43,765 --> 00:06:47,390
Now, here's the type is written down here and I'll tell

116
00:06:47,390 --> 00:06:51,085
you there is only one function in the world that has that type.

117
00:06:51,085 --> 00:06:56,850
So, my challenge to you is see if you can write that and let us know in the comments.

118
00:06:56,850 --> 00:07:00,790
If you get stuck or want to verify your answer.