Hello everyone. Welcome back. In this video, I want to go over two very important higher-order functions. You'll see them a lot, you'll use them a lot, they'll be very useful to you, even outside of this course perhaps. So, they're called foldr and map, foldr for fold right. You'll want to know how to write them and how to use them to implement some very common recursion patterns. So, let's talk about mapping. You've seen this pattern before where I want to write a function that takes a list and does something that every element of a list. So, here I have function incL l or incL list, and it just returns the list with everything incremented. So, pretty straightforward. Now, look at these two functions. One of them increments every element to the list, the other one doubles every element of the list. What do they have in common? When in fact, it would be easier to say what they don't have in common. The only thing they have in common is the name, and that's an accident really, and the operation that they do. They both have the same base case, they both make the same recursive call. All that's different is, what it does to each individual element. So, we're actually rewriting an awful lot of code to do this. All that changes the operation and everything else is sort of boiler plate. So, this is what I call Mattox's law of computing. The computer really exists to work for us, and if you're working for the computer, you're doing something wrong. I remember one time my roommate, this is back in the day when there was floppy disks. He had two floppy disks, he was dragging one file at a time from one disk to the other, and there's was hundreds of files, he probably already spent about 10-15 minutes doing this. So, I showed him how to use Ctrl+A and drag all the files in one go. So, if you're doing something repetitive for the computer, you need to rethink what you're doing. Because it's the computer job to do repetitive stuff. That includes writing code. So, here's a way to do it right. Now, this function called Map, you've seen it a couple times before, here's its source code. So, map is a higher-order function it takes an operation f, and then if you give it an empty list, it returns the empty list. If you give it a list with stuff in it, it applies f to the first element of the list, and then maps f to the rest of that list. So now, we can just say map inc or map double to get the same functions that we had earlier. So, I like to talk the Java programming language, so try this in Java. Though actually, Java has some extension cease days, maybe that's easier. All right. So, let's talk about folding now. Take a look at these two, and see what they have in common. Well, slightly more, is different about them now than was true for the mapping stuff. So, what we have is we have a base case and an operation. In one case, the base case is zero for folding plus and for folding times, the base case should be one. So, here's the source code. So, you can see line two, we take the operation f, we take the base case z, think of z as being the zero element. So, if you get the empty list, you're going to return that zero element. Otherwise, you're going fold by calling f against x, and foldr of the rest of the list. So now, some list is just foldr plus 0, and prodlist is just foldr times 1. Now, if you don't like writing recursion very much, then map and foldr are your friends, because you can take pretty much any recursive function that works over lists and rewrite them as a call to a higher-order function. So, here we have this function sum which sums up every element of a list. Then, I can show you the equivalent version in foldr. So in foldr, the operation should take two arguments. The a element is going to be the first element of the list. The b argument is going to end up being the rest of the list already having been summed up. If you look at this source code you'll see that this was the result of a recursive call here. Then, you just need the base case for the last part of it. So, some things to think about, map and fold actually you may have heard of them. There's certain large computer clusters that have an operation called MapReduce. This is basically what you've got going here. One thing that you can do is you can use foldr to write map if you want to. You should actually try that. But the opposite way does not work. The reason why it doesn't work, set map, what it's doing is it's taking a list and it's doing something to each element of that list and it's treating them independently of each other. Whereas foldr, has to be able to combine elements, and map is unable to do that kind of combination. There are a lot of high-order functions that are built in the Haskell. Here's a few of them. I encourage you to play with a Haskell REPL and investigate these functions. You can use the :t operation remember, this finds out what the type of something is, and that will give you a very good hint about what these functions do. So, hope you enjoy them.