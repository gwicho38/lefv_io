Hello, everyone. Welcome to CS 421. This lecture, we're going to talk about Higher Order Functions. You've seen them a little bit already in a couple other examples. But want to get into a little of it in detail. So, some of the concepts we're going to cover in this lecture is about first-class citizens, in the context of programming languages, and we're going to talk about how to define functions that don't have names using sectioning and lambda. Then we're also going to talk about a function that can change the interface of another function. In programming languages things are said to be first-class, if they can be assigned to variables passed as parameters or return from functions as a result. Now most languages there's kind of a dichotomy between things that are first class and things that are not. So, for example, in C, you can have integers be first class. You can have structs be first class but functions are not. They have a special syntax to define them and they kind of have to live in their own top-level part of the world. Now, different languages make very different choices about which things are first-class, and that has a huge impact on the expressive ability of a program written in that language. In this lecture, we're going to talk about the choice at Haskell, Lisp, and Ocaml have made, that functions themselves are first-class things. I'll show you what that means. So, just to remind you the syntax of defining a function in a normal way as we have here. We have the square function. The square of A is A times A and hypotenuse squared is square of A plus square of B and then is just a sample run down here. We can look at the types, call the functions and they just work like you would normally expect. I'm going to show you something a little bit different. I have this function inc and another function double. Which do what you expect and then there's another function called Compose. Now look at what's happening here. Compose takes three arguments, F G and X and F and G are actually function types. If you look at the type of compose, there's the first part is T1 arrow T2 and that's the type of F. The G part is T arrow T1, and then finally you give it a T. The T is fed to the G which emits a T1. The T1 is fed to the F which emits the T2 and then that becomes the return value of this whole thing. What we can do now is we can take something like double and inc, you can compose them. So, if I compose inc doubled 10, first double is going to be applied to 10 to get 20 and then inc is going to be called to that to get 21. So, compose is said to be a higher-order function because it takes two other functions as its arguments and manipulates them. There's another higher-order function that you will see in a future lecture, it's called Twice, takes a function and let's just say a victim and applies a function two times to the victim. So, if I twice inc 5 I get seven and twice can take itself as its own argument. So, twice, twice inc 4 what do you think that will do? You should actually open up Haskell and try it out see what happens. Now, another thing that you can do with functions and Haskell, is you can write down a function in a literal syntax without giving it a name. Now, if you think about it it's not that weird of a thing to do. Integers you do that already, you can write down the number 42 and you don't have to assign it to a variable in order to use it. There's this literal representation that we use. So, for functions there's a literal representation as well near the parts. First, there's a backslash. Backslash is often pronounced lambda and it's supposed to remind you of the Greek letter Lambda. There's another lecture that we'll go over called lambda calculus which is a mathematical study of functions. This was directly inspired by that. Now, after the backslash, there's the list of parameters. The example here we only have one parameter X but Haskell allows you to put as many as you like there. Then there is an arrow which separates the parameter Lisp from the body of the function, and then finally there's the body of the function itself. This is what will get executed once a function is called. So, to use it you just put parentheses around the thing so that Haskell knows when the function ends and then call like you would any other function. So, here we have lambda X arrow X plus one applied to 41 gives you 42. Now, if you look at Haskell syntax for defining functions, now this inc A equal A plus one. Internally it's the same thing as inc equal lambda A arrow A plus one. Also, if you have plus AB, we can write that down as lambda A arrow lambda B arrow A plus B. Now if you call plus with just one then that feeds into the A parameter and then you get the function back lambda B one plus B. So, we can actually define incus equal to plus one if we want. Now one equivalence you should know about with these anonymous functions there's something called eta equivalence. Will go over this again in more detail later. But suppose you have some function F, this is lambda X arrow F applied to X, it's the same thing. Okay. Suppose you have a function F and then suppose a wrapper lambda around it. So, lambda F arrow F applied to X, turns out those are identical. Right, if I apply F to Z then if I apply Z to this lambda X then the Z will just be fed into the X and then that will in turn feed to the F. There's also something you've seen sectioning before where you can take an arithmetic operator and put parentheses around it and then treat that as a function. So, here we have plus AB and I have different versions of plus that I can use for that. Similarly, for inc we have these other ways of writing down the increment function. So, the last thing I want to show you in this video. Sometimes you have a function which takes a pair of integers or a pair of things and then produces a result and you'd rather had the same form, that normal Haskell functions had. Where it takes one argument and then returns a function that takes the other argument. So, there's a function called Curry which will take a function like T plus, and then return a new function that behaves in the normal way. Now, here's the type is written down here and I'll tell you there is only one function in the world that has that type. So, my challenge to you is see if you can write that and let us know in the comments. If you get stuck or want to verify your answer.