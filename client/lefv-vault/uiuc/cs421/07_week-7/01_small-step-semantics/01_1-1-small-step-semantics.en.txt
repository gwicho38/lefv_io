Hello everyone, welcome to CS 421. Earlier in the semester, you saw big step semantics which gives a precise way to define the meaning of expressions in a programming language. This time, we're going to talk about another way of modeling the meaning of language is called Small Steps Semantics. When you're done with this video, you'll be able to use the small step semantics that determined the value of an expression. You'll also be able to give an explanation about why semantics informal methods are useful to us. A semantics of a language is a formal system. So, let's start by taking a high-level view of formal systems. We say that a system is formal, we mean that we pay special attention to its forms, it doesn't mean that we dress in fancy clothes, but you can do that if you want. Anyway, a formal system needs four parts. First, you specify an alphabet or a set of symbols. This is analogous to specifying the terminal symbols in a grammar. Second, you define what a valid sentence in your system looks like. Third, you specify transformation rules which allow you to make new valid sentences from old ones. Finally, you specify a set of initial sentences we consider to be valid. The fun thing is we do not have to have an interpretation of the symbols in order to use the formal system. If we are using the formal system correctly, it will preserve whatever interpretation you have given it. As computers are good at manipulating systems they don't understand, you can see how formal methods might be useful to computer scientists. Here's a fun and silly example to illustrate this. I'm going to define something called a furbitz. We will have these symbols S, paren, Z, P, x and y. Z is going to be a furbitz and x and y are going to be of type furbitz as well. We can use S to take a furbitz and give us another furbitz. We can use P to take two furbitzi, furbitzi is a plural of furbitz by the way, and combine them into a new furbitz. We can also define a relation we call gloppit. We define that inductively. Then, giving two furbitzi that have the gloppit relation, we can show how different combinations of P, S and Z can be combined to preserve that gloppit relation. Now, if we stopped here, each of you could work through these definitions and everyone who decided something about two furbitzi, whether they had the gloppit relationship or not, would agree, assuming you all manipulated this symbols correctly. You could even feed these definitions to a theorem prover and automate this, but you still couldn't tell me what a furbitz is and you don't even need to know in order to get the correct answers. Now, let me show you this. This system is more recognizable, if I tell you that if furbitz as an integer. Z is zero, P is plus and S as successor. This illustrates another power that formal systems have. If you define a system and discover that it can be mapped to another system you already know, then all the theorems you've proven over on that other system can be applied to your new one. All that said, now let's talk about small steps semantics and start with a small toy language. It's pretty famous, a simple imperative programming language, sometimes it's called SIMP or maybe just IMP. We have five constructs. SKIP does nothing, it's like a NOOP of assembler, colon equals just assignment, semicolon separates two statements. Note that it is not a statement terminator like in C plus plus. We have if statements and while statements. It's language is simple, but complex enough to do real things with it. Small step semantics express how a computer could go about evaluating a bit of code. We're given a configuration which is an environment together with the program placed within these angle brackets. We use the arrow to document what one step of computation would look like, that is executing one step of a program or result in a new configuration. The program will be one step closer determination if it terminates, and the environment could have been modified by the program. Let's define the small steps semantics for SIMP now. If we have a configuration with Skip and Sigma in one step we will get the configuration E with Sigma unchanged. Here E represents the empty program. It's a very fancy way of saying that Skip doesn't do anything. For assignment of t to u with environment Sigma, we also get the empty program, but we say that Sigma gets modified. We update the mapping of u to be whatever evaluating t would be in the original Sigma. There's also a bit more detail of what Sigma looks like. We will write it down as a set of assignments where each one of the us are a variable and they should be distinct. We can apply Sigma to an expression as if it were a function and get back the value of that expression. Here, again, at the bottom, is what it looks like if we update Sigma. The next rule is sequencing. Remember that things on top are assumptions and the thing on the bottom is a conclusion. This rule says that if we can evaluate S1 as Sigma and get S2 and Tau, then we can put a semicolon S at the end of S1 and evaluate that and Sigma and get S2 semicolon S and Tau. We then declare that the empty program, semicolon S, is just S itself. Next there's if. We need two versions, one for if the condition is true and one for if the condition is false. That symbol that looks like a sideways Pi is pronounced models or proves. Sigma models B means that B is true given the contents of Sigma. The definition of while is pretty interesting. Most of the rules removed part of the program but in the case that B is found to be true, we rewrite the program to have the body S1 duplicated and put out in front of the while. If B is false then the while loop is done in the whole thing goes away. Here's an example of using the small step semantics execute a program. You start off with this program x assigned to one, n assigned to three and while n greater than one set x equal x times n and n equal to n minus one. We write down our initial configuration like this and we use the combination of the semicolon rule and the assignment rule to get to the next step. See if you can work out the next step before going onto the next slide. Now, we have an environment with x equal one and n assigned three is the next statement. Now, we have done both of the assignments and we're at the while loop. Try to work out what the next transition is before resuming. This time, the bounding greater one is true, so we copy the body of the while loop all upfront and now we get the execute it. We have x assigned to x times n and then n assign to n minus one, and now we're at the while loop again. Well, n is two, which is still greater than one, so we have to go again. x gets x times n and n gets n minus one and we're at the while loop a third time, this time the bound is false. This makes the program empty and gives us our final configuration. There will be some practice problems available for you to try this yourself. Our next topic will be an interesting property called the Church-Rosser property and we will use something that looks like small step semantics to discuss it.