Hello everyone, welcome to CS 421. One of the underlying algorithms and programming languages is called unification and it shows up in all kinds of places Haskell's type inferencer is an application of unification. There is also a language called Prolog which uses unification to drive its entire computation engine. Now, when you're done with this video, you'll be able to describe the problem that unification solves, you'll be able to take a unification problem and solve it, and you'll be able to implement unification in Haskell if you want. Let's talk about the domain. Their system is going to have terms, they're going to be names written in the Roman alphabet, and these terms can also have arity which is a fancy way of saying number of arguments. Now, terms that have arity of greater than zero will look like function calls, and terms that have arity zero will look like variables. So here, the first x and z have already zero. So, I should stress here, a terms never have value, they're not variables, they're patterns. Also, arguments to a term can themselves have non-zero arity so they might look like nested function calls. For variables in this system, we're going to use letters from the Greek alphabet to keep everything separate. Finally, we have a mapping from variable set terms that we usually call Sigma. It's like the other environment symbols that we've used before and we can treat Sigma as a function that substitute all the variables that occur in its argument. Here's the problem we're trying to solve. Given two terms s and t, is there a single substitution Sigma that makes these terms equivalent. If there is, we see the terms unify. If they don't, of course then we say the unification fails. Now, a unification problem is a set of equations, and what we want is to find a single substitution Sigma that unifies all of them. A unification algorithm will operate on these equations until hopefully every equation intersect will be the form x equal t where x is a variable and none of the variables occur in any of the t terms. We can do that, then s is in solved form. There are four operations that we're going to use to solve a set of unification equations, the first is delete. We have an equation t equal t, then that tells us nothing, so we can just drop it from our list. We have a rule called decompose. If we have two terms with the same name and an arity that are supposed to be equal, then we replace this equation with the set of equations made by pairing the corresponding arguments. Think like zip width. There's also orient which takes an equation with a variable on the right side and flips it. Finally, there's eliminate where an equation x equals t, where x is a variable, can be used to substitute all the other variables in this set. Now, it's going to be important that x does not itself occur in t. Here's an example that I stole from an excellent book called Term Rewriting and All That, and we start off with these two equations, Alpha equal f of x and g of Alpha, Alpha is equal to g of Alpha, beta. Now, the first question or the first equation is already in solved form. So, we can eliminate the other Alphas by replacing them with f of x. The next equation is these two g terms. So we're going to use decompose, the left sides first f of x is equal to the right side is f of x and the left side second f of x is equal to the right sides Beta. Now, the f of x equation doesn't give us any new information so we can drop it altogether. Finally, f of x equal beta can be reoriented as beta equal f of x. So, this yields a solved form, and we can rewrite it as a mapping of like Sigma. This yield to solve form which we can just rewrite as a mapping. Now, I find this process very similar to solving a set of simultaneous linear equations. So, if feels like that to you, then, yeah, it's kind of related. Let's talk about what could go wrong. A unification can fail in two ways. The first way it can fail is if the patterns mismatch. So, here, f of x mismatches g of Alpha since f and g are not the same, and h of y mismatches h of z since y is not the same as z. Mismatch also happens if two things are supposed to be equal that have different arities. Another kind of failure is when the occurs check fails. So, in this example, Alpha would have to be equal to f of Alpha which creates an infinitely large terms so we disallow it. So, here's one way you might implement unification. You'll write a function that takes two lists, one with solve variables in one free equations you're still working on. So you take the first element out of the equations list and pick which of the four operations is the correct one. So, decomposing delete will modify the equation list and orient and eliminate can be handled as one case and they will add a variable to the solved list and substitute that variable wherever it occurs. So, in both the solved list and in the incoming list. Other than that, it's a pretty simple algorithm. So, let's look at some examples of how we would use unification. The unifications used when we have a set of specifications and we want to find one object that satisfies them all. So here's some example, suppose your adviser wants you to take CS 421 and some theory class, and then suppose your mom wants you to take CS 394 or 374 in some language class, the unification question is, can you find a class schedule that makes both your advisor and your mom happy? So, if you represent your schedule as this pattern f where the first argument is a language class and the second argument is a theory class, then we can have both these terms. Unifying them is pretty simple. We discover that you must take both CS 421 and CS 375. A more programming language like example is type checking, we have the types we're map inc and foo and what to know if we can apply map to inc and foo. So, determining this as a unification problem and in fact this is how Haskell does, its type inferencing. So, we compare the types of the parameters to map with the types of the arguments to map and get this equation. I've written out the type list and the equations to make it match the unification form and then use double arrow for the function types. We can decompose the Alpha arrow beta and int arrow int and then we can eliminate the Alpha equal int. Finally, we can delete the list of int equals list of int and then have our solve set of types. We can even use this on the output type of map to get the output type of the function. Now, here's another example that fails. Suppose we had the type string arrow ends, see if it would still work. Now, if you do the same set of operations as before the last question or the last equation, will end up that list of string should be equal to list event which doesn't match. So that would be a type failure. So, here's the unification algorithm, we have some other materials that go into a little more detail. So, there it is, there's the unification algorithm, there are some other materials on the website that go into little more detail and some practice problems in a small implementation for you to look at.