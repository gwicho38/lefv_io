1
00:00:00,000 --> 00:00:02,674
Hello and welcome to CS421.

2
00:00:02,674 --> 00:00:06,835
You've seen semantic systems that describe
the behavior of programs in a given

3
00:00:06,835 --> 00:00:08,151
programming language.

4
00:00:08,151 --> 00:00:10,682
But semantics can do more that.

5
00:00:10,682 --> 00:00:14,662
Semantics can also be used to describe
properties of expressions in a language.

6
00:00:14,662 --> 00:00:16,963
Today we're going to talk
about typing semantics.

7
00:00:16,963 --> 00:00:18,491
This will be in two parts.

8
00:00:18,491 --> 00:00:22,503
This first part will talk about monotype
expressions, that is expressions that

9
00:00:22,503 --> 00:00:26,929
don't have type variables in them, and the
next part will be polymorphic expressions.

10
00:00:28,112 --> 00:00:31,963
And when you're done with this video,
you'll be able to explain what a type

11
00:00:31,963 --> 00:00:34,380
judgment is, and
what the parts of one are for.

12
00:00:34,380 --> 00:00:38,309
You'll be able to build proof trees to
indicate the types of an expression, and

13
00:00:38,309 --> 00:00:42,241
you'll be able to use the type rules to
indicate when you can change the contents

14
00:00:42,241 --> 00:00:43,434
of a type environment.

15
00:00:44,774 --> 00:00:48,032
If you haven't seen typing semantics
before, you might not have understood

16
00:00:48,032 --> 00:00:50,753
a single word I've said just now,
but don't worry about that.

17
00:00:50,753 --> 00:00:52,897
It'll all make sense at
the end of this video.

18
00:00:54,945 --> 00:00:58,308
And for our sample language,
we're going to use lambda calculus,

19
00:00:58,308 --> 00:01:01,932
extended to include a few useful
things like integers, and Latin if.

20
00:01:01,932 --> 00:01:06,987
We use a circle plus to represent energy
operations like plus and minus and we use

21
00:01:06,987 --> 00:01:12,280
tilde to represent comparison operations
like less than, greater than and so on.

22
00:01:12,280 --> 00:01:14,420
So let's talk about type judgements.

23
00:01:14,420 --> 00:01:16,794
Type judgements look like this.

24
00:01:16,794 --> 00:01:19,838
The first symbol is the capital
Greek letter gamma, and

25
00:01:19,838 --> 00:01:23,412
is a traditional letter to used
to represent a type environment.

26
00:01:23,412 --> 00:01:26,934
My type environment is just like a normal
environment but instead of mapping

27
00:01:26,934 --> 00:01:30,248
variable names to their values they
map variable names to their types.

28
00:01:30,248 --> 00:01:33,511
The second symbol that looks
like a sideways T is sometimes

29
00:01:33,511 --> 00:01:36,522
called turnstile or
sometimes pronounced entails.

30
00:01:36,522 --> 00:01:40,285
It's just a marker to separate
the environment from everything else.

31
00:01:40,285 --> 00:01:42,548
The E is the expression
I'm going to talk about.

32
00:01:42,548 --> 00:01:45,718
The colon separates
the expression from the next part.

33
00:01:45,718 --> 00:01:48,323
And the alpha is where we put the type.

34
00:01:48,323 --> 00:01:50,282
Now here are two examples.

35
00:01:50,282 --> 00:01:55,374
Just reading them out, the first one would
say that gamma entails that if true,

36
00:01:55,374 --> 00:01:57,363
then 4else38 has type int.

37
00:01:57,363 --> 00:02:01,080
And the second one would say
that gamma entails that true and

38
00:02:01,080 --> 00:02:02,499
false have type Bool.

39
00:02:05,559 --> 00:02:08,963
And now that you have a type judgement,
you can build type rules.

40
00:02:08,963 --> 00:02:12,648
We use the same system for rules that
we used with big step semantics.

41
00:02:12,648 --> 00:02:16,323
We put assumptions on the top and
the conclusion on the bottom, and

42
00:02:16,323 --> 00:02:18,755
on the right side we put
the name of the rule.

43
00:02:18,755 --> 00:02:22,252
This rule, the BINOP rule,
says that if e1 and e2 are integers,

44
00:02:22,252 --> 00:02:24,069
then e1 + e2 is also an integer.

45
00:02:24,069 --> 00:02:28,512
A plus could also be minus or
times or some other binary operation.

46
00:02:28,512 --> 00:02:30,879
You decided you want to write out gamma,

47
00:02:30,879 --> 00:02:35,207
you use set notation, the elements
having the form variable colon type.

48
00:02:35,207 --> 00:02:38,365
Sometimes we leave out gamma if
it doesn't matter for our rule.

49
00:02:40,332 --> 00:02:43,414
If a rule doesn't have any assumptions,
it's called an axiom.

50
00:02:43,414 --> 00:02:45,712
So here some axioms for our system.

51
00:02:45,712 --> 00:02:48,389
The const rule says that
n is an integer and

52
00:02:48,389 --> 00:02:52,070
we have a side condition that
n must in fact be an integer.

53
00:02:52,070 --> 00:02:56,853
We also have the type variable rule
that says x has type alpha if that fact

54
00:02:56,853 --> 00:02:58,375
is included in gamma.

55
00:02:58,375 --> 00:03:01,061
Now some people will put the x: alpha and

56
00:03:01,061 --> 00:03:06,680
gamma as an assumption rather than a side
condition, kind of depends on the author.

57
00:03:06,680 --> 00:03:11,794
I like to leave it as a side condition
since it's not a type judgement.

58
00:03:11,794 --> 00:03:13,583
Now here are a few simple rules.

59
00:03:13,583 --> 00:03:17,486
Binary operations take ints and
combine them into a new int.

60
00:03:17,486 --> 00:03:20,294
Relational operators take ints and
create Booleans.

61
00:03:20,294 --> 00:03:23,773
Boolean operations take Booleans and
return more Booleans.

62
00:03:23,773 --> 00:03:26,025
Now I've chosen to make
these different rules for

63
00:03:26,025 --> 00:03:27,691
the different kinds of operations.

64
00:03:27,691 --> 00:03:31,833
But another way to have done it would've
been to make a list of operations and

65
00:03:31,833 --> 00:03:35,735
have their type signatures and
then have one rule that expresses that.

66
00:03:35,735 --> 00:03:40,264
Now I've chosen to make different rules
for the different kinds of operations, but

67
00:03:40,264 --> 00:03:44,474
it's also possible to have a list of
operations with their type signatures and

68
00:03:44,474 --> 00:03:47,638
then have one rule do something
like a lookup in that list.

69
00:03:47,638 --> 00:03:52,041
Now just like in big step semantics
you can combine these rules

70
00:03:52,041 --> 00:03:54,250
together to make proof trees.

71
00:03:54,250 --> 00:03:57,985
The way I do it is to write down what I'm
trying to prove and put a bar over it.

72
00:03:57,985 --> 00:03:59,460
A proof tree is going to get big so

73
00:03:59,460 --> 00:04:02,247
it's best to put this towards
the bottom of your paper.

74
00:04:02,247 --> 00:04:05,706
The most important thing to
decide is what rule applies.

75
00:04:05,706 --> 00:04:10,070
So which one do you
think that we need here?

76
00:04:10,070 --> 00:04:13,272
Since we have a Boolean operation
we use the BoolOp rule.

77
00:04:13,272 --> 00:04:15,198
Here it is below.

78
00:04:15,198 --> 00:04:21,673
Now we can take the sub expressions and
use them to build type judgements on top.

79
00:04:21,673 --> 00:04:26,978
Next we're going to continue
with x times 5 greater than 7.

80
00:04:26,978 --> 00:04:29,166
Now that expression is
a relation operation.

81
00:04:29,166 --> 00:04:31,921
So we split it into x times 5 and 7.

82
00:04:31,921 --> 00:04:34,028
Next we're going to look at the x times 5.

83
00:04:36,328 --> 00:04:40,319
The x part uses the variable rule,
and the 5 part uses the constant rule.

84
00:04:40,319 --> 00:04:42,833
I've added the rules labels
to the rest of the tree.

85
00:04:42,833 --> 00:04:44,615
And now this proof tree is done.

86
00:04:47,299 --> 00:04:48,344
Now so far so good.

87
00:04:48,344 --> 00:04:51,806
But sometimes we have rules where we
don't know what the type will be upfront.

88
00:04:51,806 --> 00:04:53,768
Consider this rule, the If rule.

89
00:04:53,768 --> 00:04:58,698
It says that e1 has to have type Bool and
e2 and e3 must have some type alpha.

90
00:04:58,698 --> 00:05:01,579
In other words we don't
care what the types e2 and

91
00:05:01,579 --> 00:05:03,644
e3 are as long as they are the same.

92
00:05:03,644 --> 00:05:07,336
The alpha here is a meta-variable
just like e1, e2, and e3.

93
00:05:07,336 --> 00:05:11,005
All them of them must be replaced by
valid expressions or types in order for

94
00:05:11,005 --> 00:05:12,557
the proof tree to be complete.

95
00:05:12,557 --> 00:05:17,742
We'll extend this system in the next
video to handle polymorphic things.

96
00:05:17,742 --> 00:05:20,563
Here's the rule for function application.

97
00:05:20,563 --> 00:05:24,997
If e1 has type alpha2 to alpha,
and e2 has type alpha2,

98
00:05:24,997 --> 00:05:27,847
and e1 applied to e2 has type alpha.

99
00:05:27,847 --> 00:05:31,687
If a function has an input type and
an output type, passing something in

100
00:05:31,687 --> 00:05:35,282
the input type, you should get
back something of the output type.

101
00:05:35,282 --> 00:05:39,986
If you're familiar with logic, this may
remind you of the rule of modus ponens.

102
00:05:39,986 --> 00:05:43,526
And, in fact, there is a correspondence
between types of programs and

103
00:05:43,526 --> 00:05:44,415
logical proofs.

104
00:05:44,415 --> 00:05:47,657
And it's called
the Curry-Howard isomorphism.

105
00:05:47,657 --> 00:05:51,977
Means that computer programs can be seen
as proof objects in a logical system.

106
00:05:51,977 --> 00:05:55,217
It shows that there's some deep
connections between programming languages

107
00:05:55,217 --> 00:05:56,026
and mathematics.

108
00:05:58,828 --> 00:06:03,576
Here's the rule for functions, this one's
special because it's the first rule we've

109
00:06:03,576 --> 00:06:06,693
shown you that allows you to
change the contents of gamma.

110
00:06:06,693 --> 00:06:10,737
It's important to understand this
one well, so let's work an example.

111
00:06:10,737 --> 00:06:15,964
We'll look at the type of lambda
x.x + 1 has type Int arrow Int.

112
00:06:18,397 --> 00:06:21,514
This is clearly going to be
the abstraction rule so we draw a line and

113
00:06:21,514 --> 00:06:23,259
label the rule we're going to use.

114
00:06:24,906 --> 00:06:30,835
Now we put x into gamma and try to
type check the body of the function.

115
00:06:30,835 --> 00:06:34,580
The body is a binary operation and
the x and one just need the variable and

116
00:06:34,580 --> 00:06:37,150
const rule and
now we have a complete proof tree.

117
00:06:39,435 --> 00:06:42,140
So let's introduce the last two rules for
this video.

118
00:06:42,140 --> 00:06:44,179
Here are two versions of let.

119
00:06:44,179 --> 00:06:47,305
The top one is for
let expressions that are not recursive.

120
00:06:47,305 --> 00:06:50,793
Languages like OCaml and
LISP use this kind by default, and

121
00:06:50,793 --> 00:06:53,318
have recursive versions if you need them.

122
00:06:53,318 --> 00:06:57,266
You'll notice that the e1 term is
typed checked in the original gamma.

123
00:06:57,266 --> 00:07:01,579
In the recursive version,
we use the updated gamma to type check e1.

124
00:07:01,579 --> 00:07:06,251
That's because the variable we're
defining can occur as a subterm in e1.

125
00:07:06,251 --> 00:07:08,038
So that's it for monotypes.

126
00:07:08,038 --> 00:07:12,182
Be sure to take a look at the handout for
a few more example proof trees.