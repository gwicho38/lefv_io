Hello everyone. Welcome to CS 421. So, far you've seen LO parsers which used recursive descent and LR parsers which use push-down automata. This time we're going to use monads to build parsers which are completely composable and their resulting Haskell code looks very much like the grammar we're trying to write a parser for in the first place. When you're done with this video, you'll be able to use monadic parser combinators to build parses for context-free grammars. You'll be able to build your own parser combinator library from scratch. Now, the problem we're trying to solve is this. Recursive descent parsers are easy to write, but the grammar has to be LR. Also, we have to deal with the plumbing issue, parsing input stream in, and returning it back every time. So, today we're going to fix that. To start off, let's define a type that represents our parser. This is going to look like the state type we defined for the state monad. We want to say that we have a parser of type T, if we have a function that inputs a list of strings and returns a list of pairs of a T and the remaining strings. The output being a list of pairs may be unexpected, but it gives us some nice flexibility. It allows us to use an empty list indicate that a parse failed and we could potentially return multiple parses if the grammar were ambiguous, though in practice, we're not actually going to do that. We can find the run function to extract the function part of the parser type. Notice, we're not using records in fields like we did with the state monad. Now, that we have our type, let's try writing a parser with it, something simple just to get started. We will write a parser generator, char s that takes a character s as an input, and returns a parser that succeeds if the next input is the same character as s, and fails otherwise. For success, we just return a list with the first character and the remaining characters is in a pair, for failure we just return the empty list. Now, remember that the default representation of strings and Haskell is a list of characters. We can make the parser more general by allowing a match of multiple characters. Here's a common parser generator called oneOf, that takes a list of characters and returns a parser that succeeds if the next input character is one of them. We can use this to define parsers like digit, though in reality we would use something more efficient since the whole list of digits would need to be traversed. Notice, our writing parsers that do some kind of test on the first character and succeed if the test succeeds and fails otherwise. We can abstract this by making a parser generator "sat" which is short for satisfy, that takes a predicate as a function. We can call this function "pred" on the first input rather than hard coding the action. Compare oneOf and sat to see the differences. For digit, sat lets us write more efficient version of the original oneOf. This next parser is very interesting, and it shows why we use a list of pairs as a parser's output. We'll create an operator with this pipe symbol in angle brackets. It takes two parsers and runs some both on the input. Since the output will both be lists, we append them together and then take the first element. If P1 succeeds, we'll return P1's result. Since Haskell is lazy, P2 will never even be run. If p1 runs and we will get P2's result. If p1 fails, we will get P2's result. If it succeeded, if both fail we just get an empty list. Here are a few examples using a parser that succeeds at the first letter of the input as a digit or the letter a. Now, parsers can be recursive as well. Here's a recursive string matching parser. You give it a string and it calls itself recursively character by character on the input. You'll notice that we have to spend some effort to keep track of all the inputs. You'll notice that we have to expend some effort to keep track of the inputs and outputs and recombine everything together properly after the recursive call returns. If the recursion succeeds we want to propagate the success, and if the recursion fails we want to propagate to failure. This is another example of plumbing, and it makes our programs messy and error-prone. But we've already seen a structure that handles the propagation and failure, and the unpacking of an incoming data structure. Of course, it's not going to be surprised now, because already mentioned that we're going to use monads. So, let's make a monad for our parser type. First thing we have to do is define the Functor type for parsers. This gives us fmap that takes a function f and applies it to the result for our parser. You can see what will happen here. The incoming parser contains a parsing function P1, we feed input to p1 to get out a list of pairs. The first element of each pair is the result of the parse, and that's the part we want to apply f to. The second part of the pair is the remaining input, and that's what we want to return as is. As an example, we can create a parser SDI for single digit integer, and returns an actual integer instead of a character. We can fmap plus one over that parser, and once it's run integer returned has been incremented. Even this by itself gives us a lot more power over our parsers. The next level up is applicatives, which allow multi-parameter functions to be applied. Given two parser functions p1 and p2, we run P1 to extract a function result V1, and then we run P2 over the rest of the input to get a perimeter of V2. Finally, we apply V1 to V2 to get our final result. In our example, we have plus applied to two SDI parsers. It then reads the first two digits four and five, and adds them together for the final parse. Next step is the monad. But I'm going to give you the usual advice now, pause the video and try typing all this in, so you can be sure you understand it, and resume when you're ready to see the monad definition. Here's a monad definition. We have some parser p that we want to bind to a function f. So, we take P and apply it to the input to get the result V, and the rest of the input I and P prime. Now, we apply V to F which should return a new parser, and run that against IMP prime. This will return a list of lists, so we can cat them together to get a single list. Now, we can write the plus parser monadically, we call SDI twice binding ones to X and ones to y, and then returning the result x plus y. Here's that example twice, when using regular bind notation and when using the special do notation. Here, was our stream parser with all the plumbing, either you can write it monadically. Pause and hit resume when you're ready to see the solution. Here's a monadic version, line two reads a character and line three does the recursion, line four combines the result. The best part is, the monad takes care of all the plumbing for us, never have to see it. Using a recursive pattern, we can write parser generates take a predicate and keep consuming input while the predicate's true many is zero or more, many one needs at least one match. A very common parser combinators spaces, that consumes spaces or whitespace. Here's a simplified version using many in oneOf. In real life, you would also add tab a new line. We can also be very flexible about the output type, as you saw with the single digit integer parser. This parser can return an integer expression. The int parser just collects digits with many one digit and packages it into an index. To parse operators, we often have this chaining operator. Oper just takes an operator and consumes the spaces that come after it. Chainl1 and takes a parser p and the operator parser0. Line four runs p via the bind operation, and then line five checks to see if an operator is next. If so, it reads another p it repeats the process. If not, line eight returns the result from P by itself, this will recreate a left associative operation. We can now write an expression parser for plus and integers very simply. If you remember when we showed you how to create unambiguous grammars by stratification, this will look familiar. We can create expressions that are disjunctions, conjunctions, comparisons, additions, multiplications or atomic things. The stratification make sure these operators have the correct precedence. Here's our final example a let expression. Parser combinator libraries all have try combinator, that will allow for backtracking if a parse fails. You'll get to see more of this in your assignments, so we want to explain it carefully here. There are many parser combinator libraries for Haskell. Parsec is the most famous one mainly because it was the first, attoparsec is more industrial version of it, and currently megaparsec is the best-performing parser library. If you're starting from zero, I'd recommend learning megaparsec.