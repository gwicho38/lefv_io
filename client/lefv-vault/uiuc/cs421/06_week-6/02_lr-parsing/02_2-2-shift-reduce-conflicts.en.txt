Hello everyone, welcome back. In the last video, I left you with this grammar to build a state machine firm, and if you haven't done that yet, please do that before watching this video, because it'll help you understand the material here. Now, if you did it correctly, you notice that one of the states in the action table seem to need two actions. If you did not get that result, continue watching anyway as a way to check your work. I'll let you know when to pause if you want to try it again and get interactive feedback. Now, when a single state seems to require both the shift and reduce action, it's called the shift reduce conflict. These are caused by ambiguities in the grammar. When you're done with this video, you'll be able to explain how a shift reduce conflict signals ambiguity, and give some suggestions for how you could fix such an ambiguity. You also know what a standard LR parser generator such as yak would do to handle a shift reduce conflict in Y. Now, here's the grammar we gave you. Before we start building the state machine, notice you can already tell just by visual inspection that this grammar is ambiguous. Do you see how? The answer is in the E goes to ExE production. This is one of the forms we showed you in the introduction to grammars video, which we call W in the recursion. So, if you had a sentence b x b x b, you would know which way the parentheses should go. So, let's build a state machine now and see how this causes a conflict in the table. So, here are our action and go to tables, we'll create an initial state as zero and take its closure. Now, both of these items will shift on a. So, let's use that to create the next state, pause now and resume when you're ready. The a input causes a shift to state one, and we're building state one, the cursor moves in front of an E, so we need to add in the initial E productions as well. Our next step will be to process these items that cursor before the E. Pause now and resume when you're ready to see the next state. State i2 looks like this and results from a go-to action on E from state i1. We'll now work on the shift b actions. Pause now and resume when you're ready. State i3 results from a shift b on state one. Notice we have to add in the s productions again because the cursor is in front of an s in the first line. Now we'll look at the shift b in state two, pause now and resume when you're ready. Shifting b gives a state i4. Now, we'll shift the x in state i2, pause now and resume when you're ready. Shifting x gives you state i5. We have to close over the E productions. Now, we're going to make a go-to action over the s in state i3. Pause now and resume when you're ready to see the answers. The go-to over s produces state i6. Now, we'll do a reduce on this E goes to b rule. Follow set of E is x and b, and since that was a fourth rule we put in r4 in the x and b columns of the table. Now, we're going to shift the a's in the last two items of state i3, pause now and resume when ready to see the result. Now, it turns out that shifting a makes the same configuration of state i1, so we just reuse it. Now, we're going to turn our attention to state i5 and i6. I6 is just to reduce recorded in the table and not say any more about it, but i5 starts to get interesting. When we make are go-to on E and i5, we get state i7. Now, this state has problems. Here's a hint, what is the follow set of E? Right, the follow set of E is x and b. So, we want to reduce rule three if we see an x or a b. But look at the second production in the state. It says that if we see an x, we should make a state that looks like i5. How should we fill out the table now? As tables getting long, so I chopped out some of the beginning rows, row seven is where the interesting bit happens. We have r3 in columns b and x, but we also want to shift in column x that would bring us back to state five. This is the dreaded shift reduce conflict. Now, shift reduce conflict happens when one row uses a symbol to consume input, that is to shift, while another row uses a symbol to indicate that a sub tree is finished, that is to reduce. It indicates that the grammar is ambiguous. Usually you can fix this by introducing precedence levels or associativity information. LR parser generator will have annotations to do this, or you can do it manually by stratifying the grammar. Now, if you decide to be lazy and not fix the conflict, and the parser is going to have to pick which one of the two actions to do. The standard reaction is to pick shift, because it is more likely to give you a successful parse. Now, to see why this should be the case, consider the dangling else problem. Suppose we have an if statement nested inside the then branch of another if statement, we parse up to the first time we see an else. Now you have to decide, does that else belong to the if x or to the if y? You could pick either one and get a valid parse in this case, though clearly we can't tell which one the programmer meant. But what if there's another else coming? If we say the else q belongs to the if x by picking reduce, then we have no where to put the else w. But if we shift the else q, we indicate that it belongs to the inner if y, and then the else w can belong to the if x, and that's the basics of the shift reduce conflict. Indicate that your grammar is ambiguous somehow but the good news is it's usually not hard to fix it. So, this was the second parser technology we wanted to show you, both LR and LR parsers have been around for a long time. An ex parser is much newer technology, and I think you're going to like it.