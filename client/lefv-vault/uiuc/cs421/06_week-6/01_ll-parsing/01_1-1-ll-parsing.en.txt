Hello, welcome to CS421. Today we're going to talk about a parser that's very easy to implement using regular old functions. The grammars LL you'll build a write a parser for very quickly, but the downside is that it doesn't work with every grammar. When you're done with this video, you build a tell if a given grammar is LL or not, you'll be able to use functions to implement an LL parser and you'll be able to explain how left-recursion and common prefixes cause LL parsers not to work. So, what is LL parsing? LL parsing is core part. Is it built a tree from a given input stream. The way it works is we use a start symbol as the root of the tree and then fill in the parts of the leaves are the parts of the tree is more than input is read. So in this example, we'll start by building an S-Tree. Looking at the S production you see that there should be a plus is the first part of its input and indeed the example input has a plus. So, next we want to parse the middle branch of S the E-Tree. Now, in the case of E there are two possibilities and integer or a star. In the input we see an integer, so we know we're using the E goes to int production. The next E Subtree is a star E1, so we fill in the second E-Tree with the star EE. Notice how we're filling in the parse tree from the left-side. Finally, we parsed the three and the four. Now, we have a complete tree. So, I hope you notice that we always knew which production was relevant at the time by knowing where we were in building the parse tree and by looking at the next token of the input. The number of tokens at the parse looks ahead to decide what to do next is the end. In the LL parser. The most common value of n and a parser is one meaning that we only look at the next symbol of the input to decide what to do next. So, how to implement it? Implementing an LL parser is very easy. To think of a production as a specification for a function definition, the left-hand side tells you which function is being defined. In the right-hand side, tells you how to consume the input. Terminal symbol becomes instructions to consume a token of input and a nonterminal symbol becomes a call to another parsing function. There's one important detail though the type. The input is going to be a list or a stream of tokens. So, the output's going to be a tree together with the remaining tokens. Since we're using a functional language, cannot destructively updates the input stream we have to keep track of it manually as it were. This technique of keeping track of a value by both inputting and outputting to simulate state is something called plumbing or threading, not to be confused with the usual meaning of threading where parallel or asynchronous execution is allowed. Now, here's an example, we'll take that e-production and create a function from it. The empty list is an error, so we leave that undefined here, but you may want to return an error message instead. If the first token is a star and we have the E goes to star in E e-production. To the excess is the rest of the input after the start and we use that to call getE recursively capturing the tree in e1 and the rest of the tokens in r1, we call getE recursively again with r1 to get a second e3 e2 and the remaining tokens are one. Finally, return the pair Etimes, e1 e2 with r2. On line six you could fill in code to convert a string into an integer and return and E and if you want to complete this code, the whole point of this parsing is that you can look at the next input token and know what you need to do next. So as you see, implementing a parse of this wave Is pretty straightforward. What could possibly go wrong? Well, actually there are two things. The first thing that could go wrong is called Left Recursion. Remember that a nonterminal is implemented with a function call. So, if a nonterminal appears as the first symbol on the right-hand side and that means the corresponding function is called before any input is consumed and if that call happens to be a recursive one, then we would have an infinite loop. Here's an example of the rule E goes to E plus E which is a common rule to write down in a language. If we call getE on xx and getE will have to loop. Another problem is called the common prefix problem. More exactly, in the productions of a nonterminal symbol have overlapping first sets and this parsers unable to distinguish which production should be next. Now, here's an example, E goes to minus E, and E goes to minus EE. Perhaps this is meant to represent unary negation and prefix operator subtraction. In any case, we cannot tell from seeing the minus which version of the rule is the right one. We cannot just read ahead either, since the following E could be arbitrarily complicated. The good news is that both of these problems can be fixed and we'll look at that in the next video.