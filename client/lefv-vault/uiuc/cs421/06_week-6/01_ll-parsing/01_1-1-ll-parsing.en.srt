1
00:00:00,000 --> 00:00:03,135
Hello, welcome to CS421.

2
00:00:03,135 --> 00:00:05,610
Today we're going to talk about a parser that's very

3
00:00:05,610 --> 00:00:08,460
easy to implement using regular old functions.

4
00:00:08,460 --> 00:00:12,180
The grammars LL you'll build a write a parser for very quickly,

5
00:00:12,180 --> 00:00:15,195
but the downside is that it doesn't work with every grammar.

6
00:00:15,195 --> 00:00:16,880
When you're done with this video,

7
00:00:16,880 --> 00:00:19,610
you build a tell if a given grammar is LL or not,

8
00:00:19,610 --> 00:00:23,900
you'll be able to use functions to implement an LL parser and you'll be able to

9
00:00:23,900 --> 00:00:29,030
explain how left-recursion and common prefixes cause LL parsers not to work.

10
00:00:29,030 --> 00:00:32,420
So, what is LL parsing?

11
00:00:32,420 --> 00:00:34,820
LL parsing is core part.

12
00:00:34,820 --> 00:00:37,565
Is it built a tree from a given input stream.

13
00:00:37,565 --> 00:00:41,900
The way it works is we use a start symbol as the root of the tree and then fill

14
00:00:41,900 --> 00:00:46,640
in the parts of the leaves are the parts of the tree is more than input is read.

15
00:00:46,640 --> 00:00:50,060
So in this example, we'll start by building an S-Tree.

16
00:00:50,060 --> 00:00:53,690
Looking at the S production you see that there should be a plus is

17
00:00:53,690 --> 00:00:57,995
the first part of its input and indeed the example input has a plus.

18
00:00:57,995 --> 00:01:02,230
So, next we want to parse the middle branch of S the E-Tree.

19
00:01:02,230 --> 00:01:06,865
Now, in the case of E there are two possibilities and integer or a star.

20
00:01:06,865 --> 00:01:08,500
In the input we see an integer,

21
00:01:08,500 --> 00:01:12,940
so we know we're using the E goes to int production.

22
00:01:12,940 --> 00:01:15,815
The next E Subtree is a star E1,

23
00:01:15,815 --> 00:01:19,020
so we fill in the second E-Tree with the star EE.

24
00:01:19,020 --> 00:01:23,090
Notice how we're filling in the parse tree from the left-side.

25
00:01:23,090 --> 00:01:26,255
Finally, we parsed the three and the four.

26
00:01:26,255 --> 00:01:28,795
Now, we have a complete tree.

27
00:01:28,795 --> 00:01:31,400
So, I hope you notice that we always knew

28
00:01:31,400 --> 00:01:34,130
which production was relevant at the time by knowing

29
00:01:34,130 --> 00:01:38,845
where we were in building the parse tree and by looking at the next token of the input.

30
00:01:38,845 --> 00:01:43,115
The number of tokens at the parse looks ahead to decide what to do next is the end.

31
00:01:43,115 --> 00:01:44,975
In the LL parser.

32
00:01:44,975 --> 00:01:48,770
The most common value of n and a parser is one meaning that we

33
00:01:48,770 --> 00:01:53,170
only look at the next symbol of the input to decide what to do next.

34
00:01:53,170 --> 00:01:55,845
So, how to implement it?

35
00:01:55,845 --> 00:01:59,190
Implementing an LL parser is very easy.

36
00:01:59,190 --> 00:02:03,560
To think of a production as a specification for a function definition,

37
00:02:03,560 --> 00:02:06,575
the left-hand side tells you which function is being defined.

38
00:02:06,575 --> 00:02:07,795
In the right-hand side,

39
00:02:07,795 --> 00:02:09,840
tells you how to consume the input.

40
00:02:09,840 --> 00:02:14,000
Terminal symbol becomes instructions to consume a token of

41
00:02:14,000 --> 00:02:18,995
input and a nonterminal symbol becomes a call to another parsing function.

42
00:02:18,995 --> 00:02:21,770
There's one important detail though the type.

43
00:02:21,770 --> 00:02:25,460
The input is going to be a list or a stream of tokens.

44
00:02:25,460 --> 00:02:30,065
So, the output's going to be a tree together with the remaining tokens.

45
00:02:30,065 --> 00:02:32,000
Since we're using a functional language,

46
00:02:32,000 --> 00:02:34,475
cannot destructively updates the input stream

47
00:02:34,475 --> 00:02:37,175
we have to keep track of it manually as it were.

48
00:02:37,175 --> 00:02:40,790
This technique of keeping track of a value by both inputting and

49
00:02:40,790 --> 00:02:44,540
outputting to simulate state is something called plumbing or threading,

50
00:02:44,540 --> 00:02:47,105
not to be confused with the usual meaning of threading where

51
00:02:47,105 --> 00:02:50,600
parallel or asynchronous execution is allowed.

52
00:02:50,600 --> 00:02:52,760
Now, here's an example,

53
00:02:52,760 --> 00:02:55,810
we'll take that e-production and create a function from it.

54
00:02:55,810 --> 00:02:57,200
The empty list is an error,

55
00:02:57,200 --> 00:02:58,700
so we leave that undefined here,

56
00:02:58,700 --> 00:03:01,715
but you may want to return an error message instead.

57
00:03:01,715 --> 00:03:07,930
If the first token is a star and we have the E goes to star in E e-production.

58
00:03:07,930 --> 00:03:12,200
To the excess is the rest of the input after the start and we use that to call

59
00:03:12,200 --> 00:03:17,960
getE recursively capturing the tree in e1 and the rest of the tokens in r1,

60
00:03:17,960 --> 00:03:20,540
we call getE recursively again with r1 to get

61
00:03:20,540 --> 00:03:24,525
a second e3 e2 and the remaining tokens are one.

62
00:03:24,525 --> 00:03:27,360
Finally, return the pair Etimes,

63
00:03:27,360 --> 00:03:29,980
e1 e2 with r2.

64
00:03:29,980 --> 00:03:33,350
On line six you could fill in code to convert a string into

65
00:03:33,350 --> 00:03:36,830
an integer and return and E and if you want to complete this code,

66
00:03:36,830 --> 00:03:39,950
the whole point of this parsing is that you can look at

67
00:03:39,950 --> 00:03:43,745
the next input token and know what you need to do next.

68
00:03:43,745 --> 00:03:48,020
So as you see, implementing a parse of this wave Is pretty straightforward.

69
00:03:48,020 --> 00:03:50,030
What could possibly go wrong?

70
00:03:50,030 --> 00:03:53,015
Well, actually there are two things.

71
00:03:53,015 --> 00:03:57,220
The first thing that could go wrong is called Left Recursion.

72
00:03:57,220 --> 00:04:00,530
Remember that a nonterminal is implemented with a function call.

73
00:04:00,530 --> 00:04:05,240
So, if a nonterminal appears as the first symbol on the right-hand side and that means

74
00:04:05,240 --> 00:04:07,940
the corresponding function is called before any input is

75
00:04:07,940 --> 00:04:11,210
consumed and if that call happens to be a recursive one,

76
00:04:11,210 --> 00:04:13,175
then we would have an infinite loop.

77
00:04:13,175 --> 00:04:15,980
Here's an example of the rule E goes to E plus E

78
00:04:15,980 --> 00:04:18,965
which is a common rule to write down in a language.

79
00:04:18,965 --> 00:04:22,940
If we call getE on xx and getE will have to loop.

80
00:04:22,940 --> 00:04:26,510
Another problem is called the common prefix problem.

81
00:04:26,510 --> 00:04:30,770
More exactly, in the productions of a nonterminal symbol have overlapping

82
00:04:30,770 --> 00:04:36,065
first sets and this parsers unable to distinguish which production should be next.

83
00:04:36,065 --> 00:04:37,930
Now, here's an example,

84
00:04:37,930 --> 00:04:39,360
E goes to minus E,

85
00:04:39,360 --> 00:04:41,245
and E goes to minus EE.

86
00:04:41,245 --> 00:04:46,565
Perhaps this is meant to represent unary negation and prefix operator subtraction.

87
00:04:46,565 --> 00:04:48,920
In any case, we cannot tell from seeing

88
00:04:48,920 --> 00:04:52,025
the minus which version of the rule is the right one.

89
00:04:52,025 --> 00:04:53,600
We cannot just read ahead either,

90
00:04:53,600 --> 00:04:56,720
since the following E could be arbitrarily complicated.

91
00:04:56,720 --> 00:04:59,300
The good news is that both of these problems can be

92
00:04:59,300 --> 00:05:03,180
fixed and we'll look at that in the next video.