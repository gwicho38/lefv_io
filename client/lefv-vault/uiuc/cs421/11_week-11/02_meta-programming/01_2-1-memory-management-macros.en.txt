Hello everyone, welcome to CS 421. One extremely powerful concept you're going to want to know about is the idea that programs can actually write other programs. This is sometimes called Metaprogramming, and there are languages have built-in support for this in the form of macros. When we're done with this lesson, you'll have seen three different ways to write programs that write other programs. I will introduce the defmacro form from list and we'll see how to use it to extend the language. I will also talk about some issues that come up with variables in macros. Now, in order to talk about this, we're going to use the programming language Emacs lisp or ELIST. It's very similar to the scheme machine problem you worked on, but I'll quickly explain new syntax as it comes up. So, ELIST part is a prompt. So, defun creates a new function, in this case, a function name is str-make-ink and it takes two parameters name and delta. The body of the function concatenates a bunch of strings together. We call this function with the parameters five and five, you see that I will put a string that can be pasted into the Emacs repo. The technique is pretty simple to get started with, but it can be tricky because you have literally no language support for the stranger writing. Debugging code that writes code can be difficult since the place you see the error is going to be different than the place where the code was generated. Now, one hobby people sometimes have is to write a program called the quine. Quine is a program that generates its own source code when it's run without cheating by reading the source code from disk of course. So, you can try writing a quine in your favorite language if you have some time. Now, if you're using a home or iconic language like Lisp or Prologue, language will usually provide features that allow you to manipulate source code directly. Most lisp support quasi quotation. So, the back tick creates a list, but the comma allows you to splice in a value. So, in this example, the defun and the x in parentheses will not be evaluated, they are taken as symbols. But the common name and comma delta status splice in the actual values of those parameters. So, when I run ast-make-inc, passing in the symbol five and the number five, it returns a list containing the code to define a function. I can then pass it to the eval function, which causes the definition to be compiled. Now, the technique of having a function write some code and then calling eval on it was so common. It created a special forum to combine both steps into one, the defmacro form. It's very much like the code from the previous slide, but notice how, when I call them make-inc, the 10 function is automatically created for us. Macros are somewhat controversial in programming language community, some people swear by them and say that it gives you an expressive power unmatched by any other programming technique. Other people swear at them for the exact same reason. It's very difficult to reason about what macro is actually doing. So, imagine trying to come up with a typing semantics for this single, see what I mean. I've actually been encouraged by some other programming-aged people not to teach macros to this class. But hey, let's do it anyway. So, what are some reasons we might want Macros? One reason is we might want to extend the language with things that act like functions but do not evaluate all their arguments. So, for example, suppose you want to write your own if like function in a language. Definition is very simple and if you wrote unit tests four, they may even pass. But, if you try to use it to break a recursion, you'll find that you get an infinite loop, and discuss the call by value language, all arguments will be evaluated whether we want them to be or not. A macro can get around that however. Another use case for macros is eliminating boilerplate code. So, common example of that is here. Now, suppose you are working with a database or opening a file or accessing some kind of resource, you first need to acquire the resource and check to see that you actually got it, then perform whatever operation you wanted using the handle. Once you're done with that, either normally or because you caught an exception, you need to close that handle. So, the code to do that is very similar, and it would be hard to do this with higher-order functions and eager language. But if you have macros, it becomes very simple to fold all that code into a single call like with open. Another major use case of macros is creating what's called an embedded domain-specific language. You now know very well that writing an interpreter's work. You already have a working programming language, it may be easier just to extend the language with macros and to reinvent language from scratch. Here's a example from the Clojure programming language. It's the package called hiccup. It allows you to specify HTML in the form of vectors and lists and the macro is expanded out for you. You can even embed code in the HTML and now it will be expanded out too. Find it much easier to read than at the XML-like syntax or HTML, and with hiccup, you never need to worry about closing a tag. Now, the examples I've shown you have been a bit simple, so I want to be sure about one thing that you don't get the impression that this is like number defined macros or the C pre-processor. The lisp macros are Turing complete, the macro can do anything at all, you can program to the input. In this example, we have a macro called unplus that actually rewrites the source code before the compiler gets it, replacing pluses with minuses. I don't know why you'd want to do such a thing, but hey, you can do it. I see macros that automatically paralyze code, macros that converts code into CPS and create anonymous threads out of functions. One of the taglines for Lisp is that it's a programmable programming language, and that the way the program and it is the first singular perfect language for solving the problem you have and then create that language using macros and then use that to solve the problem. You have to be careful with that technique though. It's very easy to make a code that's unreadable because no one's going to know what your macros are doing. So, let's talk about how macros interact with variables. In this example, we have a global variable named sum that we want to pass to the macro. But unfortunately, the macro has a local variable called sum as well. Now, this local variable ends up shadowing the global one. When I call mk-sum on two and sum, the macros expanded at compile time. So, the symbol sum is passed in and just paste it into the code and gets captured. Now, you could just try changing the name of your variable, but you can never really be certain that you would always avoid capture since users could mean they're variables anything they want. So, to fix this, there's a function called gensym, which will give you a new variable that's guaranteed not to have been used before. You've seen this in your machine problem and you may have seen it in prologue if you gave it the right kind of query, because prologue will gensym variables automatically when it needs them. And SWI prologue, the gensym variables start with an underscore. So, that is unintended variable capture and how to fix it, but sometimes, you actually want to capture a variable. So, here's a fun example. Sometimes you need to open a file or a database, and the function to do that will give you a handle that you must check to see if it succeeded and if so, you use a handle to do your operation. This is similar to the width macros we saw earlier but we're solving in a slightly different way. So, you end up with the codes like nine through 11, right? You open the buffer, you check to see if the buffer exists and you do something with it. So, to avoid working for the computer, you can create this macro called a anaphoric if. Ana is Greek meaning again. So, this macro defines a variable called it to be whatever was in the condition part. Now, that can be really useful assuming you don't already have a variable named it. If you're trying these examples yourselves, you might want to see if you can make a more general version where you can specify the name of the variable instead of just using the variable name it. But here's an example that does allow you to specify names. The Emacs lisp doesn't have pattern matching like Haskell does, but with this sort of macro, we can add it. So, an example here we call match on x, I mean x is supposed to be a pair. So, the first part gets assigned to a, the second apart gets assigned to b and then the body just adds a and b together. So, the ability to have a program that writes another program is hard to overstate. This was just a very brief introduction, and my brother used to work for the trucking industry as a database programmer. He is often asked to rate these reports Software in C++, and he noticed that most reports have the same kind of routines in them. So, what he did was write a program where he could list what sections were needed and the program will output the source to the report generator and then he would just customize that to the particular situation. This made a one-hour task into a five-minute one. So, Haskell does have a system called template Haskell if you're interested in macros for Haskell, but you may notice Haskell programmers don't often feel the need to use macros at all. So, for one thing since Haskell is lazy, we've removed the first use case we discussed. You can write an if statement in Haskell and I'll be just fine. We also have type classes and Monads which do a lot of the boilerplate wrapping that macros did in other languages. So, that's about all we have for this topic. I hope you'll try writing a language that uses Macros just to experience what it's like. Really does change the way you think about programming, even if you don't use macros on a day-to-day basis.