Hello everyone. Welcome to CS 421. Today we're going to talk about interpreters which is going to be the backbone of what this course is about. One of our hopes is that you will leave this course knowing how to implement a programming language of your choice, and this is going to be the groundwork of how to get started doing that. So, our objectives are going to be able to talk about the different parts of an interpreter and demonstrate how to build them. So, we'll talk about abstract syntax trees which is a data structure we use to build interpreters. We'll talk about what the differences between an interpreter and compiler. Because there are two different ways to run a computer program at least, and we'll talk about the REPL which is going to be a little bit reviewed because you've seen that. But the exciting thing is we're going to show you live HASKELL code which will allow you to run a very very simple interpreter and get started building more complicated ones. To start, let's talk about what we mean by an interpreter. There's really two ways to execute code on a computer. One is to take your computer code and then convert it into the native machine code that the CPU uses so that the CPU can run it directly. This called compiling. If you imagine that you had a book you wanted to read that was in some language you didn't understand, one thing you could do is hire someone to translate that into a new book that is in your own language. This is like compiling. So, now you can read the book directly. It's a lot more work to get the book done, has to be done all in one go sort of disclaimers of course. But once you have it, assuming you have a good reading speed, you can read this very quickly. Now, a compiler on the computer's sense, it takes about a semester to teach someone how to write a good compiler. It's a very complicated piece of software. So, the other way of having a computer program on your computer is to take your code and then have what's called an interpreter. So, it'll just read your line of code and then execute the code for you on your behalf. Now, this is like having someone read the book to you. So, they pick up this book which is written in a language you don't understand and they just translate it as they go. So, they're reading a book to you. If you decide you want to read another page or the same page again, they have to go back and reread it to you. So, it's not as fast. You have this intermediary, but it's much simpler to get started. This is a method we're going to use in the course. Now, in real life of course things are a little bit more complicated than this. A lot of languages use a hybrid approach. So, for example in Java or even Python will take your source code and compile it into what's called a byte code, and then that byte code is interpreted. But the byte code is very very simple, so the interpreter is able to run very quickly. So, the parts of an interpreter, the first part is called the parser which takes your program code and converts it into a data structure called an abstract syntax tree. The next is the evaluator, which is a function which takes the abstract syntax tree and sometimes some other stuff and then executes that. Decides what the results should be, and usually it emits a resulting value. That can be more complicated as well depending on the language. We will need an environment because we will probably have variables and want to know what they mean. So, we have to keep track of that. Now, tying all that together, we have what's called the REPL, the Read, Eval, Print, Loop. So, you've seen this in HASKELL already when you type stack REPL or there's a couple other ways that you can get a HASKELL prompt and then type in HASKELL code and have it execute directly. So, to make a language, we're going to make one with all of these features. So, I have integers and Booleans as your basic types. Then we can have the different operations that we want like arithmetic comparisons, we have if statements or if expressions, we have local variables using a let construct which is very much like the one you've seen in HASKELL, and we'll also have functions. Functions are going to take up their own video because there's a lot going on inside of a function when it's called. Now, to help you out with this, we will have provided a directory called first, and inside that directory is a bunch of subdirectories called i1, i2, and so forth. We're going to show you this interpreter and stages. Just get it barely started that will be i1 and i2 will add some features, I3 will add some more features and so forth. The course website will have details about how you can access the same. Now, if you're using stack which we recommend, then there's a few commands that will run things for you. If you type stack build inside of the first directory, that will compile all of these interpreters for you so you can run them. Then, to run a particular interpreter like i1, you say stack exec i1 if you want the HASKELL REPL. So, you can play with the different functions that are inside there. Then you say stack repl i1/Mains.hs, and that will load the interpreter but give you the HASKELL prompt. So, you will have two REPLs going on at the same time. One for HASKEL and one for the interpreter. So, it will be switching back and forth. Now to get started, there's usually about three different things we have to do. The first thing that we usually will do in this course is start by defining the types. Since three types that we need for our interpreter at least for today. Future interpreters will be a little bit more complex. We have this type Exp for expression. For this very first interpreter, we're going to have only a support integers. So, very very simple. So, we have one constructor called int x, which takes an integer argument. Similarly, we have another type for values. This is going to be the output. So, once a program has been run, we're going to get a value back. So, we have integer value, and that's going to take an integer argument. Now, there's more than one way we could have chosen to do this. In some languages, it makes sense to conflate expressions and values, and have them represented by a single type. One of the assignments you'll get in this course will do just that most likely. Finally, we have this environment Env. That's going to be a list of word pairs, which is like the associative list that we talked about in the previous lecture. The pairs are going to be the string part which contains the name of the variable, and the value type which contains the value that the variable holds. So, the second thing we will do once we've defined the types we want to represent our expressions is we'll add a line to eval. So, eval has two arguments, and expression, and an environment, and the result is a value. So, the first thing we'll do is we'll write the code for interpreting integers. So, if we get an integer expression, we simply return the corresponding integer value. Not very exciting perhaps we're got to start from somewhere. Now here on the slide also some HASKELL code or UNIX code that you can type and to get things started. So if you type stack repl i1/Main.hs, you should get this HASKELL prompt, will have main and a bunch of other stuff in there. We can take the type of eval and look at it, make sure it has a type we expected. We can eval an integer expression 123 with the empty list because we don't have any variables yet. So, we don't need to think about them, and we get an IntVal back 123, or we can start the interpreters repl by typing main and then it prints out the, nice welcome to your interpreter prompt, and then the i1 prompt is your interpreters REPL prompt. So, you can type in 23 parses that and gives you an IntVal 23 back. Now, in all of these sample interpreters, we've given you the parsers. It's going take us about five lectures to teach you how to write a good parser. So, we wanted you to be able to get started right away in writing the other stuff. So, this is the approach we're using. We've also added that command quit so you can get out of that interpreter gracefully. Now, when we run this stuff, we're going to get something called an abstract syntax tree. So, let's add another type to our expression in operator expression. So, we want to do a lot things like plus, and times, and whatnot. The data structure now has a tree-like form. So, if I parse three plus four times five, and I use the traditional order of operations, we get this the tree back. So, you notice the root of the tree is IntOpExp plus. Because a plus is a last thing to be done, so the left side is the three, the right side is the multiplication which has its own two arguments, IntExp 4 and IntExp 5. So, parsing these kind of trees and manipulating these trees is a big part of what interpreters are going to do. Now, here's our first pass of writing eval, and this would be an i2. If you remember the slides we went over for the higher-order functions lecture, this code should bother you. Because look what's going on here. The first four lines are crossing IntOpExp where the operation is a plus. Then in line four where we're turning the ends of v1 and v2 with plus and between them to add them together, five through eight the same thing, except the plus has been replaced by star minus nine to tell the same thing except now we've replaced it with a minus. Lot of code duplication here and you know how we feel about that in this course. We want to get rid of it. So, there is a nicer way. We're going to make a dictionary. So, in this dictionary, the key part is going to be a string which has the operation and question that we want to represent. So, in this case it's plus, minus, times, and slash. The value part of this pair will have the actual HASKELL function that we're going to need to do the job. So, we have the literal plus, the literal minus and div is integer division. Now, the trick to this is that these functions, these HASKELL functions work on bare HASKELL types. So, maybe we'll call them ground level. So, if we are using plus, that's going to work on HASKELL integers. But we want them to work on our interpreters and integers. So, mainly we want them to work on IntVal. So, what we're going to do is we're going to have a function called a lifting function. So, here in line six and seven, you see it. Is LiftIntOp. So, that takes a HASKELL function and list it into our interpreter space. So, now what we can do is call LiftIntOp on times, and then give it to IntVal. So, IntVal 10 and IntVal 20, and you can see what the code is doing. It's extracting those values and calling them i1 and i2, and then parsing them to the HASKELL function which gives us a literal HASKELL integer. Then re-wrapping it into another IntVal. That enables us to use a HASKELL function that's already defined, and suddenly magically we have it defined for our interpreter as well. Now, if we happened to apply this to something that doesn't make sense and we only have one value type now, but we're going to soon have others. We're just going to take the C way of doing it and just return a zero. If something doesn't make sense, we'll just return zero. It's terrible language design honestly, but we'll go over air handling later. We just want to give you a big picture. So, here's what the code looks like now with our new version of eval. So, i2. So, we have this new IntOpExp and we've taken our parameter Op now and then we'll just look up OP in the IntOpExp dictionary, and that it's going to return a Just F. Again here we're not going to check for errors. We're going to assume that all the operators work. If you give it an operator that it doesn't know about, it will just crash your program. So, we'll show how to do proper error checking in a future interpreter. So, now why don't you try this. Go ahead and look at the code for i1 and i2 and make sure you understand it. Maybe poke at it, breaks something, see what goes, see what happens. Then i3, we've added some more constructors. We've added two expression types, RelOp for relational operations, and BoolOpExp for and and or. We've also added a Boolean expression and Boolean values. So, you can have true and false. We've updated the parser for you so that you can type stuff in and have this be returned. So, see if you can update eval to work with these new things. To play with it for a little bit. If you get stuck just go ahead and pick at i4. But I encourage you really try to get this working for yourself.