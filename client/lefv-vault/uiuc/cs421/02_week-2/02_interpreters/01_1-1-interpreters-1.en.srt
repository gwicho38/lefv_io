1
00:00:02,390 --> 00:00:06,450
Hello everyone. Welcome to CS 421.

2
00:00:06,450 --> 00:00:10,530
Today we're going to talk about interpreters which is going to

3
00:00:10,530 --> 00:00:14,505
be the backbone of what this course is about.

4
00:00:14,505 --> 00:00:17,460
One of our hopes is that you will leave this course

5
00:00:17,460 --> 00:00:20,460
knowing how to implement a programming language of your choice,

6
00:00:20,460 --> 00:00:24,065
and this is going to be the groundwork of how to get started doing that.

7
00:00:24,065 --> 00:00:26,850
So, our objectives are going to be able to talk about

8
00:00:26,850 --> 00:00:30,920
the different parts of an interpreter and demonstrate how to build them.

9
00:00:30,920 --> 00:00:33,380
So, we'll talk about abstract syntax trees which is

10
00:00:33,380 --> 00:00:36,400
a data structure we use to build interpreters.

11
00:00:36,400 --> 00:00:40,009
We'll talk about what the differences between an interpreter and compiler.

12
00:00:40,009 --> 00:00:43,845
Because there are two different ways to run a computer program at least,

13
00:00:43,845 --> 00:00:45,980
and we'll talk about the REPL which is going to be

14
00:00:45,980 --> 00:00:48,110
a little bit reviewed because you've seen that.

15
00:00:48,110 --> 00:00:52,520
But the exciting thing is we're going to show you live HASKELL code which

16
00:00:52,520 --> 00:00:54,080
will allow you to run

17
00:00:54,080 --> 00:00:57,970
a very very simple interpreter and get started building more complicated ones.

18
00:00:57,970 --> 00:01:00,515
To start, let's talk about what we mean by an interpreter.

19
00:01:00,515 --> 00:01:03,590
There's really two ways to execute code on a computer.

20
00:01:03,590 --> 00:01:07,430
One is to take your computer code and then convert it into

21
00:01:07,430 --> 00:01:12,085
the native machine code that the CPU uses so that the CPU can run it directly.

22
00:01:12,085 --> 00:01:13,630
This called compiling.

23
00:01:13,630 --> 00:01:16,520
If you imagine that you had a book you wanted

24
00:01:16,520 --> 00:01:19,280
to read that was in some language you didn't understand,

25
00:01:19,280 --> 00:01:21,860
one thing you could do is hire someone to translate

26
00:01:21,860 --> 00:01:25,175
that into a new book that is in your own language.

27
00:01:25,175 --> 00:01:28,275
This is like compiling. So, now you can read the book directly.

28
00:01:28,275 --> 00:01:31,850
It's a lot more work to get the book done,

29
00:01:31,850 --> 00:01:36,005
has to be done all in one go sort of disclaimers of course.

30
00:01:36,005 --> 00:01:38,415
But once you have it,

31
00:01:38,415 --> 00:01:40,335
assuming you have a good reading speed,

32
00:01:40,335 --> 00:01:42,390
you can read this very quickly.

33
00:01:42,390 --> 00:01:46,480
Now, a compiler on the computer's sense,

34
00:01:46,480 --> 00:01:50,945
it takes about a semester to teach someone how to write a good compiler.

35
00:01:50,945 --> 00:01:53,814
It's a very complicated piece of software.

36
00:01:53,814 --> 00:01:57,080
So, the other way of having a computer program on

37
00:01:57,080 --> 00:02:00,770
your computer is to take your code and then have what's called an interpreter.

38
00:02:00,770 --> 00:02:06,405
So, it'll just read your line of code and then execute the code for you on your behalf.

39
00:02:06,405 --> 00:02:10,180
Now, this is like having someone read the book to you.

40
00:02:10,180 --> 00:02:13,130
So, they pick up this book which is written in a language

41
00:02:13,130 --> 00:02:16,365
you don't understand and they just translate it as they go.

42
00:02:16,365 --> 00:02:17,770
So, they're reading a book to you.

43
00:02:17,770 --> 00:02:21,140
If you decide you want to read another page or the same page again,

44
00:02:21,140 --> 00:02:23,320
they have to go back and reread it to you.

45
00:02:23,320 --> 00:02:24,990
So, it's not as fast.

46
00:02:24,990 --> 00:02:26,985
You have this intermediary,

47
00:02:26,985 --> 00:02:29,910
but it's much simpler to get started.

48
00:02:29,910 --> 00:02:32,380
This is a method we're going to use in the course.

49
00:02:32,380 --> 00:02:37,015
Now, in real life of course things are a little bit more complicated than this.

50
00:02:37,015 --> 00:02:39,380
A lot of languages use a hybrid approach.

51
00:02:39,380 --> 00:02:42,755
So, for example in Java or even Python

52
00:02:42,755 --> 00:02:46,970
will take your source code and compile it into what's called a byte code,

53
00:02:46,970 --> 00:02:48,980
and then that byte code is interpreted.

54
00:02:48,980 --> 00:02:50,985
But the byte code is very very simple,

55
00:02:50,985 --> 00:02:53,300
so the interpreter is able to run very quickly.

56
00:02:53,300 --> 00:02:55,175
So, the parts of an interpreter,

57
00:02:55,175 --> 00:02:59,210
the first part is called the parser which takes your program code

58
00:02:59,210 --> 00:03:03,860
and converts it into a data structure called an abstract syntax tree.

59
00:03:03,860 --> 00:03:05,720
The next is the evaluator,

60
00:03:05,720 --> 00:03:09,050
which is a function which takes the abstract syntax tree and

61
00:03:09,050 --> 00:03:12,975
sometimes some other stuff and then executes that.

62
00:03:12,975 --> 00:03:14,910
Decides what the results should be,

63
00:03:14,910 --> 00:03:18,505
and usually it emits a resulting value.

64
00:03:18,505 --> 00:03:22,770
That can be more complicated as well depending on the language.

65
00:03:22,770 --> 00:03:25,115
We will need an environment because we will

66
00:03:25,115 --> 00:03:27,510
probably have variables and want to know what they mean.

67
00:03:27,510 --> 00:03:29,295
So, we have to keep track of that.

68
00:03:29,295 --> 00:03:30,790
Now, tying all that together,

69
00:03:30,790 --> 00:03:32,110
we have what's called the REPL,

70
00:03:32,110 --> 00:03:33,875
the Read, Eval, Print, Loop.

71
00:03:33,875 --> 00:03:38,390
So, you've seen this in HASKELL already when you type stack REPL or there's

72
00:03:38,390 --> 00:03:40,950
a couple other ways that you can get a HASKELL prompt and then

73
00:03:40,950 --> 00:03:44,335
type in HASKELL code and have it execute directly.

74
00:03:44,335 --> 00:03:46,060
So, to make a language,

75
00:03:46,060 --> 00:03:48,010
we're going to make one with all of these features.

76
00:03:48,010 --> 00:03:51,770
So, I have integers and Booleans as your basic types.

77
00:03:51,770 --> 00:03:56,345
Then we can have the different operations that we want like arithmetic comparisons,

78
00:03:56,345 --> 00:03:59,015
we have if statements or if expressions,

79
00:03:59,015 --> 00:04:00,530
we have local variables using

80
00:04:00,530 --> 00:04:04,440
a let construct which is very much like the one you've seen in HASKELL,

81
00:04:04,440 --> 00:04:06,465
and we'll also have functions.

82
00:04:06,465 --> 00:04:09,140
Functions are going to take up their own video because there's

83
00:04:09,140 --> 00:04:12,390
a lot going on inside of a function when it's called.

84
00:04:12,390 --> 00:04:14,915
Now, to help you out with this,

85
00:04:14,915 --> 00:04:19,250
we will have provided a directory called first,

86
00:04:19,250 --> 00:04:22,440
and inside that directory is a bunch of subdirectories called i1,

87
00:04:22,440 --> 00:04:24,020
i2, and so forth.

88
00:04:24,020 --> 00:04:27,370
We're going to show you this interpreter and stages.

89
00:04:27,370 --> 00:04:31,910
Just get it barely started that will be i1 and i2 will add some features,

90
00:04:31,910 --> 00:04:34,100
I3 will add some more features and so forth.

91
00:04:34,100 --> 00:04:37,615
The course website will have details about how you can access the same.

92
00:04:37,615 --> 00:04:40,120
Now, if you're using stack which we recommend,

93
00:04:40,120 --> 00:04:42,920
then there's a few commands that will run things for you.

94
00:04:42,920 --> 00:04:46,070
If you type stack build inside of the first directory,

95
00:04:46,070 --> 00:04:49,820
that will compile all of these interpreters for you so you can run them.

96
00:04:49,820 --> 00:04:52,930
Then, to run a particular interpreter like i1,

97
00:04:52,930 --> 00:04:56,920
you say stack exec i1 if you want the HASKELL REPL.

98
00:04:56,920 --> 00:05:00,005
So, you can play with the different functions that are inside there.

99
00:05:00,005 --> 00:05:03,320
Then you say stack repl i1/Mains.hs,

100
00:05:03,320 --> 00:05:06,460
and that will load the interpreter but give you the HASKELL prompt.

101
00:05:06,460 --> 00:05:09,740
So, you will have two REPLs going on at the same time.

102
00:05:09,740 --> 00:05:12,160
One for HASKEL and one for the interpreter.

103
00:05:12,160 --> 00:05:14,335
So, it will be switching back and forth.

104
00:05:14,335 --> 00:05:16,064
Now to get started,

105
00:05:16,064 --> 00:05:19,040
there's usually about three different things we have to do.

106
00:05:19,040 --> 00:05:24,169
The first thing that we usually will do in this course is start by defining the types.

107
00:05:24,169 --> 00:05:29,010
Since three types that we need for our interpreter at least for today.

108
00:05:29,010 --> 00:05:31,900
Future interpreters will be a little bit more complex.

109
00:05:31,900 --> 00:05:35,005
We have this type Exp for expression.

110
00:05:35,005 --> 00:05:36,800
For this very first interpreter,

111
00:05:36,800 --> 00:05:38,610
we're going to have only a support integers.

112
00:05:38,610 --> 00:05:40,345
So, very very simple.

113
00:05:40,345 --> 00:05:42,950
So, we have one constructor called int x,

114
00:05:42,950 --> 00:05:44,470
which takes an integer argument.

115
00:05:44,470 --> 00:05:46,920
Similarly, we have another type for values.

116
00:05:46,920 --> 00:05:48,335
This is going to be the output.

117
00:05:48,335 --> 00:05:50,690
So, once a program has been run,

118
00:05:50,690 --> 00:05:52,370
we're going to get a value back.

119
00:05:52,370 --> 00:05:54,260
So, we have integer value,

120
00:05:54,260 --> 00:05:56,675
and that's going to take an integer argument.

121
00:05:56,675 --> 00:06:01,100
Now, there's more than one way we could have chosen to do this.

122
00:06:01,100 --> 00:06:05,540
In some languages, it makes sense to conflate expressions and values,

123
00:06:05,540 --> 00:06:07,820
and have them represented by a single type.

124
00:06:07,820 --> 00:06:12,740
One of the assignments you'll get in this course will do just that most likely.

125
00:06:12,740 --> 00:06:15,425
Finally, we have this environment Env.

126
00:06:15,425 --> 00:06:17,520
That's going to be a list of word pairs,

127
00:06:17,520 --> 00:06:21,595
which is like the associative list that we talked about in the previous lecture.

128
00:06:21,595 --> 00:06:25,550
The pairs are going to be the string part which contains the name of the variable,

129
00:06:25,550 --> 00:06:30,145
and the value type which contains the value that the variable holds.

130
00:06:30,145 --> 00:06:34,055
So, the second thing we will do once we've defined the types we want

131
00:06:34,055 --> 00:06:37,990
to represent our expressions is we'll add a line to eval.

132
00:06:37,990 --> 00:06:40,820
So, eval has two arguments, and expression,

133
00:06:40,820 --> 00:06:43,870
and an environment, and the result is a value.

134
00:06:43,870 --> 00:06:47,270
So, the first thing we'll do is we'll write the code for interpreting integers.

135
00:06:47,270 --> 00:06:49,435
So, if we get an integer expression,

136
00:06:49,435 --> 00:06:52,215
we simply return the corresponding integer value.

137
00:06:52,215 --> 00:06:55,175
Not very exciting perhaps we're got to start from somewhere.

138
00:06:55,175 --> 00:06:57,990
Now here on the slide also some HASKELL code or

139
00:06:57,990 --> 00:07:01,190
UNIX code that you can type and to get things started.

140
00:07:01,190 --> 00:07:04,725
So if you type stack repl i1/Main.hs,

141
00:07:04,725 --> 00:07:06,555
you should get this HASKELL prompt,

142
00:07:06,555 --> 00:07:09,225
will have main and a bunch of other stuff in there.

143
00:07:09,225 --> 00:07:12,140
We can take the type of eval and look at it,

144
00:07:12,140 --> 00:07:14,505
make sure it has a type we expected.

145
00:07:14,505 --> 00:07:17,210
We can eval an integer expression 123

146
00:07:17,210 --> 00:07:20,690
with the empty list because we don't have any variables yet.

147
00:07:20,690 --> 00:07:22,375
So, we don't need to think about them,

148
00:07:22,375 --> 00:07:24,790
and we get an IntVal back 123,

149
00:07:24,790 --> 00:07:29,810
or we can start the interpreters repl by typing main and then it prints out the,

150
00:07:29,810 --> 00:07:32,225
nice welcome to your interpreter prompt,

151
00:07:32,225 --> 00:07:35,580
and then the i1 prompt is your interpreters REPL prompt.

152
00:07:35,580 --> 00:07:41,085
So, you can type in 23 parses that and gives you an IntVal 23 back.

153
00:07:41,085 --> 00:07:44,490
Now, in all of these sample interpreters,

154
00:07:44,490 --> 00:07:45,980
we've given you the parsers.

155
00:07:45,980 --> 00:07:49,860
It's going take us about five lectures to teach you how to write a good parser.

156
00:07:49,860 --> 00:07:53,720
So, we wanted you to be able to get started right away in writing the other stuff.

157
00:07:53,720 --> 00:07:55,930
So, this is the approach we're using.

158
00:07:55,930 --> 00:08:01,190
We've also added that command quit so you can get out of that interpreter gracefully.

159
00:08:01,190 --> 00:08:04,175
Now, when we run this stuff,

160
00:08:04,175 --> 00:08:07,385
we're going to get something called an abstract syntax tree.

161
00:08:07,385 --> 00:08:12,220
So, let's add another type to our expression in operator expression.

162
00:08:12,220 --> 00:08:14,360
So, we want to do a lot things like plus,

163
00:08:14,360 --> 00:08:16,265
and times, and whatnot.

164
00:08:16,265 --> 00:08:18,700
The data structure now has a tree-like form.

165
00:08:18,700 --> 00:08:21,520
So, if I parse three plus four times five,

166
00:08:21,520 --> 00:08:24,110
and I use the traditional order of operations,

167
00:08:24,110 --> 00:08:25,655
we get this the tree back.

168
00:08:25,655 --> 00:08:29,215
So, you notice the root of the tree is IntOpExp plus.

169
00:08:29,215 --> 00:08:31,605
Because a plus is a last thing to be done,

170
00:08:31,605 --> 00:08:33,680
so the left side is the three,

171
00:08:33,680 --> 00:08:37,345
the right side is the multiplication which has its own two arguments,

172
00:08:37,345 --> 00:08:39,945
IntExp 4 and IntExp 5.

173
00:08:39,945 --> 00:08:42,560
So, parsing these kind of trees and manipulating

174
00:08:42,560 --> 00:08:45,955
these trees is a big part of what interpreters are going to do.

175
00:08:45,955 --> 00:08:49,325
Now, here's our first pass of writing eval,

176
00:08:49,325 --> 00:08:51,515
and this would be an i2.

177
00:08:51,515 --> 00:08:58,185
If you remember the slides we went over for the higher-order functions lecture,

178
00:08:58,185 --> 00:09:00,040
this code should bother you.

179
00:09:00,040 --> 00:09:01,730
Because look what's going on here.

180
00:09:01,730 --> 00:09:06,860
The first four lines are crossing IntOpExp where the operation is a plus.

181
00:09:06,860 --> 00:09:10,970
Then in line four where we're turning the ends

182
00:09:10,970 --> 00:09:15,045
of v1 and v2 with plus and between them to add them together,

183
00:09:15,045 --> 00:09:16,525
five through eight the same thing,

184
00:09:16,525 --> 00:09:19,460
except the plus has been replaced by star minus

185
00:09:19,460 --> 00:09:22,595
nine to tell the same thing except now we've replaced it with a minus.

186
00:09:22,595 --> 00:09:26,810
Lot of code duplication here and you know how we feel about that in this course.

187
00:09:26,810 --> 00:09:28,120
We want to get rid of it.

188
00:09:28,120 --> 00:09:30,155
So, there is a nicer way.

189
00:09:30,155 --> 00:09:31,790
We're going to make a dictionary.

190
00:09:31,790 --> 00:09:33,260
So, in this dictionary,

191
00:09:33,260 --> 00:09:35,750
the key part is going to be a string

192
00:09:35,750 --> 00:09:39,020
which has the operation and question that we want to represent.

193
00:09:39,020 --> 00:09:40,520
So, in this case it's plus,

194
00:09:40,520 --> 00:09:42,340
minus, times, and slash.

195
00:09:42,340 --> 00:09:45,500
The value part of this pair will have

196
00:09:45,500 --> 00:09:49,075
the actual HASKELL function that we're going to need to do the job.

197
00:09:49,075 --> 00:09:50,620
So, we have the literal plus,

198
00:09:50,620 --> 00:09:54,480
the literal minus and div is integer division.

199
00:09:54,480 --> 00:09:58,150
Now, the trick to this is that these functions,

200
00:09:58,150 --> 00:10:01,040
these HASKELL functions work on bare HASKELL types.

201
00:10:01,040 --> 00:10:02,840
So, maybe we'll call them ground level.

202
00:10:02,840 --> 00:10:04,840
So, if we are using plus,

203
00:10:04,840 --> 00:10:07,060
that's going to work on HASKELL integers.

204
00:10:07,060 --> 00:10:10,385
But we want them to work on our interpreters and integers.

205
00:10:10,385 --> 00:10:12,925
So, mainly we want them to work on IntVal.

206
00:10:12,925 --> 00:10:17,340
So, what we're going to do is we're going to have a function called a lifting function.

207
00:10:17,340 --> 00:10:19,110
So, here in line six and seven,

208
00:10:19,110 --> 00:10:21,340
you see it. Is LiftIntOp.

209
00:10:21,340 --> 00:10:26,235
So, that takes a HASKELL function and list it into our interpreter space.

210
00:10:26,235 --> 00:10:29,845
So, now what we can do is call LiftIntOp on times,

211
00:10:29,845 --> 00:10:31,710
and then give it to IntVal.

212
00:10:31,710 --> 00:10:33,480
So, IntVal 10 and IntVal 20,

213
00:10:33,480 --> 00:10:34,980
and you can see what the code is doing.

214
00:10:34,980 --> 00:10:38,410
It's extracting those values and calling them i1 and i2,

215
00:10:38,410 --> 00:10:43,000
and then parsing them to the HASKELL function which gives us a literal HASKELL integer.

216
00:10:43,000 --> 00:10:45,985
Then re-wrapping it into another IntVal.

217
00:10:45,985 --> 00:10:49,550
That enables us to use a HASKELL function that's already defined,

218
00:10:49,550 --> 00:10:54,605
and suddenly magically we have it defined for our interpreter as well.

219
00:10:54,605 --> 00:10:57,290
Now, if we happened to apply this to

220
00:10:57,290 --> 00:11:00,540
something that doesn't make sense and we only have one value type now,

221
00:11:00,540 --> 00:11:01,955
but we're going to soon have others.

222
00:11:01,955 --> 00:11:05,650
We're just going to take the C way of doing it and just return a zero.

223
00:11:05,650 --> 00:11:06,980
If something doesn't make sense,

224
00:11:06,980 --> 00:11:08,280
we'll just return zero.

225
00:11:08,280 --> 00:11:10,320
It's terrible language design honestly,

226
00:11:10,320 --> 00:11:13,835
but we'll go over air handling later.

227
00:11:13,835 --> 00:11:16,655
We just want to give you a big picture.

228
00:11:16,655 --> 00:11:23,145
So, here's what the code looks like now with our new version of eval. So, i2.

229
00:11:23,145 --> 00:11:27,370
So, we have this new IntOpExp and we've taken our parameter

230
00:11:27,370 --> 00:11:32,340
Op now and then we'll just look up OP in the IntOpExp dictionary,

231
00:11:32,340 --> 00:11:36,590
and that it's going to return a Just F. Again here we're not going to check for errors.

232
00:11:36,590 --> 00:11:38,510
We're going to assume that all the operators work.

233
00:11:38,510 --> 00:11:41,215
If you give it an operator that it doesn't know about,

234
00:11:41,215 --> 00:11:43,115
it will just crash your program.

235
00:11:43,115 --> 00:11:47,814
So, we'll show how to do proper error checking in a future interpreter.

236
00:11:47,814 --> 00:11:50,065
So, now why don't you try this.

237
00:11:50,065 --> 00:11:55,115
Go ahead and look at the code for i1 and i2 and make sure you understand it.

238
00:11:55,115 --> 00:11:56,845
Maybe poke at it, breaks something,

239
00:11:56,845 --> 00:11:59,165
see what goes, see what happens.

240
00:11:59,165 --> 00:12:02,630
Then i3, we've added some more constructors.

241
00:12:02,630 --> 00:12:04,230
We've added two expression types,

242
00:12:04,230 --> 00:12:06,545
RelOp for relational operations,

243
00:12:06,545 --> 00:12:09,320
and BoolOpExp for and and or.

244
00:12:09,320 --> 00:12:12,010
We've also added a Boolean expression and Boolean values.

245
00:12:12,010 --> 00:12:13,745
So, you can have true and false.

246
00:12:13,745 --> 00:12:19,385
We've updated the parser for you so that you can type stuff in and have this be returned.

247
00:12:19,385 --> 00:12:23,360
So, see if you can update eval to work with these new things.

248
00:12:23,360 --> 00:12:25,070
To play with it for a little bit.

249
00:12:25,070 --> 00:12:27,370
If you get stuck just go ahead and pick at i4.

250
00:12:27,370 --> 00:12:31,020
But I encourage you really try to get this working for yourself.