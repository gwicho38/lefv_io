1
00:00:00,000 --> 00:00:03,285
Hello everyone.
Welcome to CS 421.

2
00:00:03,285 --> 00:00:05,070
Today we're going to talk
about the Interpreter

3
00:00:05,070 --> 00:00:06,780
Activity, and as always,

4
00:00:06,780 --> 00:00:08,670
we hope that you will have
gone through this either by

5
00:00:08,670 --> 00:00:12,150
yourself or with some friends
before watching this video.

6
00:00:12,150 --> 00:00:13,920
Your objectives are to be

7
00:00:13,920 --> 00:00:15,000
able to read the source code for

8
00:00:15,000 --> 00:00:16,410
a simple interpreter and

9
00:00:16,410 --> 00:00:18,285
to understand how
everything works.

10
00:00:18,285 --> 00:00:20,715
We're going to talk about
lifting and how we make

11
00:00:20,715 --> 00:00:24,465
actual Haskell functions work
on our interpreter types,

12
00:00:24,465 --> 00:00:26,340
and then we're going to add
a few features, namely,

13
00:00:26,340 --> 00:00:29,100
we're going to add variables
and comparison operations.

14
00:00:29,100 --> 00:00:31,500
Now first let's talk
about the types.

15
00:00:31,500 --> 00:00:33,450
We have two levels for this;

16
00:00:33,450 --> 00:00:34,800
we have a type to represent

17
00:00:34,800 --> 00:00:36,630
the source code
that the programmer

18
00:00:36,630 --> 00:00:37,760
types in and that's going to be

19
00:00:37,760 --> 00:00:40,580
the Exp type from lines
five through seven.

20
00:00:40,580 --> 00:00:42,440
We're going to start with
two kinds of expressions;

21
00:00:42,440 --> 00:00:43,580
the integer expression and

22
00:00:43,580 --> 00:00:45,385
the integer operation expression.

23
00:00:45,385 --> 00:00:47,735
We're going to have one type
to represent the output,

24
00:00:47,735 --> 00:00:49,340
that's Val, and we're going

25
00:00:49,340 --> 00:00:50,900
to start off with
just integer values,

26
00:00:50,900 --> 00:00:52,685
but we'll add more later.

27
00:00:52,685 --> 00:00:56,330
Finally, to be able to
add variables later,

28
00:00:56,330 --> 00:00:58,345
we're going to have
an environment type.

29
00:00:58,345 --> 00:01:00,230
When we have a variable,

30
00:01:00,230 --> 00:01:01,565
we need some way to look up

31
00:01:01,565 --> 00:01:03,575
what the corresponding value is.

32
00:01:03,575 --> 00:01:05,510
The type on the
slide is listed as

33
00:01:05,510 --> 00:01:07,580
list of pair with
string and expression,

34
00:01:07,580 --> 00:01:11,795
and that's a bug because we
want to have a value instead.

35
00:01:11,795 --> 00:01:14,090
Now there are some languages
which might allow you to

36
00:01:14,090 --> 00:01:17,845
put expression inside of
variables, that's pretty rare.

37
00:01:17,845 --> 00:01:19,690
Let's talk about
how we're going to

38
00:01:19,690 --> 00:01:21,130
make Haskell functions work

39
00:01:21,130 --> 00:01:24,140
with the types we have
for our interpreter.

40
00:01:24,140 --> 00:01:26,600
One way to do that
is first I create

41
00:01:26,600 --> 00:01:28,280
a dictionary to map

42
00:01:28,280 --> 00:01:30,410
strings to the actual
Haskell functions,

43
00:01:30,410 --> 00:01:33,005
so one variation of the
type is given above.

44
00:01:33,005 --> 00:01:34,925
It's very similar to
the environment type,

45
00:01:34,925 --> 00:01:38,250
but it remaps strings to
integer error, integer error,

46
00:01:38,250 --> 00:01:40,150
integer instead of to value,

47
00:01:40,150 --> 00:01:42,770
so this allows the programmer
to specify slash and

48
00:01:42,770 --> 00:01:43,850
their source code and we get

49
00:01:43,850 --> 00:01:46,225
the actual function div
out the other side.

50
00:01:46,225 --> 00:01:48,920
Now, to make these
functions work with values,

51
00:01:48,920 --> 00:01:51,364
we have what we call
lifting operation.

52
00:01:51,364 --> 00:01:53,660
You see this on line
six through eight,

53
00:01:53,660 --> 00:01:55,415
though we have a
function as the input,

54
00:01:55,415 --> 00:01:56,600
which is a Haskell function,

55
00:01:56,600 --> 00:01:58,550
and then we input
two integer values,

56
00:01:58,550 --> 00:02:00,930
and then we basically extract

57
00:02:00,930 --> 00:02:05,115
the actual integers
out of the IntVals,

58
00:02:05,115 --> 00:02:06,450
apply them to the
function and then

59
00:02:06,450 --> 00:02:08,310
rewrap that into another IntVal.

60
00:02:08,310 --> 00:02:10,725
The bug is on line 8,

61
00:02:10,725 --> 00:02:13,185
so you see we're
returning a zero here,

62
00:02:13,185 --> 00:02:17,550
and that's a numeric type
or IntVal is a Val type,

63
00:02:17,550 --> 00:02:19,160
you can't have two separate types

64
00:02:19,160 --> 00:02:21,530
coming out on the same
function like that.

65
00:02:21,530 --> 00:02:23,990
Once you have this thing working,

66
00:02:23,990 --> 00:02:25,450
it allows you to say things like,

67
00:02:25,450 --> 00:02:27,670
liftIntOp star and
then give it IntVal 3

68
00:02:27,670 --> 00:02:30,270
and IntVal 7 and give
it IntVal 21 back.

69
00:02:30,270 --> 00:02:31,940
Now, if you want to
take care of that bug,

70
00:02:31,940 --> 00:02:33,670
there is two ways
you could do with.

71
00:02:33,670 --> 00:02:37,265
Line 8 gives what you might
call the JavaScript way,

72
00:02:37,265 --> 00:02:39,650
where if something
breaks, it just says,

73
00:02:39,650 --> 00:02:40,740
oh well and keeps going,

74
00:02:40,740 --> 00:02:43,040
so maybe just return a zero
and hope for the best.

75
00:02:43,040 --> 00:02:45,365
A little bit better

76
00:02:45,365 --> 00:02:48,685
is to have an error message
like you would on line 9,

77
00:02:48,685 --> 00:02:51,140
so you'll pick one of
these two lines to use,

78
00:02:51,140 --> 00:02:53,180
and the combined is
actually going to give you

79
00:02:53,180 --> 00:02:55,190
a warning that the
code is unreachable.

80
00:02:55,190 --> 00:02:57,680
This is because we only
have one value type,

81
00:02:57,680 --> 00:03:00,110
which means line 7
is going to handle

82
00:03:00,110 --> 00:03:01,490
every possible thing you could

83
00:03:01,490 --> 00:03:03,835
call this function
with at the time.

84
00:03:03,835 --> 00:03:05,690
Now line zero,
there's another way

85
00:03:05,690 --> 00:03:06,950
we could have done this;

86
00:03:06,950 --> 00:03:09,260
we can be a little bit
more general and say

87
00:03:09,260 --> 00:03:11,645
that this works for all
types that are integrals,

88
00:03:11,645 --> 00:03:14,800
integral just means you could
turn it into a fraction.

89
00:03:14,800 --> 00:03:17,615
It's more general than what
we need for our interpreter,

90
00:03:17,615 --> 00:03:19,160
but well, who knows,

91
00:03:19,160 --> 00:03:21,310
maybe we want to extend it later.

92
00:03:21,310 --> 00:03:23,300
Now we get to the heart of

93
00:03:23,300 --> 00:03:25,475
the interpreter, which is eval.

94
00:03:25,475 --> 00:03:28,820
The eval takes your expression
in the environment,

95
00:03:28,820 --> 00:03:30,440
the assignment of variables and

96
00:03:30,440 --> 00:03:32,270
then gives you back the
corresponding values.

97
00:03:32,270 --> 00:03:33,320
This is the thing that's actually

98
00:03:33,320 --> 00:03:34,925
going to run your program.

99
00:03:34,925 --> 00:03:38,570
The line 1, we have
integer expressions,

100
00:03:38,570 --> 00:03:41,285
we just return the
corresponding integer value.

101
00:03:41,285 --> 00:03:43,010
We've already talked about this

102
00:03:43,010 --> 00:03:44,390
that we are not just
going to return

103
00:03:44,390 --> 00:03:45,650
integers because we expect to

104
00:03:45,650 --> 00:03:47,450
have other kinds of values later.

105
00:03:47,450 --> 00:03:49,205
The lines three through seven,

106
00:03:49,205 --> 00:03:51,190
we have integer
operation expressions,

107
00:03:51,190 --> 00:03:53,765
so we have two
sub-expressions, e1 and e2.

108
00:03:53,765 --> 00:03:55,280
This is a big thing
that you're going to

109
00:03:55,280 --> 00:03:57,170
find in the language class,

110
00:03:57,170 --> 00:03:59,870
is that the value
of an expression

111
00:03:59,870 --> 00:04:02,209
is determined by composing

112
00:04:02,209 --> 00:04:03,890
the values of its subexpressions.

113
00:04:03,890 --> 00:04:05,480
When I say value,

114
00:04:05,480 --> 00:04:06,740
I can mean other properties too,

115
00:04:06,740 --> 00:04:10,190
like the type and the pattern
is almost always the same.

116
00:04:10,190 --> 00:04:12,350
We're going to look at
the subexpressions first,

117
00:04:12,350 --> 00:04:14,150
and then we're going to
combine those results.

118
00:04:14,150 --> 00:04:16,550
We do that here on
lines four and five,

119
00:04:16,550 --> 00:04:20,810
we call eval on e1 and
e2 to get v1 and v2.

120
00:04:20,810 --> 00:04:25,580
We look up the operator
and intOps from line 6,

121
00:04:25,580 --> 00:04:27,140
and you see that
they're returning

122
00:04:27,140 --> 00:04:30,410
a just f, or assuming that.

123
00:04:30,410 --> 00:04:32,765
The reason that lookup does this,

124
00:04:32,765 --> 00:04:34,280
so if you look up something in

125
00:04:34,280 --> 00:04:35,810
a dictionary and it's not there,

126
00:04:35,810 --> 00:04:38,680
you really have three
options to deal with it;

127
00:04:38,680 --> 00:04:40,260
option 1 is to throw

128
00:04:40,260 --> 00:04:43,340
an error message and then

129
00:04:43,340 --> 00:04:46,960
the programmer has to put a
try-catch block around that.

130
00:04:46,960 --> 00:04:49,925
Option 2 is to return
a default value,

131
00:04:49,925 --> 00:04:52,700
which is actually a
terrible thing to do

132
00:04:52,700 --> 00:04:56,540
unless that really is what
you want to have happen.

133
00:04:56,540 --> 00:04:58,580
The other way is to
use this maybe type.

134
00:04:58,580 --> 00:05:00,560
So you return a nothing
if it's not there and

135
00:05:00,560 --> 00:05:03,735
adjust with the thing
if you found it.

136
00:05:03,735 --> 00:05:06,890
Now, I'm circumventing
that on line 6 because I'm

137
00:05:06,890 --> 00:05:08,750
directly pattern-matching
against just

138
00:05:08,750 --> 00:05:10,850
f. So if the lookup
returns a nothing,

139
00:05:10,850 --> 00:05:12,350
you'll get a runtime error.

140
00:05:12,350 --> 00:05:14,855
This is basically the same thing

141
00:05:14,855 --> 00:05:16,480
as throwing an exception.

142
00:05:16,480 --> 00:05:19,880
Now, this can be
appropriate if you are

143
00:05:19,880 --> 00:05:22,189
generating this expression
problematically

144
00:05:22,189 --> 00:05:23,630
so you know by construction,

145
00:05:23,630 --> 00:05:27,160
as we said that the expression
is going to be correct.

146
00:05:27,160 --> 00:05:30,170
Finally, line 7, we call it lift

147
00:05:30,170 --> 00:05:33,170
operation on f. In this bug 3,

148
00:05:33,170 --> 00:05:34,715
you see there's e1 and e2 there,

149
00:05:34,715 --> 00:05:36,940
it should be v1 and v2.

150
00:05:36,940 --> 00:05:39,600
Let's add a feature
to our language now.

151
00:05:39,600 --> 00:05:42,650
We can start the variables
since they are easy to add.

152
00:05:42,650 --> 00:05:45,305
First, we have to
modify the Exp type.

153
00:05:45,305 --> 00:05:46,700
We add one new constructor

154
00:05:46,700 --> 00:05:49,195
to represent variable
expressions.

155
00:05:49,195 --> 00:05:51,920
Next, we have to add a
corresponding clause to

156
00:05:51,920 --> 00:05:54,475
val to process those
variable expressions.

157
00:05:54,475 --> 00:05:55,980
Line 1 does the lookup,

158
00:05:55,980 --> 00:05:57,590
and the result can be
either that we found

159
00:05:57,590 --> 00:05:59,150
the variable and got a just back,

160
00:05:59,150 --> 00:06:00,200
in which case we return

161
00:06:00,200 --> 00:06:02,090
the value we get
picked to the color,

162
00:06:02,090 --> 00:06:03,935
or else we might get a nothing.

163
00:06:03,935 --> 00:06:06,475
Again, we have two choices
how to handle that;

164
00:06:06,475 --> 00:06:07,820
we could just do it the way

165
00:06:07,820 --> 00:06:09,110
shell scripting languages do

166
00:06:09,110 --> 00:06:11,060
it and give it a default value.

167
00:06:11,060 --> 00:06:12,560
In our case, we'll
have it return a

168
00:06:12,560 --> 00:06:14,150
zero and hope for the best.

169
00:06:14,150 --> 00:06:16,460
This of course, is
terrible language design

170
00:06:16,460 --> 00:06:18,125
if you want reliability.

171
00:06:18,125 --> 00:06:21,400
The better way is to simply
return an error message.

172
00:06:21,400 --> 00:06:24,800
Now, let's add comparison
operations to the language.

173
00:06:24,800 --> 00:06:27,530
We need a new constructor
for Val since we will have

174
00:06:27,530 --> 00:06:30,260
both integer and Boolean
values and the language.

175
00:06:30,260 --> 00:06:32,030
We also need a new
constructor for

176
00:06:32,030 --> 00:06:35,590
Exp to represent
comparison operations.

177
00:06:35,590 --> 00:06:38,210
Now, we would really
have liked to use

178
00:06:38,210 --> 00:06:39,620
the intOps dictionary to

179
00:06:39,620 --> 00:06:41,855
store these comparison
operations,

180
00:06:41,855 --> 00:06:43,400
but a comparison operator has

181
00:06:43,400 --> 00:06:45,760
a different type than
the arithmetic operator,

182
00:06:45,760 --> 00:06:48,095
it outputs a Boolean
instead of an integer.

183
00:06:48,095 --> 00:06:49,520
Because of this, we need

184
00:06:49,520 --> 00:06:50,720
a separate dictionary and

185
00:06:50,720 --> 00:06:52,970
separate lifting operation
to deal with them.

186
00:06:52,970 --> 00:06:55,460
Now, other than the types
and the specific names,

187
00:06:55,460 --> 00:06:57,170
the code here uses
the same idea as

188
00:06:57,170 --> 00:06:59,530
the liftIntOp code we had before.

189
00:06:59,530 --> 00:07:01,235
One nice thing though,

190
00:07:01,235 --> 00:07:02,420
now that we have more than one

191
00:07:02,420 --> 00:07:04,055
constructor and our value type,

192
00:07:04,055 --> 00:07:06,960
the compiler warnings
will go away.

193
00:07:07,220 --> 00:07:10,500
Finally, we can add
the clause to eval.

194
00:07:10,500 --> 00:07:13,475
It has the same structure
as a clause for intOpExp,

195
00:07:13,475 --> 00:07:15,530
only now we're using
the CompOpEx dictionary

196
00:07:15,530 --> 00:07:18,020
and the liftCompOp functions.

197
00:07:18,020 --> 00:07:20,310
That will be all for this video.

198
00:07:20,310 --> 00:07:21,890
In the next activity,
we'll show you how to

199
00:07:21,890 --> 00:07:24,450
add functions to your language.