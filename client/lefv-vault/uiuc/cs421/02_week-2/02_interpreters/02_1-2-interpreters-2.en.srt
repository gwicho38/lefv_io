1
00:00:02,240 --> 00:00:04,920
Hello, everyone and welcome back.

2
00:00:04,920 --> 00:00:06,370
In our last video,

3
00:00:06,370 --> 00:00:08,510
we built an interpreter which is very simple.

4
00:00:08,510 --> 00:00:13,155
All I had was integers and arithmetic operations like plus and times,

5
00:00:13,155 --> 00:00:14,645
and when we ended,

6
00:00:14,645 --> 00:00:19,255
we asked you to think about how you go about adding Boolean style operations to it.

7
00:00:19,255 --> 00:00:21,680
So, connectives like 'and' and 'or'

8
00:00:21,680 --> 00:00:24,510
which take two Booleans to produce another Boolean and

9
00:00:24,510 --> 00:00:32,410
also relational operations which take an integer and return Booleans as a result.

10
00:00:32,410 --> 00:00:35,970
So, the first thing we're going to do as always is we're going to think about what

11
00:00:35,970 --> 00:00:39,600
the type should be in Haskel, the community.

12
00:00:39,600 --> 00:00:43,000
That's our sense of what the best practices is.

13
00:00:43,000 --> 00:00:45,950
Think through the types first and then start writing the code.

14
00:00:45,950 --> 00:00:49,940
So, here we've added three new constructors to the EXP datatype.

15
00:00:49,940 --> 00:00:52,745
We have RelOpExp, which is going to

16
00:00:52,745 --> 00:00:56,065
represent our relational operators like less than and greater than.

17
00:00:56,065 --> 00:00:59,290
We have BoolOpExp, which is going to represent 'and' and 'or'.

18
00:00:59,290 --> 00:01:02,000
We're going to have Bool expressions to

19
00:01:02,000 --> 00:01:05,880
represent Booleans themselves because we're going to need those to get started.

20
00:01:05,880 --> 00:01:09,400
Also, in val, we need to have BoolVal because some

21
00:01:09,400 --> 00:01:13,045
of our results will be Boolean and that's how we're going to represent those.

22
00:01:13,045 --> 00:01:16,900
Now, to get started, let's do BoolOps first,

23
00:01:16,900 --> 00:01:19,405
'and' and 'or' because it's a little bit simpler.

24
00:01:19,405 --> 00:01:23,030
So, we're going to need a dictionary that takes the strings and maps them

25
00:01:23,030 --> 00:01:27,080
into their corresponding Boolean operations and

26
00:01:27,080 --> 00:01:30,860
this is going to look just like the ones we did in the last video where

27
00:01:30,860 --> 00:01:34,790
we had plus and times mapping to the Haskell equivalence.

28
00:01:34,790 --> 00:01:38,525
Only, we have to creating a dictionary because the types of these are different.

29
00:01:38,525 --> 00:01:40,110
So, we can't just mix them together.

30
00:01:40,110 --> 00:01:41,595
It's just a little unfortunate.

31
00:01:41,595 --> 00:01:44,510
There are some convoluted ways around that,

32
00:01:44,510 --> 00:01:48,000
but they're beyond the scope of what we're going to do in this course.

33
00:01:48,000 --> 00:01:50,240
We have our lifting operation as before,

34
00:01:50,240 --> 00:01:52,520
where we take a Haskell function F,

35
00:01:52,520 --> 00:01:55,845
and then take two Boolean values with i1 and i2 in them,

36
00:01:55,845 --> 00:01:58,100
extracting those out, feed those to

37
00:01:58,100 --> 00:02:01,760
F and then wrapping the result back into a new BoolVal.

38
00:02:01,760 --> 00:02:05,740
For Eval, we have two things we need to evaluate.

39
00:02:05,740 --> 00:02:10,190
We need to evaluate Boolean expressions and create Boolean values out of it and this

40
00:02:10,190 --> 00:02:15,200
is just like the integer expression being evaluated into an integer value before.

41
00:02:15,200 --> 00:02:17,740
Finally, we have a BoolOpExp.

42
00:02:17,740 --> 00:02:18,920
So, we have our operation.

43
00:02:18,920 --> 00:02:19,950
We have e1 and e2,

44
00:02:19,950 --> 00:02:23,020
and the first thing we want to do is evaluate e1 and

45
00:02:23,020 --> 00:02:26,415
e2 to get our corresponding v1 and v2.

46
00:02:26,415 --> 00:02:28,570
Then we're going to lookup the operation in

47
00:02:28,570 --> 00:02:32,410
our boolup's dictionary to get F. Then finally,

48
00:02:32,410 --> 00:02:37,295
we're going to lift F and feed it as v1 and v2 to get our final result.

49
00:02:37,295 --> 00:02:39,320
So, that looks very similar to

50
00:02:39,320 --> 00:02:43,730
the integer operation expression that we evaluated in the last time.

51
00:02:43,730 --> 00:02:49,850
There are six relational operations that we care about this time, here they are.

52
00:02:49,850 --> 00:02:51,405
Just like the last one,

53
00:02:51,405 --> 00:02:53,720
we have built this dictionary with them.

54
00:02:53,720 --> 00:02:55,790
We have a lifting function to take

55
00:02:55,790 --> 00:03:02,965
these operators and apply to integers to that and get a corresponding Boolean value.

56
00:03:02,965 --> 00:03:05,785
Then the eval, the code looks very similar.

57
00:03:05,785 --> 00:03:07,835
So, now that we've done that,

58
00:03:07,835 --> 00:03:10,485
it's time to add some variables to our language.

59
00:03:10,485 --> 00:03:15,675
The way we're going to do that is we're going to rely exclusively on let expressions.

60
00:03:15,675 --> 00:03:21,920
So, we have an example here where we have this let x equal two plus three and x times x,

61
00:03:21,920 --> 00:03:25,110
rather than doing it the Haskell label where we use indentation.

62
00:03:25,110 --> 00:03:27,710
The parses for that are a little bit trickier to write.

63
00:03:27,710 --> 00:03:30,350
So, we're going to have a keyword 'end' that tells us when

64
00:03:30,350 --> 00:03:33,745
the let expression or the body of the let expression has ended.

65
00:03:33,745 --> 00:03:35,300
So, here in this let expression,

66
00:03:35,300 --> 00:03:37,615
we are defining a variable x.

67
00:03:37,615 --> 00:03:40,365
We're setting it to the value two plus three.

68
00:03:40,365 --> 00:03:42,605
So, that needs to be evaluated till it's five,

69
00:03:42,605 --> 00:03:44,760
and then we're going to evaluate the body of the let,

70
00:03:44,760 --> 00:03:47,075
and it's x times x.

71
00:03:47,075 --> 00:03:49,905
Inside this body, x is going to have value five.

72
00:03:49,905 --> 00:03:52,590
So, that, of course, is going to turn into the value 25,

73
00:03:52,590 --> 00:03:55,585
which is then going to be added to the three to get 28.

74
00:03:55,585 --> 00:03:58,680
To update the expression type, we need two things.

75
00:03:58,680 --> 00:04:00,400
First, we need variables.

76
00:04:00,400 --> 00:04:03,650
So, we have a VarExp which takes

77
00:04:03,650 --> 00:04:05,330
a string parameter and we have

78
00:04:05,330 --> 00:04:08,740
a LetExp for the let expression which takes the three parameters.

79
00:04:08,740 --> 00:04:12,115
The string contains the name of the variable,

80
00:04:12,115 --> 00:04:18,785
the first exp is the initial value of that and the second exp is the body of the let.

81
00:04:18,785 --> 00:04:22,190
Now, we get to write Eval now that we have our typeset.

82
00:04:22,190 --> 00:04:24,815
So, to evaluate a VarExp,

83
00:04:24,815 --> 00:04:29,015
we finally get to use this E and V parameter that we've been parsing around a lot.

84
00:04:29,015 --> 00:04:32,300
We're going to lookup var in side of E and V. Now,

85
00:04:32,300 --> 00:04:36,395
remember E and V is just the list of ordered pairs.

86
00:04:36,395 --> 00:04:37,905
The first part of the pair is a string.

87
00:04:37,905 --> 00:04:39,380
The second part is the value.

88
00:04:39,380 --> 00:04:41,840
So, we're going to call lookup on that and it's just going to compare

89
00:04:41,840 --> 00:04:45,045
a var to everything until it finds what we're looking for.

90
00:04:45,045 --> 00:04:46,600
If it finds it,

91
00:04:46,600 --> 00:04:48,795
we have line three with just val,

92
00:04:48,795 --> 00:04:50,850
and we just return the val part.

93
00:04:50,850 --> 00:04:51,995
If we don't find it,

94
00:04:51,995 --> 00:04:54,925
we're going to simply return a zero instead,

95
00:04:54,925 --> 00:05:00,825
and more realistic language we would introduce error handling, but we'll do that later.

96
00:05:00,825 --> 00:05:02,990
Now, for the code for let,

97
00:05:02,990 --> 00:05:04,695
this is slightly more complicated.

98
00:05:04,695 --> 00:05:07,790
You want to make sure that you understand this because

99
00:05:07,790 --> 00:05:10,879
what is going to happen is we have to actually modify

100
00:05:10,879 --> 00:05:13,940
an environment because let creates a new variable and we have

101
00:05:13,940 --> 00:05:17,060
to have a way of recording that new variable and its mean value.

102
00:05:17,060 --> 00:05:19,560
So, the first thing we need to do is take that e1,

103
00:05:19,560 --> 00:05:23,150
which is the value of the variable and evaluate it in

104
00:05:23,150 --> 00:05:27,430
our current environment and we're going to save that into this variable v1.

105
00:05:27,430 --> 00:05:30,620
The next thing we want to do is create a new environment that

106
00:05:30,620 --> 00:05:35,010
has the variable VAR bound to the value v1.

107
00:05:35,010 --> 00:05:37,650
So, we're going to use the insert function to do that.

108
00:05:37,650 --> 00:05:42,350
Now, all insert does is take a key and a value,

109
00:05:42,350 --> 00:05:47,710
puts them into a tuple and adds that to the beginning of the list which is E and

110
00:05:47,710 --> 00:05:50,270
V. We can have other implementations where we use

111
00:05:50,270 --> 00:05:53,560
hash tables or something like that and the MPs.

112
00:05:53,560 --> 00:05:55,460
We will, in fact, do things like that.

113
00:05:55,460 --> 00:05:58,115
But for now, we're just using a linked list.

114
00:05:58,115 --> 00:06:02,970
So, anyway with added var being V1 into the environment in V,

115
00:06:02,970 --> 00:06:07,000
and that's creating a new environment that sharing the old one.

116
00:06:07,000 --> 00:06:11,940
Then we pass that into a recursive call to Eval V2.

117
00:06:11,940 --> 00:06:13,690
So, during that recursive call,

118
00:06:13,690 --> 00:06:17,210
our environment now has this new value added into it and it

119
00:06:17,210 --> 00:06:21,390
feels very much like pushing this value onto a stack.

120
00:06:21,390 --> 00:06:24,640
All we've done is really add something to the beginning of the linked list,

121
00:06:24,640 --> 00:06:29,815
but the function calls themselves Implement A Stack Frame.

122
00:06:29,815 --> 00:06:34,850
So, we are actually leveraging the fact that our language has

123
00:06:34,850 --> 00:06:40,475
this built-in stack for recursive calls and we're using that for our own data.

124
00:06:40,475 --> 00:06:44,035
The nice thing is, is when this call to the var returns,

125
00:06:44,035 --> 00:06:46,820
our variable E and V is unchanged.

126
00:06:46,820 --> 00:06:49,840
So, it feels like we pushed it onto the stack,

127
00:06:49,840 --> 00:06:51,710
made the call and when we returned,

128
00:06:51,710 --> 00:06:53,470
we popped it back off.

129
00:06:53,470 --> 00:06:54,985
Now, this is all implicit.

130
00:06:54,985 --> 00:06:59,360
This is a very common pattern and sometimes you'll hear functional programmers say that,

131
00:06:59,360 --> 00:07:04,355
"Oh yes, we pushed var onto E and V and then made this call. Didn't really?"

132
00:07:04,355 --> 00:07:05,880
But it has the same effect.

133
00:07:05,880 --> 00:07:09,710
So, it's sometimes easier to express it as if we are

134
00:07:09,710 --> 00:07:14,480
using stacks even though we are not exactly doing that.

135
00:07:14,480 --> 00:07:17,600
So, this should give you a few extra things in your interpreter to

136
00:07:17,600 --> 00:07:20,925
play with and the reference implementation isn't i4.

137
00:07:20,925 --> 00:07:25,150
I've added one other thing there and not implemented it just to give you something to do.

138
00:07:25,150 --> 00:07:28,370
There's an if expression there which you should be able to right now.

139
00:07:28,370 --> 00:07:29,975
So, see if you can do that.

140
00:07:29,975 --> 00:07:32,360
Then the next time what we're going to do is talk about

141
00:07:32,360 --> 00:07:34,610
functions and function calls because those

142
00:07:34,610 --> 00:07:40,340
are the most interesting data structure that we're going to talk about in this course.

143
00:07:40,340 --> 00:07:42,240
Well, there's a lot of interesting data structures,

144
00:07:42,240 --> 00:07:44,975
but this one is called a Closure and it

145
00:07:44,975 --> 00:07:49,470
really is one of the most interesting things we're going to discuss.