Hello again, welcome back. This video we're going to talk about closures which is a way of encoding functions for function calls. So, we'll talk really briefly about how to add conditions to your language, that's what we left off the last video with, and we'll talk about functions and function application, and we'll talk about this data structure called a closure and why it's necessary. So, remember what we did last time, we made an interpreter, we added all these good things to it, arithmetic variables, let, and the code for this can be found in the i5 directory, if you want to take a look. So, we also last time we added variable expressions, and let expressions. One of the things I've tried to emphasize is that the way let works is it creates a variable, that variable exists inside the body of the let. Once the let is done and returns, that variable disappears. We talked about this behaving very much like a stack. So, when you make the recursive call, the new environment is created that has this variable, it's like pushing it onto the stack. Then when the recursive call returns that variable disappears. It goes out of scope, but it has the same action, it's popping something off of a stack. So, looking at source code here, you see this let z equal 10 equals z plus 1. So, if we run that we get the number 11 back which is what you should expect. But then, if I try to evaluate z afterwards, it says it's not in scope. Because a let body is done and so z just disappears, and if we run our interpreter i5, we get the same result. We can create a variable z, we evaluate z plus 1 that gives us 11, but then when we try to evaluate z by itself afterwards, it's gone out of scope and disappeared. Now, about adding if. If you wanted to add if to your language, you need to add another constructor for your expression, so here it is IfExp with three parameters now. The first will be the condition, the second will be the then branch, the third will be the else branch, and then for eval, it's fairly straightforward. Evaluate the e1 part because that is the condition, and if it turns into a true thing, you evaluate e2 because that's the then branch. Otherwise, you evaluate the e3 part because that's the else branch, and we're taking the approach that anything that's not explicitly true is going to be considered false. There's other decisions you could've made with this, but this is one way. So, adding functions. So, let's start off with example function. We have lambda x arrow x plus one. While I say lambda it's a backslash but it's supposed to represent lambda which we'll talk about more when we do lambda calculus. What we have is parameter x, we have a function body x plus 10, and we have an argument 20. This should remind you of the let expressions that we created earlier. So, let's talk about how to implement it. Now, this is a wrong way, so don't memorize this code or anything. But if you were to do this without having really thought about languages before, this could be a first attempt. The problem with this first attempt, is it'll actually work for you a lot of the time. So, let's look at this. We have a new Exp type called Fun Expression, which has a string for the variable x that's the parameter, and another expression for the body in this case x plus 10. Then for the value part, we're going to have a function value which has again the string and the expression because when you have a fun expression, it just turns into a function value, and then that value gets applied later. Then we need a way to apply function so that will be an application expression or AppExp. We have two parameters one should be the function, one should be the parameter to the function or argument to the function. So, here would be the code, you would evaluate e1 to get the function value. You evaluate e2 to get the argument. We insert the argument into the environment, and then we evaluate the body. So, this looks just like what we would have done with the let expressions. The only problem is, it doesn't work. So, let's talk about what could possibly go wrong. The way I'm going to do that is I'm going to take that function call that we did earlier the x plus 10 applied to 20, let's expand it out a couple of times. First, let's give that function a name. Let's say that let's call it f, we'll use a let expression to do that. So now, we have f applied to 20, so that should gives us our 30. Then instead of hard-coding 10 into the function, let's create a variable named delta, and we'll put that in there. So, again, we call f to 20, then it adds 20 to delta which is 10 so that's give us a 30. Now here's the trick, when we run f 20, is delta still in scope? It's a trick question, because at the f 20 part, delta is no longer in scope. If you try to print out delta there, it's going to give you an error. However, the function somehow seems to remember what delta was. So, let's expand it out one more time. Let's now create a new variable named delta, set it to be 20, and then call f 20 with that. We still get back 30. So, somehow this function knows that delta is equal to 10 when the function was created, it ignores z delta that was equal to 20 when the function was called. So, this is the reason we need something called a closure. Whenever we create a function value, we need to know three things; we need to know the name of the variable, we need to know the body of the function, but we also need to know what values that variables held when this function was created. So, here's how we're going to do it. The expression types can stay the same, we'll have our function expression, we have our application expression, but for our value, we need a constructor called a closure. It's going to have a string for the parameter. It's going to have an expression for the body, and an environment for keeping track of what the variables were when they were defined or when the closure was defined. So, for eval, we have a function expression. It just returns a closure, and you can see it's stashing a copy of the environment there. Now, the application expression now becomes more complicated. First, we have to evaluate e1 and that had better turn into a closure. In the closure, we're going to call its environment clenv for closure environment. That's to keep it distinct from the environment that was passed into the current call of the eval. We need that current environment, because when we evaluate the argument here in e2, we want to evaluate that in the current environment. But then when we evaluate the body of the closure, we're going to insert that arguments value into the closures environment, not to the current one. So, let's do an example evaluation so you can see how this works. So, here I'm going to say let d equal 10 and lambda x arrow d plus x. That's going to create this call to eval. So, we have let x d, and you should probably pause this slide and make sure you see how the eval call here when I'm passing in their lines up with the expression above. So, go ahead and do that and convince yourself that that's the right thing. So, here we call that eval on the IntExp 10, because that's the first thing you do with let, and that's going to get us an IntVal 10. Then we're going to stash that into an environment and call the function expression, and that's going to give us back this closures. See, we have a closure. It's defined on X when the body is plus x d, and then the closure environment is d is an IntVal 10. Alright. So, now let's call this function. So, we're going to let f equal this closure here. So, this d equal 10 x plus d part that's just the same thing we did in the previous slide. But now we're going to evaluate that in the body of let y equal 20 in f y. So, again hit pause, look at all this code here and see how that lines up with what you saw above. So, let's assume that the let part, this part with a let f has been evaluated, and so f now has been put into the environment, it's equal to this closure, and you see that the closure has its own environment that says d is equal IntVal 10. Now we're going to evaluate the let expression that says y is equal to 20 inside of the body saying that we are applying f to y. So, here we evaluate the white part and stick that into the environment. Now we're evaluating the body of that let, so you have application expression, and we have f applied to y. So, we're going to look at the code again just to remind you what eval has to do with function calls. So, we're going to take the e1 part which is f and expand that out to this closure. We're going to take the e2 part and expand that out, that's going to be this IntVal y. We're going to insert that y value into the argument for the x, and then evaluate the body x plus d inside of the closure environment which says d is equal to 10, and then that insertion of x equal to 20 is going to occur inside that closure environment. So, when we do that, and folding this x and y values, you see on the bottom eval here, we have the body of the function, the body of that closures, it says plus x d. The x is going to be equal to IntVal 20 and now left the call to eval uncalled. So, just so let that expanded out so you can see that x is going to be assigned to the value of y, and when you evaluated while it was 20 so that will get simplified away. But I left that in there just to make it explicit where that comes from. D, of course, having IntVal 10 was the original part of the closure. So, that's basically it. I think you know how to take it from here to add x and d to get 30. Now closures have an interesting history. The first language to use them appears to be Peter Landin's SECD machine. Just a fairly old language in a very formal looking language. It looks like a state machine. It's not something used for real programming necessarily, it's more for understanding languages. The first language to really use closures a lot was Scheme which is a dialect of Lisp. One of the interesting things about programming languages is that so many of the things that we use commonly in programming languages first saw the light of day in Lisp. So, today they're very common. Even Java and C++ have introduced closures to them. I'm going to say recently which means these slides are going to be out of date in about 30 seconds, but yeah it's pretty recent. So, some other things to try, this is the last video in this series. But you could try adding C-style ifs, where zero is considered false. You could try expanding us some other function calls to get an idea how they work, and then sometimes you have functions that take multiple parameters. If you want to do that you're going to have to change a few things. You may have to introduce lists of strings where you had a single string to represent parameters before. It's not that hard of a change to make but it could be very informative if you want to try that. So, I hope you've enjoyed writing interpreters. Again, the code is an i5 if you want to take a look. But again, I encourage you try to do this all yourself and see how much of it you can get done. You pick up the examples if you get stuck, and hope you enjoy playing with your interpreter.