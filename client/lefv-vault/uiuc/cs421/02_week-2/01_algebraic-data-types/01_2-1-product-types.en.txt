Hello everyone and welcome back. In this couple of lectures, we're going to talk
about defining your own types in Haskell. It really makes it a much more useful language
when you can do that. There's two ways
to do this, well, there is called product types
and a called sum types. In this video, we're going
to talk about product types. Now these are both a class or something we call
algebraic data types, which is just a fancy way
of saying that we take other types and we combine
them together in various ways. So the product types, usually include things like
tuples or pairs, and records. So you think things
like coordinate pairs or Cartesian coordinates, or records like lines
from a database. These are all usually
considered product types. Sum types are a little
bit more complicated. We'll do that in the next video. So your objectives. You want to be able to explain
what a product type is, and you also want to be
able to use pairs and records with Haskell syntax to model a few different
data structures like dictionaries and database,
and complex numbers. So as I said earlier,
there are two kinds of product types
that we will use. The first one is called a tuple. So a tuple or an n-tuple, it's an order collection of
elements, the order counts. If n is equal to 2 it's
usually called a pair. So here's some syntax for you
to show you how it works. So in lines 1 and 2,
I defined variables x and y. X is an integer, 10, y is a string "Hi". I can look at the types with the :t. Now one thing you'll notice with the type of y is said
to be a list of characters. The default setting
for Haskell is that that's how strings
are represented. There are other string
representations that Haskell has that are more efficient in certain
circumstances, but that's beyond the
scope of our course so we're not going to
worry about those. But you might see that if you
look at other Haskell code. Anyway, the magic comes in line 7 when we actually define a pair. So we're going to set p to be equal to the pair of x and y. See the syntax, you just use
an open close parentheses, and you put all the elements you want in there
separated by commas. Now if I take the type of p, the type shows you
as being a pair, the first part's integer, the second part is a
list of characters. Now if you come from
other languages, it's a toss-up whether these things are built
into the language or not. Pretty much every
language has some kind of support for doing
something like this. C++, for instance, doesn't have pairs as
part of the basic syntax. But the standard template library define things that work for this. Some languages use vectors to
handle this sort of thing. Languages like Python
have pairs built in. So Haskell gives you a few
functions to work with pairs directly because
they're so common. The main two are
first and second, which take the first element
or the second element. Now these functions
only work with pairs. If you have a tuple with
three or five or whatever, these functions don't
work with that, you're going to have
to write your own. So here's just an example,
if I take first of p, I get the 10, if I
take second of p, I get the "hi" back. Now tuples are fun because you can put a pretty much anything
you want in them. So here I'm going to
define a variable p4. The first part's going
to be 10 of integer, the second is a string,
the third is a function. Remember we talked about
higher order functions, they're first class citizens, so we can just put one in there. Then the last element is
going to be another tuple. If we take the type of p4, we get a fairly
complicated type back. Now let's do an
example with these. Let's try to implement
complex numbers. Now you probably remember, and if you don't,
don't worry about it, it's not that important for our course, it's
just an example. We can pretend that take the square root of minus
1 and call that i, and any multiple of that is
called an imaginary number. So you have a plus bi, numbers of that form are
called complex numbers. If you think about what the properties of the square
root of minus 1 would be, you can quickly derive
that addition and multiplication would follow
these mathematical formula that you see up here. So in Haskell, if we want to use tuples to implement this, then we can say that the first element of the
pair is a real part, and the second element of the
pair is the imaginary part. So we have complex add
and complex multiply. We can use pattern matching in order to deconstruct
the pairs for us, which saves us a lot of typing. Then the output is just
going to be another tuple, where we combine the elements as in the mathematics above. Now this works pretty well and if you're writing
something small, and you're not going to be sharing that with
too many people, this is a pretty reasonable
way to go about it. But if you're going to make a
library of complex numbers, then this is probably
not a good idea. The reason for that is that, while we can certainly use tuples to represent
complex numbers, these functions they
take any tuple at all. Not every tuple can
be a complex number, but there's nothing to
distinguish that here. There are other ways
of communicating to the compiler what
our intentions are, so that the compiler
can give us more help. For that, we're going
to need the other kind of product type called a record. So here's how to define a record. You have a keyword called data, and then you have the
name of the type complex. Then we have the equal sign, then we have a constructor, which in this case happens to be the same name as the type. This is something you'll
see quite often in Haskell. After that, you're going to
have curly braces and then the names of all the fields
with their associated types. So here we have
complex as two fields, re for real, which
has type Float, and im, which also
has type Float. So now the fields have names, so it gives us a little
bit more flexibility. Now in line 2, you'll see
this thing deriving Show,Eq. We're not going to explain
that too much right now, except just to say that if you define your own
type like this, Haskell by default will
not print it out for you. If you try to print it, you have to define a
function called show, which tells it how to
convert these to strings. Now this deriving thing
tells Haskell basically, "Look, you know how
to print this out, just do it for me." Same with the Eq, we want
equality derived for this. In the lecture on
type classes we'll go into more detail on what this is doing and how you
can do it yourself if you don't want Haskell
to do it for you. So you've defined
the type and now we want to create elements of it. We have two choices. One, you can write
down the name of the constructor,
which is complex, and then write down the values at the field should have in the order that you declared them. So you write down the real part, and then you write down
the imaginary part. This is the first option you see. The second is you could be more explicit and specify
the field names. Again, you write
down the constructor and then you write
down the curly braces, and you say re equal
10.5, im equal 34.2. So both of these will
do the same thing. Now the cool thing
is you'll see in the next slide is field names
actually become functions, which can project
out the elements or select out the fields
of this particular record. Because these become functions, we have a serious limitation that field names have to
be unique in Haskell, at least within the same scope. Haskell has an advanced
feature that you can turn on, which allow you to relax that
restriction a little bit, but we're probably not going
to do that in this course. So here's some examples. I cannot call re on
c and get 10.54, im on c, get 34.2. This is like the dot
notation in other languages. You can have c.re or c.im to do the same thing
in other languages. This is how we do it in Haskell. Having the field access or
things be actual functions, gives us some flexibility. We can use these, you're
like an argument to map. Maybe we have a list
of complex numbers, so we map re over
that list and we're going to get all of
the real parts back. Anyway now, here are the
complex number functions. So I have chosen to write
it out in the long format. You probably should too, if you're writing library code that other people
are going to read. If you're feeling lazy and you're not going to
show it to too many people, you could use the
shorthand notation. I feel like this is a
little bit easier to read, until a little bit
clearer and near. Six months later when you come
back to look at your code, this is going to make more sense. Here's another example, we
can make database records. We're going to create a
data type called person, which has a first name and
last name, and an age. Again, we're going
to derive to show an equality and I can
make a list of people. Here I'm going to use
the short notation just because it's a lot
of typing otherwise. So we have person, we have ''Bilbo''
''Baggins'' who's 111, and ''Harry''
''Potter'' who's 19. He was 19 when I
wrote these slides. He's older than that now. So here's some things I'd
like you to try doing. Now that you've seen this syntax, play with these
examples a little bit, and then see if you
can do things here. There's a sync on an
associative list, which is very common in
functional programming languages. You have a list of
pairs, and in the pair, the first part is a key,
the second part is a value, think like hash tables. So we could have this example here where
we have a phone book, or the "emergency" is 911, and "Jenni", well, that's
her famous phone number. So try writing a
function called add. I'll take a key and a value, and one of these
associative list and return a new one
with that new key, and add and value added into it. If you want to extra challenge, you can try to make it so that the key is sorted in that list. Then write another
function called mylookup, which will take a key
in associative list, and return the
corresponding value. There is a built-in
function called lookup, which does this already. So you can play
with that if you're wondering what exactly
I'm asking you to do. Then if you want
some more practice, then try doing a record type
with a key and value field, and then try writing the
functions with those. I'll play with that
for a little bit. The solutions to this will be posted on the course website, but don't pick at that until you've
given this a good try. So the next video,
we're going to talk about the sum types.