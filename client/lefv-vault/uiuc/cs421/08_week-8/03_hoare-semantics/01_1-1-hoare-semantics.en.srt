1
00:00:00,000 --> 00:00:03,810
Hello. Welcome to CS 421.

2
00:00:03,810 --> 00:00:07,335
You've seen quite a few different semantic systems up to now and you'll notice how

3
00:00:07,335 --> 00:00:10,920
each have their own way of modeling what's happening with the program.

4
00:00:10,920 --> 00:00:14,880
In this semantics, we're going to focus on the effect of program has on the state,

5
00:00:14,880 --> 00:00:17,895
the goal of being able to tell that the program does the right thing.

6
00:00:17,895 --> 00:00:20,970
When this video is done, you'll be able to write down Hoare Triples

7
00:00:20,970 --> 00:00:23,985
and explain how they're different from small steps semantics.

8
00:00:23,985 --> 00:00:28,245
You'll also be able to use some to show the correctness of a single program.

9
00:00:28,245 --> 00:00:31,920
We'll also show you an important concept called The weakest precondition.

10
00:00:31,920 --> 00:00:34,620
Remember the simple imperative programming language?

11
00:00:34,620 --> 00:00:37,760
It's back. Let's make a simple change though.

12
00:00:37,760 --> 00:00:42,560
That we can leave off the else branch of an if statement if the branches skip.

13
00:00:42,560 --> 00:00:46,415
It'll also be useful to define these two functions overstatements,

14
00:00:46,415 --> 00:00:49,170
var of S is a set of variables that appear in S

15
00:00:49,170 --> 00:00:51,680
and change of S is a set of variable names

16
00:00:51,680 --> 00:00:54,800
that appear on the left-hand side of an assignment statement in S.

17
00:00:54,800 --> 00:00:57,050
To provide good contrast,

18
00:00:57,050 --> 00:01:00,175
I want to be sure you remember the small step semantics.

19
00:01:00,175 --> 00:01:03,740
We have a configuration which is a program together with its state,

20
00:01:03,740 --> 00:01:06,290
and we transition to another configuration depending on

21
00:01:06,290 --> 00:01:09,055
what the next step of the program should be.

22
00:01:09,055 --> 00:01:10,810
We're concerned with two things.

23
00:01:10,810 --> 00:01:16,685
Exact values of the variables in the states and the next step that occurs in the program.

24
00:01:16,685 --> 00:01:18,710
This is good for what it does, but sometimes,

25
00:01:18,710 --> 00:01:21,550
there's a lot to be gained by allowing for variation.

26
00:01:21,550 --> 00:01:23,480
Here, we introduce Hoare Triples.

27
00:01:23,480 --> 00:01:25,650
There are two assertions p and q

28
00:01:25,650 --> 00:01:28,370
placed in curly brackets around the program S.

29
00:01:28,370 --> 00:01:32,660
The Hoare Triple asserts that if p is true before the program S runs,

30
00:01:32,660 --> 00:01:34,415
q will be true afterwards.

31
00:01:34,415 --> 00:01:38,225
We call p the precondition, q the post-condition.

32
00:01:38,225 --> 00:01:41,420
p and q can be a list of variables and their values,

33
00:01:41,420 --> 00:01:44,585
but they can also be more general than that and frequently are.

34
00:01:44,585 --> 00:01:48,664
We also want to distinguish between partial correctness and total correctness.

35
00:01:48,664 --> 00:01:51,745
If we have partial correctness, we guarantee a correct answer,

36
00:01:51,745 --> 00:01:54,030
but only if the program terminates.

37
00:01:54,030 --> 00:01:56,330
We don't guarantee termination.

38
00:01:56,330 --> 00:01:59,180
Suppose you had a program that would go through the digits of pi

39
00:01:59,180 --> 00:02:01,430
and look for your social security number,

40
00:02:01,430 --> 00:02:04,430
you might be able to generate as many digits of pi as you want

41
00:02:04,430 --> 00:02:07,775
and be able to indicate if your Social Security number shows up.

42
00:02:07,775 --> 00:02:10,580
But at any stage that number hasn't been found,

43
00:02:10,580 --> 00:02:12,110
you cannot say that it's not there.

44
00:02:12,110 --> 00:02:13,985
You just have to keep looking.

45
00:02:13,985 --> 00:02:18,215
Total correctness, on the other hand, guarantees both correctness and termination.

46
00:02:18,215 --> 00:02:21,540
These Hoare Triple that we're writing here,

47
00:02:21,540 --> 00:02:24,890
we always assume partial correctness on these.

48
00:02:24,890 --> 00:02:27,610
Here are some examples to illustrate.

49
00:02:27,610 --> 00:02:29,250
The first example says that,

50
00:02:29,250 --> 00:02:33,140
if x equals 0 before we run our program, x will be 1 afterwards.

51
00:02:33,140 --> 00:02:35,090
The second example is less precise.

52
00:02:35,090 --> 00:02:37,375
It just says that x will be greater than 0.

53
00:02:37,375 --> 00:02:39,899
The third one says, true for the post-condition

54
00:02:39,899 --> 00:02:41,600
which means nothing at all about the program

55
00:02:41,600 --> 00:02:43,520
except that it has terminated.

56
00:02:43,520 --> 00:02:46,615
The fourth and fifth assertions are false.

57
00:02:46,615 --> 00:02:49,125
We have false as our post condition.

58
00:02:49,125 --> 00:02:50,650
Since false can never be true,

59
00:02:50,650 --> 00:02:53,585
but we are asserting is that the program never terminates.

60
00:02:53,585 --> 00:02:55,670
If we have false as our post-condition,

61
00:02:55,670 --> 00:02:57,260
since false can never be true,

62
00:02:57,260 --> 00:03:00,790
what we're asserting is at the program never terminates.

63
00:03:00,790 --> 00:03:04,340
Okay. So, let's define the axioms for Hoare Triples

64
00:03:04,340 --> 00:03:06,395
in the simple imperative programming language.

65
00:03:06,395 --> 00:03:07,655
First one is skip.

66
00:03:07,655 --> 00:03:11,510
If p is true before you skip, you will be true after you skip.

67
00:03:11,510 --> 00:03:14,230
The assignment axiom often surprises people.

68
00:03:14,230 --> 00:03:17,810
It says that, for p to be true after an assignment of t to u,

69
00:03:17,810 --> 00:03:22,145
then p will have to be true before with all the u's replaced with t's.

70
00:03:22,145 --> 00:03:23,690
The example should help.

71
00:03:23,690 --> 00:03:28,300
Suppose I want x to be greater than 10 after we assign y to x.

72
00:03:28,300 --> 00:03:33,140
The only way that happens is if I replace x by y for the precondition,

73
00:03:33,140 --> 00:03:35,990
y needs to be greater than 10.

74
00:03:35,990 --> 00:03:37,460
Composition is easy.

75
00:03:37,460 --> 00:03:40,770
If we have p run S1 to get r,

76
00:03:40,770 --> 00:03:43,515
and then take r run S2 to get q,

77
00:03:43,515 --> 00:03:47,940
then we can start with p run S1 and S2 and get q.

78
00:03:47,940 --> 00:03:50,330
The conditional rule is special.

79
00:03:50,330 --> 00:03:53,690
There are some insights that happened in the development of computer science

80
00:03:53,690 --> 00:03:57,140
that cause things to be possible that otherwise would not have been possible,

81
00:03:57,140 --> 00:03:59,330
and you're looking at one of them right now.

82
00:03:59,330 --> 00:04:02,150
Imagine you had 10 S statements in a row,

83
00:04:02,150 --> 00:04:05,210
and you wanted to understand the effect of program could have.

84
00:04:05,210 --> 00:04:07,700
There are 2 to the 10 paths through that program.

85
00:04:07,700 --> 00:04:11,315
A thousand and twenty-four different things that can happen.

86
00:04:11,315 --> 00:04:16,430
Edsger Dijkstra realized that we could instead think of an if

87
00:04:16,430 --> 00:04:19,505
as having a single precondition in a single post-condition.

88
00:04:19,505 --> 00:04:23,140
Both S1 and S2 should cause q to be true.

89
00:04:23,140 --> 00:04:27,995
If you have the time, I highly recommend reading this EWD 264.

90
00:04:27,995 --> 00:04:30,190
There will be a link on the course website.

91
00:04:30,190 --> 00:04:33,575
In that paper, Dijkstra spells out his idea.

92
00:04:33,575 --> 00:04:36,180
The Loop Rule is similar to if,

93
00:04:36,180 --> 00:04:40,110
but the precondition and post-condition both share a common term p,

94
00:04:40,110 --> 00:04:44,565
and the post-condition had said B is negated when the loop is done.

95
00:04:44,565 --> 00:04:47,605
We will have a separate lesson about loops.

96
00:04:47,605 --> 00:04:52,160
The rule of consequences isn't about a specific construct instead,

97
00:04:52,160 --> 00:04:54,005
it tells us what we can get away with.

98
00:04:54,005 --> 00:04:58,960
Suppose that we have specification p1 S q1,

99
00:04:58,960 --> 00:05:01,980
and then we find a p that implies q1,

100
00:05:01,980 --> 00:05:04,515
and q that is implied by q1,

101
00:05:04,515 --> 00:05:10,450
and we can also say that p S q. I like to think of this is how we advertise software.

102
00:05:10,450 --> 00:05:12,780
If our program needs 5 gigabytes to run,

103
00:05:12,780 --> 00:05:14,745
but we tell people it needs 10,

104
00:05:14,745 --> 00:05:16,755
we're not going to get into too much trouble.

105
00:05:16,755 --> 00:05:18,585
The program will still run.

106
00:05:18,585 --> 00:05:22,655
We are allowed to strengthen the precondition and still have a true statement.

107
00:05:22,655 --> 00:05:27,340
For the output, if our program can produce more than 10 results in an hour,

108
00:05:27,340 --> 00:05:30,545
but we advertise that it produces more than five results in hour,

109
00:05:30,545 --> 00:05:32,600
then we still won't have a false statement.

110
00:05:32,600 --> 00:05:36,740
We're allowed to weaken the post-condition and still have a true statement.

111
00:05:36,740 --> 00:05:40,490
Here's an example proved that uses assignment and sequence.

112
00:05:40,490 --> 00:05:44,300
To do a proof, you can either write out a proof tree-like structure,

113
00:05:44,300 --> 00:05:48,325
or you can interleave assertions with your program like you see on the right.

114
00:05:48,325 --> 00:05:50,900
Typically, you will start with your post-condition,

115
00:05:50,900 --> 00:05:53,240
x equal 20 and y equal 10 in this case,

116
00:05:53,240 --> 00:05:56,195
and go backwards, you derive your preconditions.

117
00:05:56,195 --> 00:05:58,685
So, we would look at the y equal t,

118
00:05:58,685 --> 00:06:01,600
and derive that t had to be equal to 10.

119
00:06:01,600 --> 00:06:03,600
Then we look at the x going to equal y,

120
00:06:03,600 --> 00:06:05,505
derive that y had to be 20.

121
00:06:05,505 --> 00:06:07,905
Finally, we would use t is going to equal x,

122
00:06:07,905 --> 00:06:10,290
to write that x has to be 10.

123
00:06:10,290 --> 00:06:15,220
So, we have as a proof that this program exchanges the values of x and y.

124
00:06:15,220 --> 00:06:17,940
If x starts with 10 and y starts at 20,

125
00:06:17,940 --> 00:06:22,110
we'll have our desired result that x will be 20 and y will be 10.

126
00:06:22,110 --> 00:06:25,430
For if proofs, we add some assertions to the branches

127
00:06:25,430 --> 00:06:29,220
to derive that if q is true after S1 or S2,

128
00:06:29,220 --> 00:06:32,175
then p and B or p and not B

129
00:06:32,175 --> 00:06:35,295
must be true before the branch executes.

130
00:06:35,295 --> 00:06:37,450
For proofs that use consequence,

131
00:06:37,450 --> 00:06:39,619
we can just write both assertions down,

132
00:06:39,619 --> 00:06:42,430
the stronger one followed by the weaker one.

133
00:06:42,430 --> 00:06:45,200
As an example, here's a program that asserts that m will be

134
00:06:45,200 --> 00:06:48,005
the maximum of x and y in all cases.

135
00:06:48,005 --> 00:06:50,635
That's what the pre-condition of true means.

136
00:06:50,635 --> 00:06:53,375
There is a handout with all the rules if you want.

137
00:06:53,375 --> 00:06:55,130
Look at that and see if you can work out,

138
00:06:55,130 --> 00:06:57,455
but the proof for this program might look like.

139
00:06:57,455 --> 00:06:59,480
And since you haven't seen many examples yet,

140
00:06:59,480 --> 00:07:02,965
feel free to just watch the derivation.

141
00:07:02,965 --> 00:07:07,520
We start off by putting our post-condition in desired precondition in their places.

142
00:07:07,520 --> 00:07:09,620
Next, we put the post-condition

143
00:07:09,620 --> 00:07:11,990
at the end of the branch of the second if statement

144
00:07:11,990 --> 00:07:15,400
in user rules to derive the preconditions for them.

145
00:07:15,400 --> 00:07:20,105
After that, we use the if rule to derive the precondition for the whole if statement.

146
00:07:20,105 --> 00:07:24,845
We are going to use p to represent all this because it's about to get messy.

147
00:07:24,845 --> 00:07:28,250
But notice what has to be true at this point of the program

148
00:07:28,250 --> 00:07:30,200
where we define the capital p.

149
00:07:30,200 --> 00:07:31,860
Between the two if statements.

150
00:07:31,860 --> 00:07:34,815
x should be less than y, and y is the max,

151
00:07:34,815 --> 00:07:39,150
or x is greater than y and m is already equal to the max.

152
00:07:39,150 --> 00:07:43,480
We do the same thing with the first if statement deriving the branches.

153
00:07:43,480 --> 00:07:46,660
To save space, I'm not actually going to write it all out.

154
00:07:46,660 --> 00:07:48,560
Next, we combine the branches

155
00:07:48,560 --> 00:07:52,280
to make the ultimate pre-condition of the two statements.

156
00:07:52,280 --> 00:07:56,030
Expanding everything out, we see that if x is less than y,

157
00:07:56,030 --> 00:07:58,355
or y is less than x, we're fine,

158
00:07:58,355 --> 00:08:01,250
but if they are equal, then this program is only going to work

159
00:08:01,250 --> 00:08:05,500
if m happens to be the max of x and y already.

160
00:08:05,500 --> 00:08:08,240
This is not a weaker precondition than true.

161
00:08:08,240 --> 00:08:11,120
So, this is a disproof of the program.

162
00:08:11,120 --> 00:08:13,310
I like this example because when I was an undergrad,

163
00:08:13,310 --> 00:08:15,470
I made the mistake of forgetting the case

164
00:08:15,470 --> 00:08:19,090
where two numbers could be equal during a comparison.

165
00:08:19,090 --> 00:08:22,360
In our next video, we'll talk about loops.