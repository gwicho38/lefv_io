Hello, everyone, and welcome back. In the last video, we introduced Hoare logic. Now, loops have some interesting considerations that we'll want to look at. When you're done with this video, you'll be able to explain the three conditions necessary for a loop to yield the correct answer, and the two conditions necessary for a loop to terminate. Perhaps, most importantly though, we're going to talk about loop invariants. Being able to pick a good loop invariant will help greatly in your future programming. Now, remember from our discussion about IF statements, how it's better to have a single precondition and a single postcondition that describe both paths through the IF statement. In a WHILE loop with the same kind of thing happens except that it repeats. So, the precondition and postcondition are much more closely related. Here's what a proof outline looks like for a loop. Q is our precondition in S_i is our initialization code. P is a special condition called the loop invariant. T is called the termination function, and it's like a counter for how many more times we'll have to go through the loop, but it's more subtle than that. B is the bound, and r is our final postcondition. We can extract out five equations from this, and these describe what a loop needs to do. The first three equations deal with partial correctness. Equation 1 says the initialization code must establish the loop invariant. Equation 2 says that, if the bound is true and the loop invariant is true when the loop body runs, then the loop body preserves the loop invariant. Equation 3 says that if the loop invariant is true but the bound is false, then the postcondition is achieved. The next two deal with termination. Equation 4 says that if the loop invariant is true, then our termination function t is greater than zero. In other words, it has a lower bound. Thinking of this as a base case for induction. Equation 5 says that if a loop invariant in a bound are true, then running the body of the loop decreases the termination function. We stipulate that t must be an integer. This means that the loop must eventually terminate. Here's an example. We want a loop that sums up all the elements of an array A. The loop invariant is that S must be the sum of all the elements in A up to index i minus 1. You can see that the initialization code establishes this trivially by setting S and i both to zero. The second equation says that if we get to run our loop, the loop invariant will be preserved. We add A of i did S and then increment i, and that will preserve the invariant. Finally, the third equation says that once the bound becomes false, we will have our desired postcondition, that S will be equal to the sum of all of these elements. For another example, consider the greatest common divisor of a and b, here, the loop invariant is simply that the GCD of the current values of a and b are the same as the GCD of the initial values of a and b. The modular arithmetic preserves this property. Once a equals 0, we have that b is a GCD, which is what the third equation says. How to pick a good loop invariant? To pick a loop invariant, you need to find a weaker version of the postcondition, and then use the bound to strengthen the loop invariant progressively until the invariant becomes or implies the postcondition. There are three ways this can be done. A first is to replace a constant with a range such as when we're looping over an array. We'll replace the size of the array with the loop index. The second is to add a disjunct declare that something else might also be true, and the loops job is to make that thing untrue. The third is to remove a conjunct and have the loop restore that conjunct. Let's see some examples. Here's a loop invariant that says that S is the product of all the elements of an array. We can create an index n, and say that we have a product of all the elements up to n minus 1. Once n is equal to the size of the array, we'll have our postcondition. Example 2 is the GCD. We want a to be 0 and b to be the GCD. We can add a disjunct here that if a is not 0, then the current value of a and b have the same GCD as the originals. For example 3, we want to say that f of x and Delta are both bounded by Epsilon. Maybe a loop invariant would be to remove the Delta part. Now, we want to consider the termination properties. It is similar to recursion where each recursive call is on a smaller value. The idea of smaller can be several different things. Integers typically get closer to zero, lists get closer to the end, and Hydras that use lexicographical ordering on the number of heads. Not all sequences terminate just because the input gets closer to the base case. Consider the sequence when we divide a float by 2 each time. We know that this does not converge even though it gets closer to zero every time. For this reason, we insist that determination function have to be an integer, and that gets rid of most of those problems. The total correctness formulas just say that our termination function t is some value greater than zero, it has a lower bound, and the second formula says that the value decreases. We also insist that i be an integer as we said to guarantee that decreasing eventually leads to a base case. For example 1, we can take our initial t to be the size of a minus i. In this case, it's easy to pick an exact value for t. i gets incremented each time bringing it closer to the size of a. For example 2, we don't have an easy formula, but we can see clearly that taking the mod a of b is going to shrink a each time. So, we can just use t equal a, assuming that we start off with a being the larger of the two. Well, that's it for the five equations. This is a lot to cover. So, be sure to look on the website for other materials.