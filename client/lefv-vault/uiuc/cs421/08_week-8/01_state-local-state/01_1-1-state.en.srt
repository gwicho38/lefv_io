1
00:00:00,000 --> 00:00:03,120
Hello everyone, welcome to CS 421.

2
00:00:03,120 --> 00:00:06,255
We've been avoiding talking about this for the whole course.

3
00:00:06,255 --> 00:00:08,130
We've either been doing without it altogether,

4
00:00:08,130 --> 00:00:12,495
assimilating with monads, but it's timely address state directly.

5
00:00:12,495 --> 00:00:15,810
Haskell is a little unusual in that it forbid state,

6
00:00:15,810 --> 00:00:17,520
but most languages allow it.

7
00:00:17,520 --> 00:00:21,990
So we need to be able to discuss what effect state has on our languages.

8
00:00:21,990 --> 00:00:24,120
When this video is done,

9
00:00:24,120 --> 00:00:27,285
you'll be able to describe the property of referential transparency,

10
00:00:27,285 --> 00:00:30,825
and explain the complication that state brings to programs,

11
00:00:30,825 --> 00:00:34,020
and when you use a similar language called OCaml,

12
00:00:34,020 --> 00:00:36,630
and use references to model state.

13
00:00:36,630 --> 00:00:42,260
Here's a rule of referential transparency given in a small step semantics format.

14
00:00:42,260 --> 00:00:46,885
It says here that if e_1 evaluates to v and e_2 also evaluates to v,

15
00:00:46,885 --> 00:00:52,655
then we can replace e_1 with e_2 and some other context and get the same final result.

16
00:00:52,655 --> 00:00:56,230
Here I've used to f applied to e_1 to represent that.

17
00:00:56,230 --> 00:01:00,325
This rule does not hold for all systems but when it does,

18
00:01:00,325 --> 00:01:05,335
you can use what we call the equational reasoning to think about our programs.

19
00:01:05,335 --> 00:01:08,180
One of the benefits of equational reasoning is that you

20
00:01:08,180 --> 00:01:10,460
can use mathematics to modify your program,

21
00:01:10,460 --> 00:01:13,135
and it possibly could make it more efficient.

22
00:01:13,135 --> 00:01:17,850
For example, this equation says that if f is applied to an if expression,

23
00:01:17,850 --> 00:01:22,035
we can move f inside the branches of the f expression.

24
00:01:22,035 --> 00:01:25,785
So, in this case here with x multiplied by this if,

25
00:01:25,785 --> 00:01:28,850
moving the multiplication inside the branches makes the code more

26
00:01:28,850 --> 00:01:32,030
efficient since we no longer have to deal with the division.

27
00:01:32,030 --> 00:01:35,920
Of course we're assuming that x is in zero here but never mind that.

28
00:01:35,920 --> 00:01:38,160
You can drive a lot of complication,

29
00:01:38,160 --> 00:01:41,480
you can drive a lot of optimizations this way if you can be sure

30
00:01:41,480 --> 00:01:45,275
that moving expressions around will not change the meaning of your program.

31
00:01:45,275 --> 00:01:48,685
But there is a complication when state is introduced.

32
00:01:48,685 --> 00:01:50,400
Since Haskell doesn't have state,

33
00:01:50,400 --> 00:01:54,770
we're going to use a similar language called OCaml for this lecture and the next few.

34
00:01:54,770 --> 00:01:56,960
To the hash symbol you see is a prompt for

35
00:01:56,960 --> 00:02:00,635
the ripple and statements are terminated with two semicolons.

36
00:02:00,635 --> 00:02:05,615
Anyway in OCaml, it's possible to create a function like this one.

37
00:02:05,615 --> 00:02:07,040
Every time you call counter,

38
00:02:07,040 --> 00:02:10,400
it returns a number one more than the one you gave it before.

39
00:02:10,400 --> 00:02:13,630
So the question is does equational reasoning still work?

40
00:02:13,630 --> 00:02:15,525
Well, I like puns,

41
00:02:15,525 --> 00:02:18,510
so let's just call this the counter example.

42
00:02:18,510 --> 00:02:23,220
Before we can say that f of x plus f of x is equal to two times the f of x,

43
00:02:23,220 --> 00:02:24,735
but it clearly does not work,

44
00:02:24,735 --> 00:02:27,060
if f of x is called the counter.

45
00:02:27,060 --> 00:02:30,929
So let's break down the semantics of state in OCaml.

46
00:02:30,929 --> 00:02:34,505
First, we start off with the Transition Semantics.

47
00:02:34,505 --> 00:02:37,930
We have four operations to introduce The first is rough,

48
00:02:37,930 --> 00:02:41,870
it takes a value for an argument and creates a state $i,

49
00:02:41,870 --> 00:02:46,340
initialized to the value v. We don't get the address itself but

50
00:02:46,340 --> 00:02:51,175
we get a representation of it that we can compare for equality with other states.

51
00:02:51,175 --> 00:02:53,340
To access the contents of a state,

52
00:02:53,340 --> 00:02:54,850
we use exclamation point,

53
00:02:54,850 --> 00:02:58,435
it's kind of like the pointer in direction operator in C++.

54
00:02:58,435 --> 00:03:01,550
We also have assignment operator colon equal,

55
00:03:01,550 --> 00:03:04,220
it updates a state and returns a value called unit,

56
00:03:04,220 --> 00:03:07,240
which we represent with open and closed parentheses.

57
00:03:07,240 --> 00:03:09,345
Finally, we have semicolon,

58
00:03:09,345 --> 00:03:12,560
which allows us to separate operations and return the value

59
00:03:12,560 --> 00:03:16,025
of the last operation as a value of the whole chain.

60
00:03:16,025 --> 00:03:17,630
Here are the Natural Semantics,

61
00:03:17,630 --> 00:03:20,735
are big steps semantic rules for the same operations.

62
00:03:20,735 --> 00:03:24,360
I'm just going to let you look at them and read them to you.

63
00:03:26,710 --> 00:03:31,715
Okay. So, let's look how we can use state to write counter function.

64
00:03:31,715 --> 00:03:34,015
Here's the first way we're going to try.

65
00:03:34,015 --> 00:03:39,365
We'll create a global variable called CT and initialize it as a reference to zero.

66
00:03:39,365 --> 00:03:44,555
Next, we're going to define a function counter and increment CT and returns it.

67
00:03:44,555 --> 00:03:48,805
We can test it out and see that counter does what we wanted it to do.

68
00:03:48,805 --> 00:03:51,995
There are a few bad things about this though.

69
00:03:51,995 --> 00:03:54,785
First, CT is globally defined.

70
00:03:54,785 --> 00:03:57,750
If someone else had already defined a variable named CT,

71
00:03:57,750 --> 00:03:59,195
there could be a collision.

72
00:03:59,195 --> 00:04:01,880
But this problem is solved easily enough by using modules

73
00:04:01,880 --> 00:04:04,630
or some other namespacing mechanism.

74
00:04:04,630 --> 00:04:07,640
The other problem is if a user gets a hold of this variable,

75
00:04:07,640 --> 00:04:10,460
they could change it themselves which might break the functionality of

76
00:04:10,460 --> 00:04:15,325
the counter especially if we changed a representation of it in the future.

77
00:04:15,325 --> 00:04:19,655
We haven't even mentioned what happens if you decide you want more than one counter.

78
00:04:19,655 --> 00:04:24,035
So, we could conclude that state is bad because it breaks equational reasoning

79
00:04:24,035 --> 00:04:28,755
and it does make programs significantly more difficult to reason about.

80
00:04:28,755 --> 00:04:30,950
In fact many people do conclude that,

81
00:04:30,950 --> 00:04:33,155
and that's why we have languages like Haskell.

82
00:04:33,155 --> 00:04:35,390
But there are algorithms and constructs that

83
00:04:35,390 --> 00:04:37,819
really do need state to be handled efficiently.

84
00:04:37,819 --> 00:04:41,340
Many graph algorithms for example,

85
00:04:41,340 --> 00:04:42,810
and since our world is stateful,

86
00:04:42,810 --> 00:04:45,700
sometimes state is the most natural way to model things.

87
00:04:45,700 --> 00:04:47,315
In the next video,

88
00:04:47,315 --> 00:04:49,670
we will present another way of writing counter that makes

89
00:04:49,670 --> 00:04:52,950
use of local variables to hide the state.