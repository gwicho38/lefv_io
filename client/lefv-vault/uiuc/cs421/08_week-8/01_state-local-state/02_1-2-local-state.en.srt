1
00:00:00,000 --> 00:00:02,040
Hello, and welcome back.

2
00:00:02,040 --> 00:00:04,590
In the last video, we used the global variable

3
00:00:04,590 --> 00:00:07,005
to keep track of the current value of a counter,

4
00:00:07,005 --> 00:00:09,480
but this time we're going to use a much more sophisticated way

5
00:00:09,480 --> 00:00:11,790
of dealing with the state variable.

6
00:00:11,790 --> 00:00:13,680
When you're done with this video,

7
00:00:13,680 --> 00:00:16,380
you'll be able to use lead and function declarations to

8
00:00:16,380 --> 00:00:20,130
control precisely when a variable is created and initialized.

9
00:00:20,130 --> 00:00:25,350
You'll also be able to completely encapsulate a stateful variable within a function.

10
00:00:25,350 --> 00:00:27,300
Now, to use this technique,

11
00:00:27,300 --> 00:00:30,710
it's very important that you understand what a variable gets created.

12
00:00:30,710 --> 00:00:32,585
So, take a look at this code.

13
00:00:32,585 --> 00:00:36,565
Here, we define a function foo with one parameter x.

14
00:00:36,565 --> 00:00:41,870
Inside of foo, we define a variable a and set it equal to 10 plus 20,

15
00:00:41,870 --> 00:00:46,450
and then finally, the body of the let returns the value a plus x.

16
00:00:46,450 --> 00:00:52,070
If we call foo twice and assume that the compiler does not optimize this away for us,

17
00:00:52,070 --> 00:00:55,440
how many times will the 10 plus 20 be computed?

18
00:00:55,850 --> 00:00:58,410
The answer is twice.

19
00:00:58,410 --> 00:01:00,390
Each time the function is run,

20
00:01:00,390 --> 00:01:01,965
the lead is evaluated.

21
00:01:01,965 --> 00:01:04,600
This creates a brand new variable a,

22
00:01:04,600 --> 00:01:07,730
which is then discarded when the function returns.

23
00:01:07,730 --> 00:01:10,990
Now consider this example where a is a global variable.

24
00:01:10,990 --> 00:01:13,280
It's declared outside the scope of foo,

25
00:01:13,280 --> 00:01:15,875
so it doesn't matter how many times foo gets called.

26
00:01:15,875 --> 00:01:18,625
The a is only made one time.

27
00:01:18,625 --> 00:01:21,350
Now, let's modify the first example.

28
00:01:21,350 --> 00:01:26,120
Notice that I declare a variable called foo and then declare a variable called a,

29
00:01:26,120 --> 00:01:30,770
and the body of the lab returns a function that is inbound to foo.

30
00:01:30,770 --> 00:01:34,495
You will recognize this as a closure I hope.

31
00:01:34,495 --> 00:01:36,775
I call foo twice,

32
00:01:36,775 --> 00:01:39,350
the a is still only computed once for

33
00:01:39,350 --> 00:01:42,740
the same reason that the global version of a is only computed once.

34
00:01:42,740 --> 00:01:47,840
The a is created outside of the scope of the function nagging

35
00:01:47,840 --> 00:01:49,880
no internally the data structure that makes it

36
00:01:49,880 --> 00:01:53,995
possible for foo's function to access a is called a closure.

37
00:01:53,995 --> 00:01:56,910
Now, we're going to use this with state.

38
00:01:56,910 --> 00:02:00,965
We define a variable counter and then use a let

39
00:02:00,965 --> 00:02:05,485
to declare a variable CT initialized as a reference to zero.

40
00:02:05,485 --> 00:02:10,430
The let then returns a function that increments CT and returns its value.

41
00:02:10,430 --> 00:02:13,190
We now have a version of counter that works as before

42
00:02:13,190 --> 00:02:16,225
except CT only exists inside the function,

43
00:02:16,225 --> 00:02:18,270
where outside of the let now, so,

44
00:02:18,270 --> 00:02:21,335
CT is out of scope for the rest of the program.

45
00:02:21,335 --> 00:02:24,395
This leads to the following horrible Pun.

46
00:02:24,395 --> 00:02:29,630
Remember that the higher order function twice is really the church numeral for two.

47
00:02:29,630 --> 00:02:32,030
We can apply twice to counter a few times

48
00:02:32,030 --> 00:02:34,430
and see that it always creates different results,

49
00:02:34,430 --> 00:02:36,960
you know what this means, right?

50
00:02:36,970 --> 00:02:41,300
This is why you should never mix church and state.

51
00:02:41,300 --> 00:02:45,050
Here's a semi practical application of this technique.

52
00:02:45,050 --> 00:02:46,940
By swapping out what we do at the state,

53
00:02:46,940 --> 00:02:50,950
we can use to local state as a seed for a pseudorandom number generator.

54
00:02:50,950 --> 00:02:54,400
In this function, we allow the user to parse in the initial via the state,

55
00:02:54,400 --> 00:02:59,065
so, it acts like the seed in their random number generator.

56
00:02:59,065 --> 00:03:01,840
By swapping out what we do at the state,

57
00:03:01,840 --> 00:03:06,125
we can use a local state as a seed for a pseudorandom number generator,

58
00:03:06,125 --> 00:03:10,325
and this function we allow the user to parse in the initial value of the state.

59
00:03:10,325 --> 00:03:14,015
So, this acts like the random number generator seed.

60
00:03:14,015 --> 00:03:17,130
Another interesting trick is this one.

61
00:03:17,130 --> 00:03:21,365
We can create a tuple of functions instead of just creating one.

62
00:03:21,365 --> 00:03:25,880
Here, both functions have access to the local state CT. Now,

63
00:03:25,880 --> 00:03:30,065
we have a function counter and another function that can reset the counter.

64
00:03:30,065 --> 00:03:33,470
Perhaps this idea of a local state accessible only

65
00:03:33,470 --> 00:03:36,775
to a few related functions will remind you of something,

66
00:03:36,775 --> 00:03:39,910
we'll talk about that in our next video.