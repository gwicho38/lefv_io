Hello everyone, welcome back. Now, the idea of subtyping is implicit in many languages. For example, many languages allow you to supply an integer to something that expects a float. Now, it turns out that objects subclasses behave almost like subtypes, but there is a subtle difference. When you're done with this video, you'll know the difference between a subclass or subtype, and be able to give examples of types to have what's called a covariant and contravariant relationship with each other. Now, to start let's test this question, how can we tell if one type is a subtype of another? Are integers subtypes of floats or is it the other way around? What about characters and strings? If a type A can be considered kind of type B, then a is A subtype of B. Another way to say this is if you can supply an A where a B was expected and not lose data, then A is a subtype of B. So, by this recognizing, an integer is a subtype of float. I can cast an integer into a floating-point number without losing anything. But if I take a float and turn it into an integer, I have to say what to do with the decimal part, we're going to lose some of the data. When types take parameters, the situation becomes more complex. There are two main possibilities. If the relationship of the container follows the relationship of the containee, then the relationship is said to be covariant. Lists are a good example of this. A list of ints is a subtype of list of floats, since ints are subtypes of floats. Therefore, we see that list subtypes are covariant in their argument. Functions however, are a lot more complicated. Suppose we're expecting a function that outputs a float but I give you a function that outputs an int, this is fine, the context in which the function is being used can treat any received int as if they were floats. Therefore we say function subtyping is covariant with respect to its output. The input is a different story. Suppose I have a function that expects an int for an input but the context passes in a float instead, that float is going to get truncated. On the other hand, if we have a function that expects a float input but it's given an int input, everything should be fine. So, function subtyping behaves oppositely to its input. This input style is called contravariant. Contravariant tends to consume things whereas covariance tend to produce or store them. Here's a diagram of the different function type relationships for ints and floats. Notice that interior int and float era float are not comparable at all by this scheme. If you end up exploring Haskell's packages, you'll find a few other examples of contravariant types. One of these is a gated dot pro functor package, which is like functor but allows you to find two kinds of mapping, one that is covariant and contravariant. We are going to use some of these course though. Now, with objects, we can set up an admittedly rare situation like this one. Class A has a method foo that is type A to A and bar calls it. Suppose we make a subclass B and overwrite foo to B of type B to B but we do not overwrite bar. If we Call class B's bar it will invoke Class B's foo, but it was written to expect an A to A, and a B to B is not a subtype of an A to A. So, a subclass is act like subtypes. There's also this subtle difference with the covariant and contravariant relationships. No objects had been wildly successful especially since C++ came about in the early 90's. Most functional programming languages avoid them, since many of the problems that object solved can also be solved using functions, especially higher-order functions. Most programmers will tend to prefer one style to the other. Now, many languages support both Models, OCaml for instance as objects and that's where the O in OCaml comes from. Inheritance can also be tricky especially if you allow multiple inheritance, which you really shouldn't if you're designing your own language.