1
00:00:00,000 --> 00:00:03,305
Hello everyone, welcome to CS 421.

2
00:00:03,305 --> 00:00:07,630
The last time we talked about encapsulating state inside of functions.

3
00:00:07,630 --> 00:00:10,030
So, this time what we're going to do is make use of

4
00:00:10,030 --> 00:00:13,190
that to implement their own objects system.

5
00:00:13,190 --> 00:00:16,030
When you're done with this video you'll be able to relate

6
00:00:16,030 --> 00:00:19,060
the concept of objects to functions with state,

7
00:00:19,060 --> 00:00:21,610
and you'll also implement two objects systems

8
00:00:21,610 --> 00:00:25,045
when using records and when using message dispatch.

9
00:00:25,045 --> 00:00:28,375
It'll be very helpful to have a running example for this.

10
00:00:28,375 --> 00:00:30,115
So, we'll start with this one.

11
00:00:30,115 --> 00:00:32,410
Again, this is OCaml syntax but you

12
00:00:32,410 --> 00:00:35,274
should be able to read it since you already know Haskell.

13
00:00:35,274 --> 00:00:39,810
I've created two functions pi1 and pi2 known as projection functions.

14
00:00:39,810 --> 00:00:42,580
We're going to treat pairs as cartesian coordinates.

15
00:00:42,580 --> 00:00:46,570
We also have a function report that takes a pair and prints it out.

16
00:00:46,570 --> 00:00:50,535
Finally, there's a function movept which takes a point and a Delta,

17
00:00:50,535 --> 00:00:52,755
and adds Delta to the point.

18
00:00:52,755 --> 00:00:57,505
Now, let's make a point class using the local state technique from last time.

19
00:00:57,505 --> 00:01:00,830
We have an object constructor mktPoint that takes

20
00:01:00,830 --> 00:01:05,470
an initial value for the location and uses that to create a local state myloc.

21
00:01:05,470 --> 00:01:08,480
Then, we return a five tuple with the reference in

22
00:01:08,480 --> 00:01:11,210
the four functions the same for from the last slide,

23
00:01:11,210 --> 00:01:15,410
except we capture the result of movept and update myloc with it.

24
00:01:15,410 --> 00:01:19,310
Now, the problem with this method is whenever we want a point object we

25
00:01:19,310 --> 00:01:23,410
must assign it to the five tuple of names capturing the state and the functions.

26
00:01:23,410 --> 00:01:27,200
We wanted a dozen of these it would get cumbersome very quickly.

27
00:01:27,200 --> 00:01:30,200
One way we can improve on this is to use records.

28
00:01:30,200 --> 00:01:32,750
Like in Haskell, OCaml will let you define

29
00:01:32,750 --> 00:01:35,300
the names and types of the fields and now every time you

30
00:01:35,300 --> 00:01:41,065
create a point you get a record object back that's easy to access, like this one.

31
00:01:41,065 --> 00:01:46,875
Difference with OCaml and Haskell is that OCaml's lead are not recursive by default,

32
00:01:46,875 --> 00:01:49,405
but then there's this letRec keyword.

33
00:01:49,405 --> 00:01:53,420
We can define a variable this to capture the value of the entire record.

34
00:01:53,420 --> 00:01:55,880
Then, we can use the this variable inside of

35
00:01:55,880 --> 00:02:00,035
our method definitions just like you could in a language like C++ or Java.

36
00:02:00,035 --> 00:02:01,805
For the two example we have here,

37
00:02:01,805 --> 00:02:04,190
it's probably not worth the effort but if we

38
00:02:04,190 --> 00:02:06,695
need it to be able to pass the whole object to something else,

39
00:02:06,695 --> 00:02:08,885
this would make it much simpler.

40
00:02:08,885 --> 00:02:12,620
So, the idea of extending a record with functions

41
00:02:12,620 --> 00:02:15,740
and fields and encapsulated state is a common one,

42
00:02:15,740 --> 00:02:18,400
you'll see it in languages like C++.

43
00:02:18,400 --> 00:02:21,740
But the original idea of objects used a different model,

44
00:02:21,740 --> 00:02:26,540
that is of sending messages to objects and the objects that act on those messages.

45
00:02:26,540 --> 00:02:29,200
This is similar to languages like Smalltalk.

46
00:02:29,200 --> 00:02:32,480
So, let's create an object that uses message dispatch.

47
00:02:32,480 --> 00:02:35,870
We'll use strings to represent messages and the function that

48
00:02:35,870 --> 00:02:39,730
receives the string will return the matching function to us.

49
00:02:39,730 --> 00:02:41,880
Now, here's mkPoint again,

50
00:02:41,880 --> 00:02:44,185
this time using a message dispatcher.

51
00:02:44,185 --> 00:02:47,750
We create references for x and y separately this time,

52
00:02:47,750 --> 00:02:51,160
and then return a function that accepts a string st.

53
00:02:51,160 --> 00:02:53,580
It matches st to one of getx,

54
00:02:53,580 --> 00:02:55,350
gety, movx, or movy.

55
00:02:55,350 --> 00:02:58,900
If the string is not one of those it emits an error message.

56
00:02:58,900 --> 00:03:03,814
Not a dynamically typed language like Python or scheme this technique is very powerful,

57
00:03:03,814 --> 00:03:07,480
though unnecessary in Python since objects already built in.

58
00:03:07,480 --> 00:03:09,384
In OCaml and in Haskell,

59
00:03:09,384 --> 00:03:11,180
if Haskell allowed state,

60
00:03:11,180 --> 00:03:14,390
this technique suffers from one very painful limitation,

61
00:03:14,390 --> 00:03:17,485
all the methods must have the same type.

62
00:03:17,485 --> 00:03:21,650
But even given that limitation the message passing technique opens

63
00:03:21,650 --> 00:03:26,120
up another feature of objects, namely subclassing.

64
00:03:26,120 --> 00:03:29,000
So, to warm up, you might want to think about how you

65
00:03:29,000 --> 00:03:31,750
would add a report method to this object.

66
00:03:31,750 --> 00:03:33,510
It's fairly easy, right?

67
00:03:33,510 --> 00:03:37,805
You just match on the string report in return an appropriate function.

68
00:03:37,805 --> 00:03:42,085
You'll have to take a dummy argument and return a dummy value but it would work.

69
00:03:42,085 --> 00:03:44,295
Now, suppose we wanted a subclass,

70
00:03:44,295 --> 00:03:47,340
fastpoint that moves twice as fast as point.

71
00:03:47,340 --> 00:03:51,245
A fastpoint should respond to all the same messages that a point would respond to,

72
00:03:51,245 --> 00:03:52,685
overwriting some of it wants,

73
00:03:52,685 --> 00:03:54,100
adding some if it wants.

74
00:03:54,100 --> 00:03:59,355
To do that with message-passing fastpoint needs to access points data.

75
00:03:59,355 --> 00:04:01,215
Here's how it works.

76
00:04:01,215 --> 00:04:02,565
We have two entities,

77
00:04:02,565 --> 00:04:06,100
a superclass point, and a subclass fastpoint.

78
00:04:06,100 --> 00:04:08,780
When we create a fastpoint the first thing it will do

79
00:04:08,780 --> 00:04:11,360
is create an instance of its superclass point.

80
00:04:11,360 --> 00:04:15,139
Then fastpoint will return a message dispatcher to handle the messages,

81
00:04:15,139 --> 00:04:17,975
and if it gets a message it doesn't want to handle,

82
00:04:17,975 --> 00:04:20,250
it sends it to point.

83
00:04:21,020 --> 00:04:23,550
Here's the code for point.

84
00:04:23,550 --> 00:04:26,720
We call this function mkSuperPoint because it's only meant to

85
00:04:26,720 --> 00:04:30,070
be used to create superclass points, not normal ones.

86
00:04:30,070 --> 00:04:33,080
It's same as the original but it also returns a tuple of

87
00:04:33,080 --> 00:04:37,535
references so that fast point will have direct access to the local state.

88
00:04:37,535 --> 00:04:39,925
Now, here's the code for fastpoint.

89
00:04:39,925 --> 00:04:44,945
It first calls the superclass constructor in much the same way as you would do in Java,

90
00:04:44,945 --> 00:04:48,710
or C++, or Python, then message dispatcher handles movx,

91
00:04:48,710 --> 00:04:55,480
movy, but the getx and gety messages it passes to the superclass,

92
00:04:55,480 --> 00:04:57,905
so now we have actual inheritance.

93
00:04:57,905 --> 00:05:00,710
This is not very efficient if we have long chains of

94
00:05:00,710 --> 00:05:03,730
inheritance though but it's very flexible.

95
00:05:03,730 --> 00:05:05,980
To make this fast in real life,

96
00:05:05,980 --> 00:05:10,540
the language C++ creates a table for every class type called the V table.

97
00:05:10,540 --> 00:05:13,744
It has what amounts to a lookup table for its methods.

98
00:05:13,744 --> 00:05:17,960
Each entry of the V table points to an appropriate version of the objects methods,

99
00:05:17,960 --> 00:05:22,040
and each object will have a pointer to the corresponding V table.

100
00:05:22,040 --> 00:05:24,215
This does not work by default though,

101
00:05:24,215 --> 00:05:27,020
to use this in C++ you need to tell the compiler that

102
00:05:27,020 --> 00:05:30,075
you want to use virtual methods, the virtual keyword.

103
00:05:30,075 --> 00:05:32,360
Otherwise, the compiler will look at the type of

104
00:05:32,360 --> 00:05:34,940
the variable in hardcode that class's method at

105
00:05:34,940 --> 00:05:40,270
compile time which will cause it to ignore the actual type of the variable contains.

106
00:05:40,270 --> 00:05:43,550
So, in summary, we can use message passing to

107
00:05:43,550 --> 00:05:46,850
simulate objects and a few languages use this.

108
00:05:46,850 --> 00:05:49,640
Doing this in a strongly typed language is difficult

109
00:05:49,640 --> 00:05:52,675
and this language provides extra support for objects.

110
00:05:52,675 --> 00:05:56,600
One important idea about object is set of polymorphism.

111
00:05:56,600 --> 00:05:59,450
You've seen it before with parametric polymorphism for things

112
00:05:59,450 --> 00:06:02,435
like lists and with type classes in Haskell,

113
00:06:02,435 --> 00:06:07,075
objects and inheritance gives you another way of implementing polymorphism.

114
00:06:07,075 --> 00:06:09,920
We could spend a whole semester just on objects but

115
00:06:09,920 --> 00:06:12,925
we're going to stop here except for one more lesson,

116
00:06:12,925 --> 00:06:18,900
and that is, what is the relationship between the objects subclasses and subtypes?