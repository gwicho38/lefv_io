20:16:10 All right, welcome to the MP 5 crash course. So today the main goal is to take you. For those of you who are kind of in a state where you're looking at the MP or parts of the MP and you're like, I have no idea what's going on.
20:16:27 To a place where You're more like, okay, I kind of have a sense of what's going on here.
20:16:34 I feel like a sense of what's going on here. I feel like I can start asking some questions now.
20:16:38 I feel like I can start asking some questions now that will help me make some forward progress on the MP.
20:16:41 So to accomplish that, I'll quickly go through the data types that we're dealing with for MP 5.
20:16:50 Walk through some of the monad operations that might be good to know or remember. Walk through some of the monad operations that might be good to know or remember, the functions that we give you.
20:17:15 And then So to get started, so we're dealing with the about state here where we have some evaluation result of type A.
20:17:20 Our environment of type E and V. And then a diagnostic that we're going to. Throw whenever we have to throw an error.
20:17:31 And then so with the environment type that we're dealing with here, again, we're using a hash map with the string and the value and then.
20:17:41 With our, we have a few different files here going on. So pay attention to the constructors here going on. So pay attention to the constructors here.
20:17:51 It will make it easier to pattern match and do the restors here. It will make it easier to pattern match and do the rest when we're doing some of these of vowels in the avowal part of the Mp.
20:17:59 And then, I'm not gonna go through diagnostic here just for time's sake, but you can take a peek at some of the different diagnostics that we have in what you'll need to do for those.
20:18:11 And then so as a reminder for the main part of our program, so our about signatures we have an a valve that takes a valve to an aval state fell and then a vowel list that takes the list of valves and gets us in about state valves.
20:18:30 So all about the So there were to accomplish that. So. Return is going to be a very nice word for us to remember.
20:18:42 So as a reminder, it takes some sort of grand value A and then lifts it into the monad of some MNA.
20:18:52 So this is going to end up being our aval state. So it's Probably going to be good when we're returning a kind of where I was touching on here.
20:19:02 For example, if we have a val and we're needing to return a valve state valve that will be a good time to use return.
20:19:12 And then as a reminder that F map exists. So this takes some sort of ground level A to B function with a function.
20:19:22 So that's our monad of A and then puts the result in a functor. So. If we're doing something with a valve that's in our mon ad and then if we need to put it back in a And then our application function here.
20:19:33 So this takes an Applicative with an A to B function in it. In aplicative so this is our Mona with the A in here and then puts it the result in an applications.
20:19:47 So if we're doing something. To a val that's also in the moon ad. That will be a good time to use.
20:19:56 Our application here. And then so lift M 2. So we'll see this in one of the functions that we give you but this basically takes a function A to B to C.
20:20:12 And then, Monad with an A in it, a Mona at B, and then we get back, Monet of C.
20:20:20 Hey then, map M. So this is our, monatic form of map and it will be useful for us if we have some sort of List of A that we need to do something.
20:20:36 And then we have our A to NB. So doing something manatic here. So we can take our list of bows in this case and then do some sort of transformation and then we get them back in a moment at here.
20:20:52 And then for this example, we're just dealing with LIST here, but it could be any observable but.
20:20:58 That's for another time. So moving on to some of the valve state functions specifically. So we have get.
20:21:06 So get gets or retrieves the environment from out of the For example, if we wanna get the current environment, we can just.
20:21:17 Set current to, whatever our get result is. And then gets kind of partner to this is put.
20:21:28 So it puts or replaces the environmental state in the monad. So for example, with that current that we got using get.
20:21:38 If we do some other stuff here, but we want to restore the environment to what it was before we did all the things we can put Ker and and ever places the whatever the environment looked like for with what we wanted it to be.
20:21:52 And then following along, we also have modify. So modify, modifies the environment with some sort of EMB 2 and V functions.
20:22:04 So, our Hashmap insert might be one of the nice things that We can use with modify here.
20:22:13 So for example, if we just wanted to. Insert this X with the number 3. We can do that with modify.
20:22:25 And then as a quick refresher, so some of the hash map functions that might be useful for you to remember here on insert lookup empty from list and union all exist so.
20:22:39 Familiarize yourselves with those again. And then so moving on to the other NP functions that we give you.
20:22:49 So we have plan list here that, gets us either an actual list of vows to work off of so more convenient for us to actually work with or let's us know that it was in that's with flat and lists and then so get binding so we have some sort of val and then we get in a bow state with a
20:23:13 string. And the valve tuple in there. So this is useful for let because, since we're doing with.
20:23:21 Be dealing with a pair in this case, but our environment is. That hash map of the stream.
20:23:31 Gets that string bell out of it for us. And then so get list of 2. So this has a valve and then we go then we get out in about stage with a valve tuple.
20:23:47 So this is useful in The special form con since we know each class is expected to be exactly a 2 element list.
20:23:57 So that condition and then. The thing to evaluate and react off of based off the that condition And then finally we have get list, which takes a valve and then we get back in a bow state with a list of those.
20:24:12 So this is useful for evaluating a value of representing the list into an actual list. And then so a quick reminder that these things exist.
20:24:24 So depending on how you like to implement your MPs, We have zip here, which takes a list of A and Alyssa B and then we get back.
20:24:33 List of tuples AB our normal ground level map which takes that A to B function with a list of A and we give back a list of B.
20:24:45 We can construct. Lists with their X excess we can pair match specifically on stuff that we're looking at within our list.
20:24:55 Let's are great here so we could. Let and then set whatever ground values that we want and the rest of the thing.
20:25:03 So those all should hopefully cover. The functions that you wanna be aware of or functions are already in the MP.
20:25:12 So with that we can go ahead and Circle back to some of the monads stuff with some do notation.
20:25:21 So this example comes from the book example of do notation. So I'm pretty sure if you Google a Haskell do notation.
20:25:30 This is one of the first results that pops up, but I'll go over it. A bit more detailed line.
20:25:36 By line. And then also if you're wanting to look at, the I/O monad for hassle, you can Also, use this URL.
20:25:50 To look at some of the other things that you could do with I/O Monet if you're curious.
20:25:54 So we have here just kind of a Basic function, by. Gets our first name and last name.
20:26:04 Puts them together and then Tells whoever's using it that is pleased to meet you so What's happening here is similar to our put with our environment, we can put a string into our aisle moment and then if we're wanting to get something out of the I/O Mona.
20:26:26 So being able to interact with the user that's similar to the get when we're getting the environment.
20:26:30 And then we can set it to whatever we want. We can put more things. We can get more things and then we can use our let's.
20:26:41 Here. In order to set some of the ground levels. So for instance, this.
20:26:49 Fal string here. To whatever the values that we've gotten from before input. Put it back to our user here.
20:27:00 So to what kind of through that. We'll go ahead and I'll break this up here and then.
20:27:08 Make sure everything's all loaded. And then so we can go ahead and run name. Do here.
20:27:16 So what's your first name? So that's that. Put straight. Put, so it takes the string and then we get back in I/O with the unit.
20:27:26 So that's the parentheses there. And then so now we're. Doing the get line so I could put clear here and then we put So and your last name and then.
20:27:39 We can get the line.
20:27:43 Last so we're setting last to that get line there and then we let full equal the first name, space last name, and then we finally.
20:27:53 Put the stir with that, which gets the new line and then please meet you. Full name.
20:28:02 Which we get right here. So. Yeah, so that's a basic example, but you can kind of see how the components all work together on how you could also start chaining things along when you're doing your MPs using some.
20:28:18 Of when we're dealing with things at the monatic level and then also if we're needing to get some stuff set up.
20:28:28 With those ground level. Values there. So hopefully that's a nice quick refresher and you were able.
20:28:37 To make a couple extra connections just hearing me walk through some of the things. But I'll go ahead and leave with a couple of the tips.
20:28:45 That I had. So it's pretty important here. It's always important, but particularly important here to look at the function signatures.
20:28:58 So, This is going to be useful in figuring out. What you need to do to get to the next So if you're supposed to be returning something.
20:29:10 And you have something that's not quite what you need return looking for either in the functions that we give you or some of the mode add functions to see how you can transform the thing.
20:29:23 And then so. Along similar lines is that so check-in and make sure you know what's Monadic and what's a ground value and then how you can get things to either level if you're needing to work with one thing or another and then so he can also, debug kind
20:29:47 of using those diagnostic messages. So when you throw the diagnostic, you can put. A string and that kind of helps you let you know where you're at so put whatever useful strength there is.
20:30:00 And then I think that's about it. So I'm Cooling to Leave things here for now, but if there's anything else that you want to see anything more specific that you want me to walk through or more monad stuff or all that. Let me know.
