Hello, welcome to CS 421. Now that you've seen some basic type classes, we're going to introduce three more type classes that have a profound effect on how Haskell programs are written. These classes are called Functor, Applicative, and Monad. We're going to introduce functor and applicative and leave monad for a little bit later. When you're done with this video, you'll be able to use the functor and applicative type classes to generalize the map higher-order function, and you'll build and implement them for your own datatypes. So by now you will have use the map function to apply a function to elements of a list in your own programming, and it's super convenient that lists have this function. But take a look at these example types. We have a tree type that implements rose trees, and a maybe type that's the same as the one that comes with Haskell. So, wouldn't it be convenient if we could use map on these as well. After all, these are types are just containers like lists and it makes sense that we might want to map an operation over them. So, this is where functor and applicative come in. The Functor Typeclass gives us a function fmap, which takes a function from a to b and a container f containing a's and returns a container containing b's. It's just like regular map, but now we've generalized it by making the container itself a parameter. I hope you are absorbing this technique of making things set parameters that once were fixed. You saw this first in the lecture about higher-order functions when we parameterize the operation we wanted to perform on a list. But now we've parameterized the list too. You've also seen this with continuation passing style, when we used a parameter instead of the built-in function return mechanism. So, here are the instances of functor from maybe enlist types. These are loaded by default when you start Haskell so, you don't actually need to type them in yourself. So, let's see how we can use this. Remember the inclus function from the higher-order functions lecture. Let's write a new version called incAnything, which uses fmap instead of map. We can pass it a list and it works like regular map. We can pass it a maybe works on that as well. So, in fact, anything for which we provided a functor instance will work on this function now. Now, let's move this up one level. Here's a definition of applicative. The first function is called pure, and serves to take a value and put it into a container. Second operation is this less than star greater than operation. It takes two containers, one with a function from a to b and one with an a. The output is a container with a b. This is called a lifted function application. Some people call this operator app as a result. Contrast this with fmap. Fmap, the function we are applying is on ground level. It's a bear function. But for app, the function starts off in the container instead. So, let's look at an example. Let's declare a type Foo that contains an a. To declare fmap, we just apply the given function to the contents of a given Foo. For the applicative, pure just puts its value into a Foo, and the app function takes a Foo with a function and a Foo with an argument and yields a new Foo with the result of the application. You might want to pause here and look at these definitions or type them in yourself to become more familiar with them, resuming you're ready to see how we can make use of this. Here's a sample run, we can define a function inc that increments its argument index. We can use fmap to increment an integer contained within the Foo. Here's an alias for fmap you'll see a lot, this dollar sign in angle brackets. It's supposed to remind you of the regular dollar sign, which represents function application. So, I'm just going to call it the fmap operator. So next, let's put inc into a Foo, in that situation we can use the app operator to apply Foo inc to Foo 20 to get Foo 21. But you may be wondering, why would we put an inc into a Foo in the first place? To answer that, let's define another function plus, which just adds two arguments together. How can we use this with Foo? Well, we could use the fmap operator. If we apply plus to Foo 20, using the fmap operator, what do we get back is a Foo with a function in it. This is how a function gets into a Foo, and why we need an applicative operator? Here's the rest of the example, we can use fmap to apply plus to Foo 20, which results in Foo of plus 20. The app operator then takes that and applies it to Foo 30 to get Foo 50. If you'd written plus 20 30 you would get 50 out. But by introducing these operations, you can apply plus to any container and get the same functionality. We refer to this as lifting plus. Here's a few details, we need to mention. There are some mathematical laws that applicatives should follow, otherwise things just will not make sense. These laws just say that the normal properties of functions such as identities and composition, work with the applicatives the same way they work normally. It would actually require some effort on your part to make it not follow these laws. You should know however that Haskell does not enforce them at all. Or giving credit the sources, I should say that many of these examples were stolen from the Haskell Wikibooks page.