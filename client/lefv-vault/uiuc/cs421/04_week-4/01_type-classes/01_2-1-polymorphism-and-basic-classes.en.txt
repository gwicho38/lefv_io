Hello everyone, and welcome to CS 421. In a programming language, we often want to apply an operation to more than one kind of thing. So, for example, in most programming languages, the plus operator works on both integers and floating point numbers without us needing to distinguish it in any way. When a function or operation is allowed to work on more than one type, it is said to be polymorphic. So, when you're done with this video, you'll be able to describe polymorphism. There is several ways of accomplishing it. You'll also be able to describe Haskell's type classes and use them to define some polymorphic functions. So, like I said, it's very common to want to use the same thing such as a function, or an operator, or a container, over many different types, and different languages had developed different ways to handle this. For example, in C ++, we have function overloading, which is called Adhoc polymorphism. Many languages support a form of objects and inheritance, which allows similar types to be grouped together. Languages like Haskell and OCaml that have the Henley Milner type system, support parameterize types such as lists. Languages like C ++ in Java support templatized classes or the generics. The Haskell supports a construct called a type class which we're going to talk about in great detail. Now, here's an example of overloading and C ++. You see here, we have two function thing Inc, and we would like the function to work on both integers and doubles. So, we declare the function twice with different parameters. This was a huge, huge, improvement over the C programming language. In C, you'd have to give the functions different names so that the compiler could distinguish them. Here, we can give them the same name. In C, you would have a function inc integer and another function inc double, and as you can imagine, this gets tedious quickly. If you have a lot of types, do you want to operate on, and the way C++ handles this is a process called mangling. The compiler uses the types of the parameters as part of the function's name internally, which allows it to tell them apart. This is similar to what we would have had to do and C, but it's all handled by the compiler for us. Here's an example in Java of inheritance. We have a class shape and another class square that inherits from shape. So, we can have it a collection of objects that inherit from shape and loop over them, knowing they all support certain fields or operations. Now, I'm going to assume you've worked with this before. So, I'm not going to go into much detail now, though, in the future, we're going to have a more detailed lecture about objects. Compare a metric polymorphism, allows your types to have a perimeter of some kind, and it's often used for type sediment to be containers, though that's not the only use for them. So, Java calls them generics, C++ calls them templates. In Haskell, they're referred to as parameterized types. So, let's look at type classes. Type class is just a collection of types that support a set of functions. So, here's the Eq type class for types that support equality. This declaration says that type A, is a member of the Eq type class if it supports equal and not equal. The second line of the declaration gives the types of the functions we want to support, and then the last two lines give default definitions. Later on, when you declare a type to be a member of this class, you have the option of giving your own definition of these functions or keeping the default definitions. Notice that the double equal and not equal are defined recursively in terms of each other. This allows you to define one of the two and then the other one you get automatically. Now, the reason we have an Eq type class is, Haskell does not define equality for user-defined types automatically. For one thing not all types can be compared, for example, functions. For another thing, we may have a different idea about when we want to consider two pieces of data to be equal. So, for an example, you might have a node type that contains data and a common field. Maybe you don't want the comment field to be considered when you compare for equality. In this example, I've created a type Foo, and made two variables, X and Y, both assigned to Foo 10. If we try to compare them, we get this error message. It's an indication we did not make Foo to be a member of the Eq type class. So, let's look how to do that. The instance keyword is how we declare a type to be a member of a type class. Here, I've told Haskell that Foo is a member of Eq and given the definition for equality, and I'll get the default definition of not equal from the class declaration. So, now, equal works for X and Y. So, too long, didn't code, there are many type classes in Haskell and many of them are super basic, and if you're thinking that the compiler should be able to just make Foo and EQ instance for us, you would be right. So, the Haskell implementers just got the same thing. So, they put in a keyword deriving that we can use to tell the compiler to make Foo, and instance of the type class for us. So, let's take a look at some of the other basic type classes now. So, we have 0rd, which is not just the code for Chicago's O'Hare Airport. The 0rd type class indicates that a type has an ordering. A minimal definition is the compare function though you could define the operators instead. One thing that's a bit unusual but is type is that it makes use of another one called ordering and it has three members LT, GT and EQ. Then you might want to pause this video and review the functions to see how it makes use of it all, and just resuming you're ready to see the next type class. Now, if you want to convert a type into a string, we have the show type class. It has just one function show. Usually, we just use a deriving clause to have the compiler show for us, but sometimes it's preferable to for us to write our own definition. Similarly, we have the read type class. Is the opposite of show. It converts a string into a member of the given type. Now, you'll note that if you want to use read, you have to tell Haskell the type that you expect to get back. It won't infer it automatically. It has to know from the context what you're expecting. So, this is one of the consequences of type classes. Type inferencing is not decidable. So, like show, we can derive read to have function created for us. So, those are some of the basic type classes. You've also seen numb for numeric types and you seen integral for types of support modulus. There are many other type classes that come with Haskell, and in the next video, we're going to go over the functor and applicative type classes which allow for a much more advanced operations on user-defined types.