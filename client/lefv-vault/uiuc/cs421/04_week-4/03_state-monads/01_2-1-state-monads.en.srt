1
00:00:00,390 --> 00:00:01,924
Hello everyone, welcome to CS 421.

2
00:00:01,924 --> 00:00:05,562
When Monads were first applied
to programming languages,

3
00:00:05,562 --> 00:00:09,890
they weren't made simply to do
interesting things with lists.

4
00:00:09,890 --> 00:00:13,793
The things that got everything excited was
that they could be used to model stateful

5
00:00:13,793 --> 00:00:16,035
computations in a purely
functional setting.

6
00:00:17,811 --> 00:00:21,667
When you're done with this video, you'll
be able to describe the newtype keyword

7
00:00:21,667 --> 00:00:24,770
and the record type we use for
representing state.

8
00:00:24,770 --> 00:00:27,890
You'll be able to implement the pure
operation for the state monad.

9
00:00:27,890 --> 00:00:30,685
And you'll be able to implement the bind
operation for the state monad and

10
00:00:30,685 --> 00:00:31,688
trace an execution of it.

11
00:00:32,931 --> 00:00:35,916
This video has two parts and
next part we'll also define get and

12
00:00:35,916 --> 00:00:39,644
put that will allow you to directly
manipulate the stateful part of the monad.

13
00:00:41,195 --> 00:00:44,051
The first thing we need to do is
decide how to represent the state for

14
00:00:44,051 --> 00:00:44,715
computation.

15
00:00:44,715 --> 00:00:48,413
Now, stateful computation
starts with an input state and

16
00:00:48,413 --> 00:00:52,890
return some kind of result,
possibly modifying that state.

17
00:00:52,890 --> 00:00:57,610
So we can represent that as a function
of type a arrow as comma a.

18
00:00:57,610 --> 00:01:00,837
Where a is the state type,
when s is the result type.

19
00:01:02,073 --> 00:01:05,510
So as an example,
check out this ex1 function.

20
00:01:05,510 --> 00:01:10,019
It takes a state, s, and returns
a computation two times s as a result, and

21
00:01:10,019 --> 00:01:12,395
increments the state s in the process.

22
00:01:13,983 --> 00:01:17,905
Now to represent states more explicitly so
that they're type checker can keep us from

23
00:01:17,905 --> 00:01:20,252
mixing things up,
we'll use this record syntax.

24
00:01:20,252 --> 00:01:24,603
Here, we're creating a type
called State with two parameters,

25
00:01:24,603 --> 00:01:29,050
we have s as the output type and
a as the state type as before.

26
00:01:29,050 --> 00:01:32,860
The order is important,
we'll explain why in a few minutes.

27
00:01:32,860 --> 00:01:35,510
The constructor's called state as well,
and inside it,

28
00:01:35,510 --> 00:01:38,470
we have the record with one field,
runState.

29
00:01:38,470 --> 00:01:42,280
The newtype keyword in Haskell causes
the types to be synonyms of each other

30
00:01:42,280 --> 00:01:43,180
internally.

31
00:01:43,180 --> 00:01:43,875
The result is,

32
00:01:43,875 --> 00:01:47,572
we don't have to use pattern matching to
extract the record part of a state value.

33
00:01:47,572 --> 00:01:50,705
Now here's an example to make this clear.

34
00:01:50,705 --> 00:01:56,908
The long form way to declare a state
value might be here, where I define ex2a.

35
00:01:56,908 --> 00:01:59,350
It's just like ex1 from
the previous slide, but

36
00:01:59,350 --> 00:02:03,890
notice I have created the record and
set the runState field explicitly.

37
00:02:03,890 --> 00:02:08,690
But you can also declare a state value
like ex2b just by passing the function in,

38
00:02:08,690 --> 00:02:09,870
this will save us some typing.

39
00:02:10,890 --> 00:02:13,675
The runState field name accesses
the function part of the record.

40
00:02:13,675 --> 00:02:17,558
It's a little bit weird to name it this
way, most people would have thought to

41
00:02:17,558 --> 00:02:20,627
call it function or the computation or
something like that.

42
00:02:20,627 --> 00:02:23,001
But in Haskell,
label names are also functions,

43
00:02:23,001 --> 00:02:26,741
so it looks more natural when we use it
to extract the function out of the state.

44
00:02:26,741 --> 00:02:30,600
You should probably try typing all this
in to be sure you understand how it

45
00:02:30,600 --> 00:02:32,634
works before going to the next slide.

46
00:02:34,847 --> 00:02:37,133
Now to write a monad,
there must be functor and

47
00:02:37,133 --> 00:02:39,031
applicative class already defined.

48
00:02:39,031 --> 00:02:43,645
For functors, we want to pretend that
the state contains a value that we want to

49
00:02:43,645 --> 00:02:49,000
fmap a function across all those values,
returning new states in the process.

50
00:02:49,000 --> 00:02:52,011
So here's that ex2 function
with increment in a sample run.

51
00:02:54,117 --> 00:02:57,020
Now we can define our functor type class.

52
00:02:57,020 --> 00:03:00,569
And remember how I said earlier that
the state type parameters had to be in

53
00:03:00,569 --> 00:03:04,366
a certain order, the state type has to
come first, and then the result type.

54
00:03:06,146 --> 00:03:10,931
Now, we have two things that we want to
call State, the constructor, or type,

55
00:03:10,931 --> 00:03:16,350
spelled S-T-A-T-E, and also
the representation of the State in type s.

56
00:03:16,350 --> 00:03:19,640
Now to avoid confusion,
when I refer to the variable,

57
00:03:19,640 --> 00:03:23,360
I'll try to call it State s,
using State as an adjective.

58
00:03:23,360 --> 00:03:26,667
And when I want to refer to
the entire encapsulated function,

59
00:03:26,667 --> 00:03:28,523
I'll say state using it as a noun.

60
00:03:28,523 --> 00:03:33,760
But when I want to talk about constructor,
I'll call it the state constructor.

61
00:03:33,760 --> 00:03:39,050
Right, so back to why the state type has
to come first in the type definition.

62
00:03:39,050 --> 00:03:41,758
The reason is that functors
need a container type.

63
00:03:43,367 --> 00:03:46,632
If we have a state s a,
then we can say that

64
00:03:46,632 --> 00:03:52,250
the State is a container that
has values of type a within it.

65
00:03:52,250 --> 00:03:56,175
If we had to put the result type first,
then the function type class would want to

66
00:03:56,175 --> 00:03:59,828
map over state values, not result values,
and that's not what we want.

67
00:03:59,828 --> 00:04:03,680
So our task now is to write fmap.

68
00:04:03,680 --> 00:04:08,890
Here, f is the function from a arrow b and
g is a State s a.

69
00:04:08,890 --> 00:04:12,120
What we want is to output a State s b.

70
00:04:12,120 --> 00:04:16,418
It's much easier to do this kind of thing
if you think explicitly about the types.

71
00:04:16,418 --> 00:04:20,170
Notice that fmap needs to return a state,
so we go ahead and

72
00:04:20,170 --> 00:04:21,659
write down the state constructor.

73
00:04:22,730 --> 00:04:26,900
That constructor needs to have a function
in it that takes an initial State value

74
00:04:26,900 --> 00:04:28,160
and returns a pair.

75
00:04:28,160 --> 00:04:30,190
So let's take in an initial State s1.

76
00:04:31,450 --> 00:04:37,340
Variable g contains a State, so we call
runState on it and the State value s1.

77
00:04:37,340 --> 00:04:40,240
This gives us a result x,
and a new State value, s2.

78
00:04:41,280 --> 00:04:47,570
Finally, we apply f to the result x, and
return the correct tuple, and that's it.

79
00:04:47,570 --> 00:04:51,086
Again, you should try typing all this in
to be sure you understand how the states

80
00:04:51,086 --> 00:04:52,571
and results flow in the program.

81
00:04:55,200 --> 00:05:00,290
Now similar reasoning gives us a
definition of the applicative type class.

82
00:05:00,290 --> 00:05:05,010
We need to define pure which takes
an element and wraps it into a state.

83
00:05:05,010 --> 00:05:08,360
This may seem weird because
what we get is something that

84
00:05:08,360 --> 00:05:12,330
takes in a state variable and then returns
a result without even consulting it.

85
00:05:12,330 --> 00:05:15,170
But when we say that something is pure,
that is exactly what we mean in

86
00:05:15,170 --> 00:05:18,049
this context,
that is not contaminated by the state.

87
00:05:19,430 --> 00:05:22,603
Where the star operation,
we have two States f1 and x1.

88
00:05:22,603 --> 00:05:25,668
We know that f1 contains
a function of some kind and

89
00:05:25,668 --> 00:05:29,020
that x1 contains a value
to get to that function.

90
00:05:29,020 --> 00:05:30,752
But both of them
are contained within a State.

91
00:05:33,128 --> 00:05:34,470
But further we have to turn
our own State as a result.

92
00:05:35,600 --> 00:05:39,126
So following the types,
we emit a State constructor and

93
00:05:39,126 --> 00:05:41,307
take an initial State variable s.

94
00:05:43,789 --> 00:05:47,919
To get the function out of f1,
we runState f1 s and

95
00:05:47,919 --> 00:05:53,491
this gives us f in a new State s2,
which we then use to runState x1 and

96
00:05:53,491 --> 00:05:56,585
get our value x in the final State s3.

97
00:05:56,585 --> 00:06:00,954
We can then return f of
x in s3 as a result.

98
00:06:02,271 --> 00:06:04,510
That's all there is to applicative.

99
00:06:04,510 --> 00:06:07,284
Again, before you continue, you should
pause the video, and be sure you

100
00:06:07,284 --> 00:06:10,261
understand this definition, and
resume when you're ready to see the monad.

101
00:06:12,002 --> 00:06:13,437
Now we can show you the monad.

102
00:06:14,880 --> 00:06:17,811
The return definition is the same
as pure from applicative,

103
00:06:17,811 --> 00:06:20,050
this is the usual situation.

104
00:06:20,050 --> 00:06:21,480
But now we want to discuss bind.

105
00:06:21,480 --> 00:06:23,880
The first parameter is simply a State,

106
00:06:23,880 --> 00:06:28,170
the second parameter is a function
that takes the content of a State and

107
00:06:28,170 --> 00:06:32,041
returns a new State possibly with
a different type of context.

108
00:06:32,041 --> 00:06:36,112
That's why the type of f is
listed as a arrow State s b.

109
00:06:36,112 --> 00:06:39,310
Finally, the output should
be of type State s b.

110
00:06:39,310 --> 00:06:44,235
Now, since we're returning a state,
you can write down the state constructor

111
00:06:44,235 --> 00:06:47,480
in a lambda to accept
the incoming state variable s.

112
00:06:48,550 --> 00:06:53,650
Now what we have to do is extract
the contents of x, so let's call that y.

113
00:06:53,650 --> 00:06:56,470
Once we have y, we can feed that to f.

114
00:06:56,470 --> 00:06:59,587
Now think for a second though,
what will be the type of f applied to y?

115
00:07:02,527 --> 00:07:04,497
I hope you thought, it will be a State.

116
00:07:04,497 --> 00:07:09,344
But now, we have more work to do because
we're already returning a State and

117
00:07:09,344 --> 00:07:12,312
we have this results State
from f applied to y.

118
00:07:13,592 --> 00:07:17,976
So we take the state variable
result from s2 from the previous

119
00:07:17,976 --> 00:07:21,360
runState where we extracted x from y or
y from x.

120
00:07:22,440 --> 00:07:29,470
We use that to runState f y which yields a
new result z and a new state variable s3.

121
00:07:29,470 --> 00:07:33,242
Now, we can simply return that tuple
as a result of our top level state.

122
00:07:34,823 --> 00:07:37,514
Now this is the end of
this particular video but

123
00:07:37,514 --> 00:07:40,990
we've one more where we show
you how to use the state monad.

124
00:07:40,990 --> 00:07:42,720
But before you watch that,
it would be good for

125
00:07:42,720 --> 00:07:46,310
you to work through this code to be
sure you understand how it works.

126
00:07:46,310 --> 00:07:48,380
It's true we haven't shown
you any examples yet but

127
00:07:48,380 --> 00:07:52,800
just from knowing the types of the parts,
you can derive this particular definition.

128
00:07:52,800 --> 00:07:56,101
So see if you can get to the point where
you can write this definition out without

129
00:07:56,101 --> 00:07:59,165
consulting any sources and it will
help you understand what comes next.