Hello everyone. Welcome to CS 421. Today, we're going to talk about an interesting language construct called the monad. When you're done with this video, you'll be able to describe the problem that monads attempt to solve, understand three monad laws, know Haskell syntax for declaring monadic operations and be able to show how monads work for the List and Maybe types. So, let's start off by defining monads. Now, a monad is a container type m that has two functions, bind and return. You can see the types on the slide. The return function is very simple. All it does is take a value of type a and place it inside the container. For thinking this looks like pure from the applicative type class, you'd be correct, they are the same thing. The idea here is that, return takes a value and puts it into a monad for us. Now, be sure you don't confuse this with the return keyword that most other languages have that they use for returning from functions. This is a different thing. Now, the bind function is quite a bit more complicated, it takes two arguments. The first is a container containing a value of type a. The second argument is a function that takes a value of type a and returns another container that holds the result of the function. The output is a container of the same type, but it is not necessarily the same thing that the function returned. Bind's job is to unpack the incoming monadic container and feed the contents to the function and then take the result of that function and possibly do more processing. I'll go over some examples of these in the next few slides. Now, one thing you should know is that bind is often written with this symbol, greater-greater-equal. If you replace the second greater than symbol with a lambda, you will get the Haskell logo. Now, there are certain rules that bind and return are expected to follow, called the three monad laws. They're pretty simple really. The first two laws say that return acts as a kind of identity, both on the left hand side and the right-hand side of a bind. The third law just says that bind is associative, which makes it easier to compose multiple binding operations. Here are a few examples of how return works for some built-in types. For a Maybe, return simply puts its volume to a just. For a list, return creates a singleton list with that element. For an either, return puts its element and a right construct. Again, we see that return and like pure and applicative places its argument in the simplest version of the container that can hold it. I should point out that once a value is inside the container, we don't have a way of manipulating it directly except by using the monadic bind operation, at least that is if you want to restrict yourself to the monadic operations. For monads, all the magic happens in bind. Bind's job is to unpack the monad , feed the contents to the function and collect whatever monadic results it gives and then package it up into a single monad. Here's a simple example with Maybe monad or perhaps, remind you of applicative. If we bind a nothing to a function, we get nothing back. In fact, the function's not even run. If we bind a just to a function, we feed the contents of the just to the function and return whatever the function gives us back. Now, there's one huge difference between monads and applicatives. In an applicative, the function would have returned a ground level type and the applicative operator would have lifted it into a just for us, but with monads, the function itself gets to decide whether to return a just or a nothing. See what I mean, consider these programs. The functions on the top use applicative, but if we want a function that can signal an error, we need something like the functions on the bottom. Now, before you move on, verify for yourself that the functions on the bottom cannot be used for f map or applicatives. Again, to reemphasize, applicatives take the values out of the parameters, run them through a function and then repackage the result for us. The functions have no control, the applicatives makes all the decisions. Monads let the functions themselves decide what should happen and that's what makes them more powerful. So, now, we can define our inc and add functions to use monads. Here, we assume the inputs are monads and we bind to access the content and return to repackage it as a monad. So, the madd function needs two inputs. So, notice that bind operations are nested. You might imagine that if we had a bunch of operations like this, we'd end up writing a bunch of boilerplate, binding and returning code. Well, that's working for the computer and you know how we feel about that. Fortunately, there's a library called control.monad which gives us these handy monadic lifting functions. Just give it a ground-level operation and it returns a monadified version of it. On the next slide, we will show you how it's used. So, see how much nicer it is. The madd, minc and related functions are very simple now, with the exception of mdiv. Since that operation does something special, we had to write it out. Here is one more operation that you need to see, the fail function. Mathematically, it's not really part of a monad, but in Haskell, they are included, since monads are often used to handle error conditions, but this isn't a type class called MonadFail. So, the faii function takes a string and returns whatever a monad would represent failure, but just realize that not all monads actually have a way of representing failure. Here's the complete definition of the Maybe monad. So, as we said before, return places its argument into a just, binding with nothing, producing nothing and binding with just gives a function a chance to say what happens next. So, here's a few examples. In the first, line we just increment ten, in the second line, we add some things and in the third line we perform a division. The fourth and fifth lines are interesting. In the fourth example, we increment the result of the division, but in the fifth example we have a division by zero, and the increment therefore gets nothing and returns nothing. Here also is the definition of the list monad. Return places its argument into a singleton List and bind is a bit special here. Given a List, bind will extract the contents and apply them to functions you give it. But here's the deal. A List can contain multiple items. Each one of them is going to be given to your function. Furthermore, that function is going to return a monad. In other words, a List. So, the results of bind here will be a List of lists. To make this work with the types, we need to combine all these lists together somehow. Fortunately, we have a built-in function that does just that called concatMap. It's like map, but it assumes the output of the function is a list and concatenates everything together for us. The Maybe monad from the previous example is often used to simulate error handling and the list monad is often used to simulate non-determinism, so that allows multiple possibilities. We can use our calculator functions with the List monad, without having to modify anything. Here, we pass one, two and three to minc and get two, three, four and if we pass a multi-parameter List to n plus, it will give us back all the combinations of all the additions that could have occurred. Now, if we do a division by zero, it gives us back the empty list because that represents a failure, but the last example is really nice. We have three divisors for ten now. One of them results in an error, but the other succeed. So, we end up with a List containing the two successful ones. So, these are just a few examples. I hope you'll play with this yourself on the Haskell-ripple and the next videos will show some more advanced kind of monads.