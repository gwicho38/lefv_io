Hello and welcome to CS 421. Today, we're going to start a short series of lectures about a strange language called Prolog. You ask a typical programming language student about Prolog a few months after a course is done, they'll usually say something like, "Yes, that was a weird language, I don't remember much about it." In some introductory programming language courses ignore it completely and to be honest, it's not likely to come up in industry. So, with such a ringing endorsement why bother teaching it. One of the major ideas of this course is that the choice of language has a huge effect on how you go about solving problems. A prologue is a different way of looking at computation in most languages and sometimes this turns out to be a major advantage. So, in this course you're going to write a type inference. But if I was going to ask you to do it in Java, I'd give you maybe two or three weeks, in Haskell I'd feel safe giving you one week to do it, but if you knew Prolog you could write this in about 15 minutes. So, even if you don't use Prolog directly, you may be able to get a logic library for your favorite language and integrate that. That just might save you a couple of weeks of coding and debugging, so I think that makes Prolog worth knowing about. Now for this lecture, your objective is to be able to explain how Prolog uses unification to drive computation and to write a few simple prolog programs. So, let's start this off by asking the question, how do you decide what is true? Philosophers have a great time arguing over how you get started on something like that, but if you happen to have a nice starter set of things you already know or assume to be true, and it's easy to make more true things out of the ones you started with. So, in Prolog what we're going to do is declare some objects, don't confuse those with the objects and object oriented programming though. Objects in Prolog are like the terms in the unification problem, they're bare patterns, they don't hold values but they are important for the structure they exhibit. Next you're going to write down some facts about those objects, this correspond to axioms of logic, things like Socrates is human. Third, you write down some rules, facts that are true if other facts also happened to be true. So, the rule if X is human then X is mortal is a famous one. Now, such things can be easily expressed in first order predicate logic. So, remember that predicate is a function that returns true or false. If we have two true things we can make a third true thing by connecting them with things like and and or depending on the circumstances. We've already talked about first order predicate logic in this class, I'm not going to say more about it at this point. Now, Prolog uses an idea we've talked about before. A logic system like first-order predicate logic works by manipulating symbols and it turns out computers are pretty good at doing that. So, the idea behind Prolog is to describe the solution to a problem using logic and let the computer work out what the solution should be. Prolog was first developed in 1970 by Alan Colmerauer and Robert Kowalski among others. At the time, they thought that Prolog would be used for things like databases and expert systems. When I first started teaching this course, I used to say that there are two questions we could use to categorize programming languages, what is the nature of data and what is the nature of a program? Decided over the years that it's a bit too simplistic, so I don't use those questions much anymore but I liked the answers in Prolog, so I kept the slide. So, what is the nature of data? In Prolog, data consists of facts and rules about objects. They are kept in a database by the language. What is the nature of a program? Well, a program is a set of these facts and rules followed by a query. Now, that's a bit abstract so let's do a real example. So, on the top left you see a graph, it's directed and disconnected and on the right, you see a Prolog representation of this graph. It's not the only representation we could have used but it does what we want. They're all connected and the node names a through h are not reserved words are variables, they are simply patterns that exist, and we are the ones you choose how to interpret these patterns as a description of a graph. On the bottom left, you see three facts. First, that Socrates is human. Second, the fact that Socrates is the father of Jane. There was a huge scandal in the philosophy world in Ancient Greece when this happened, remember you heard it here first. One of the fun and frustrating things about computers, they believe anything we say whether it's a good idea or not. Finally, the third fact is that Zeus is the father of Apollo. Now, let's add some rules. The first rule says that, X is mortal if X is human. In Prolog the conclusion is on the left-hand side of the colon dash operator, and the patterns are on the right hand side, they hypotheses or subgoals. The second rule says that if X is the father of Y and X is human then Y is human. The last two rules spell out when there's a path from X to Y. Either X is connected to Y or X is connected to some Z that has a path to Y. The capital letters are variables and behave the way variables data in unification problems. They don't contain values per se but they unify with patterns. If a variable appears on the left-hand side of the colon dash, we understand that logically as being quantified with a "for all" and if it appears first on the right hand side, it is quantified within exists. So, now we have a small Prolog database, let's now run some queries against it. A Prolog REPL will present you with a prompt that looks like a question mark dash. After you type in a pattern Prolog will try to unify it with a database. So, if you type in human (socrates) then Prolog finds that there is a rule listed directly that says the same thing. So, trivially these two terms unify and prologue declares that this pattern to be true. If we ask mortal(socrates) things get more involved. The exact term mortal(socrates) is not listed but we do have a rule mortal(X) where X is a variable. Therefore, X will unify with socrates here. This term has a sub-goal though, human(X). Since X unifies with socrates, we replace the X with socrates and search for that. Now, you'll notice that when I read these Prolog terms out, I usually skip mentioning the parentheses and I feel like that's probably okay as long as you can actually see the slide when I'm doing it. Now, here's the next step. We want to be a little bit more explicit we have this rule mortal(X) if human(X) and then we unify mortal(X) with the mortal(socrates) that rule like the one on the bottom. So, if Socrates is human then Socrates is mortal. Prolog knows that Socrates is human so Prolog also deduces that Socrates is mortal. So incidentally, this whole thing about Socrates being mortal is a rough equivalent to the Hello World first program in other programming languages. Now, let's look at a more complicated example. We're going to ask if Jane is mortal. Well, that query unifies the same rule that X is mortal if X is human. That gives us this instance. Now, we can say that Jane is mortal if Jane is human so is Jane human. Well human(jane) unifies with human(Y) yielding the subgoals. We have to find some X such that X is the father of Jane and then we have to show that X is human. Now, we're in luck because father of X Jane unifies with fatherof(socrates, jane). Then this instantiates X for us. Now we just have to check if Socrates is human. Now, here's a couple for you to try, see if you can write a predicate exactlybetween and another predicate between. The difference is that exactlybetween only accepts connected but between works with paths. So, pause and resume when you're ready to see the answer. Well, here are the solutions. So, again exactlybetween we have two connected subgoals and between we have two path from subgoals. One thing that makes Prolog interesting is that we can put a variable into a query and then Prolog will give us a list of all the substitutions for that variable that made the query true. Here we ask who is the father of Apollo where who is a variable and Prolog will discover that this query unifies with fatherof(zeus, apollo) and report back that who can equal Zeus. The next query we try is to ask if there's a path from c to X, where X is a variable. The first result is that X equals a. This is because c is connected to a in the graph. Next you see a semicolon, this is actually the user's input on the REPL. Prolog will pass if it thinks that there could be more than one result, you can hit enter to accept the results you've gotten so far, or semicolon to search for another solution. The second solution, Prolog finds h since a is connected to h in the graph. The third and fourth solutions are both f. This happens because there are two paths from c to f in the graph and Prolog discovers both of them and reports them. So, if we look a bit more closely, when we first enter the query path from c, X the first rule it will unify with is this one, that there's a path from c to Y, if c is connected to Y. Prolog then searches for the subgoal c connected to Y and finds out that this unifies so c is connected to a. We ask it to search again, it drops a c is connected to a result and searches for another one that unifies, in this case, it unifies that c is connected to h. When asked for our third result, the connected subgoal fails and so Prolog backtracks to the top-level, since this particular rule for path from has no more answers Prolog goes to the next one. So, now Prolog will try these rules. They'll find some z that c is connected to and see if there's a path between those. That connected c, z subgoals find a and h but then we find a path from a and h to f. So, we're going to go over a few more syntactic things. This'll be quick but think of this part is more showing you the features, practice problems so make sure you get the details. Because Prolog is driven by unification, we have to tell it explicitly if you want to use arithmetic. Here's an example of the ever present factorial function. The first clause says that one is the factorial of zero or if you want to be more precise that the predicate facts succeeds on inputs zero and one. The second clause is three subgoals. M is N minus 1 says to subtract one from n and have M unify with that value. fact(M, Y) is just a recursive call and X is Y times N is another arithmetic operation. If you were to replace the is keyword by equal by mistake, then M would be replaced by the pattern N minus 1 and nothing would happen. Another thing to notice just to reiterate, functions never return values in Prolog. They either succeed or not. To have the experience of returning a value, you have one variable as an output variable. If you are familiar with the mathematical description of functions as relations, then this representation should remind you of that. Another syntax you're going to use is list notation. The empty list and singleton lists look just like they do at Haskell. Again, I've lists with multiple elements again just like in Haskell by separating elements with commas. Now, the head and tail representation is a bit different though. We keep the angle brackets and we put a vertical bar between H and T to represent that H is the first element and T is the remainder of the list. So, the big difference between Haskell though is that Prolog lists have no concept of monotonicity. Prolog doesn't care about the types and formats and what the elements are. So, let's combine lists and arithmetic syntax to write a length predicate. So, length is built into prologues we call it mylength. First clause says mylength of the empty list is zero and mylength of a list with a head and a tail is one more than the mylength of the tail. There is a one-character change you can make if you want to make this take the sum of the elements of lists. So, pause this and seeking to determine what that changes and resume when you're ready to see the answer. Here's the answer. Instead of just adding one, we add whatever's in H. If you want more practice, you can try writing product but we won't go over that here. Here's another example list Append. Again notice the very Prolog style of having the first two parameters that pattern be the input and the last parameter be the output. When you look at Prolog documentation it will indicate which variables are inputs and which ones are outputs. In many cases, variables can be either inputs or outputs. On line six and eight, we have Prolog find an X such that appending X to two, three gives us a list one, two, three, four or one, two, three. So, as a final example here's reverse written in Prolog. We use an auxiliary function with an accumulator to handle the verse in much the same way you do it in Haskell. So, that's enough for the introduction. You want to get a Prolog compilers such as SWI is free Prolog compiler and try these examples. You'll see some more examples on the course website.