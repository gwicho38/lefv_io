Hello everyone, and welcome back. So, being able to specify effects and rules is powerful, but so far we've treated Prolog as a static build the system then solve the problem kind of language, and actually Prolog can modify its database enabling a Prolog program to learn. When we're done with this lesson, you'll be able to use findall and checklists to perform queries over a range of values. You'll be able to use call and assert to modify Prolog's database, and finally you'll be able to programatically construct and deconstruct Prolog objects. So, let's first look at findall and checklist. These are some of prologues higher-order functions or maybe I should call them higher-order predicates. Findall has three parameters. The first is a new variable X, the second is a query concerning X, and the output is a variable that will contain the list of patterns that satisfy the query. Think of it as a function that keeps hitting semicolon for you and then presents the whole bunch of results. Checklists takes a predicate as its first parameter and the list of items, and then applies the predicate to each item. Checklist succeeds if the entire list succeeds with the predicate. The assumptions will come in handy a bit later. One very interesting feature Prolog that rarely gets mentioned is that Prolog is a homoiconic language. Data that you put into the database is the same as the queries you run against it, or more generally code and data share the same form. This is also a feature of the list family of languages and allows for some very powerful and most people would say very dangerous styles of programming, namely that programs can examine and write other programs. Personally, I really like it. Now, to have Prolog examine terms, it provides a bunch of predicates that check the kind of thing that the predicate has. So, an atom is a pattern like Socrates, Jane or Eve in the previous lecture. Things that look like variables and other languages basically. To integers and such are not atoms, but these are called atomic and so we have another predicate called atomic to check for those. We also have predicates called integer that checks for integers and so on and so forth. You get the idea. Now, one really nice predicate is called var. You use it to check if a variable has been unified yet or not. So, you can write some really interesting predicates with this. You already have seen that a predicate can use its parameters as either input or output, or sometimes both. Sometimes, you would want to use a different algorithm at the first parameter is a variable, then in the second parameter, then if the second parameter is a variable. The var predicate allows you to check and then pick the best algorithm for the job. Now, if you want to convert between an atom and a string, there's a name predicate that allows you to do that. The list 102, 111, 111, that's just the list of ASCII values for foo, and this is a great predicate to have on hand if you're doing natural language processing. There are predicates that work on functors as well. But before we go to those, I want to show you this one useful utility called listing. You give it a name of an object or a functor and it will show you all of the functors in the database that share that name. So, you've seen ways to look at atomic things to see what kind of things they are. Functors are more complicated because they have arguments. So, here are two predicates to examine functors. The functor predicate takes functor as its first argument and the two outputs are the name and the number of arguments. The arg predicate will return a specific argument for a particular functor. So, these predicates are useful if you want a specific part of the functor, but if you want all of the information you're going to need what's on the next slide. So, if you want to build functors or deconstruct them completely, you're going to need this equal dot dot operator. It takes a functor on the left side and returns a list on the right, but the first element is a functor and the rest are the arguments. This is the same kind of representation you would expect in dialect of list. So, you can see here in the example, I've deconstructed bst five, null, null into L. Now, L is a list of those parts. On line three, I take a list likes, John, X and assemble that into L to get a functor. This works for rules as well as for simple functors. That colon and dash operator we've been using all this time is actually just another functor. Since it's assemble and not alphanumeric, it puts parentheses around it when it stands alone making it look like a smiley face emoticon. So, we've seen how to examine things and create them. Now, let's put these things into the main database. The main commands for this are assert and retract. Assert takes an argument and puts it into the database. In this example, I've asserted that two, three, five and seven are primes, and I can now query them just as if I've loaded them from a program. I can also change my mind and retract the fact. Jucy's predicates you loaded from a file, you need to declare that the predicates are dynamic using the dynamic keyword. The slash two at the end of likes here means that likes takes two parameters. Now, assert can work for both facts and with implications. Is usually assert just puts new information at the end of the database. Now usually, assert puts new information at the end of a database. If you want to insert it, the fact, at the beginning, you have assert a to handle that for you. Now, the last piece of the puzzle you need is this call predicate. Call is like eval and other languages. It takes a structure you've created it and runs it as a query. Here's an example of where right of predicate ask about. You give it an object and the name of a predicate and ask about will assemble them into query and run that query. So, call is not the same thing as asserted. It runs queries only. Assert is for updating the database. So, here's an example program to keep track of student questions. In our database, we have a predicate question with two arguments. The first is a student who ask the question, the second is the query the student would like to run. The answer predicate finds the next question asked by a particular student, then runs the query for the student and also removes a question from the database, so we don't have to answer it again. So, being able to update the database like this makes Prolog much more interesting than what is normally taught about it. On the course website, you'll find a couple of toy programs that you might want to look at. One is an artificial intelligence program that takes a rudimentary natural language queries in response to them. The other is a type inferencer, like the one from your MPs, but you could have written it yourself in about 15 minutes once you know how to do it, and so that's it for our Prolog series and I hope you enjoyed the language.