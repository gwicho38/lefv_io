1
00:00:00,000 --> 00:00:02,745
Hello and welcome to CS 421.

2
00:00:02,745 --> 00:00:04,710
Today, we're going to start a short series of

3
00:00:04,710 --> 00:00:07,590
lectures about a strange language called Prolog.

4
00:00:07,590 --> 00:00:09,870
You ask a typical programming language student about

5
00:00:09,870 --> 00:00:12,225
Prolog a few months after a course is done,

6
00:00:12,225 --> 00:00:13,980
they'll usually say something like, "Yes,

7
00:00:13,980 --> 00:00:15,555
that was a weird language,

8
00:00:15,555 --> 00:00:17,280
I don't remember much about it."

9
00:00:17,280 --> 00:00:21,645
In some introductory programming language courses ignore it completely and to be honest,

10
00:00:21,645 --> 00:00:23,460
it's not likely to come up in industry.

11
00:00:23,460 --> 00:00:27,465
So, with such a ringing endorsement why bother teaching it.

12
00:00:27,465 --> 00:00:30,390
One of the major ideas of this course is that the choice of

13
00:00:30,390 --> 00:00:34,335
language has a huge effect on how you go about solving problems.

14
00:00:34,335 --> 00:00:36,840
A prologue is a different way of looking at computation in

15
00:00:36,840 --> 00:00:40,400
most languages and sometimes this turns out to be a major advantage.

16
00:00:40,400 --> 00:00:43,400
So, in this course you're going to write a type inference.

17
00:00:43,400 --> 00:00:46,370
But if I was going to ask you to do it in Java,

18
00:00:46,370 --> 00:00:48,665
I'd give you maybe two or three weeks,

19
00:00:48,665 --> 00:00:51,440
in Haskell I'd feel safe giving you one week to do it,

20
00:00:51,440 --> 00:00:55,115
but if you knew Prolog you could write this in about 15 minutes.

21
00:00:55,115 --> 00:00:57,680
So, even if you don't use Prolog directly,

22
00:00:57,680 --> 00:01:01,760
you may be able to get a logic library for your favorite language and integrate that.

23
00:01:01,760 --> 00:01:04,670
That just might save you a couple of weeks of coding and debugging,

24
00:01:04,670 --> 00:01:07,865
so I think that makes Prolog worth knowing about.

25
00:01:07,865 --> 00:01:12,470
Now for this lecture, your objective is to be able to explain how Prolog uses

26
00:01:12,470 --> 00:01:17,705
unification to drive computation and to write a few simple prolog programs.

27
00:01:17,705 --> 00:01:20,555
So, let's start this off by asking the question,

28
00:01:20,555 --> 00:01:22,610
how do you decide what is true?

29
00:01:22,610 --> 00:01:26,840
Philosophers have a great time arguing over how you get started on something like that,

30
00:01:26,840 --> 00:01:29,090
but if you happen to have a nice starter set of

31
00:01:29,090 --> 00:01:31,580
things you already know or assume to be true,

32
00:01:31,580 --> 00:01:34,945
and it's easy to make more true things out of the ones you started with.

33
00:01:34,945 --> 00:01:37,770
So, in Prolog what we're going to do is declare some objects,

34
00:01:37,770 --> 00:01:41,030
don't confuse those with the objects and object oriented programming though.

35
00:01:41,030 --> 00:01:44,480
Objects in Prolog are like the terms in the unification problem,

36
00:01:44,480 --> 00:01:46,310
they're bare patterns, they don't hold

37
00:01:46,310 --> 00:01:49,870
values but they are important for the structure they exhibit.

38
00:01:49,870 --> 00:01:53,475
Next you're going to write down some facts about those objects,

39
00:01:53,475 --> 00:01:55,470
this correspond to axioms of logic,

40
00:01:55,470 --> 00:01:57,585
things like Socrates is human.

41
00:01:57,585 --> 00:01:59,980
Third, you write down some rules,

42
00:01:59,980 --> 00:02:03,565
facts that are true if other facts also happened to be true.

43
00:02:03,565 --> 00:02:08,410
So, the rule if X is human then X is mortal is a famous one.

44
00:02:08,540 --> 00:02:13,330
Now, such things can be easily expressed in first order predicate logic.

45
00:02:13,330 --> 00:02:17,140
So, remember that predicate is a function that returns true or false.

46
00:02:17,140 --> 00:02:20,030
If we have two true things we can make a third true thing by

47
00:02:20,030 --> 00:02:23,555
connecting them with things like and and or depending on the circumstances.

48
00:02:23,555 --> 00:02:26,240
We've already talked about first order predicate logic in this class,

49
00:02:26,240 --> 00:02:29,185
I'm not going to say more about it at this point.

50
00:02:29,185 --> 00:02:32,930
Now, Prolog uses an idea we've talked about before.

51
00:02:32,930 --> 00:02:35,990
A logic system like first-order predicate logic works by

52
00:02:35,990 --> 00:02:39,595
manipulating symbols and it turns out computers are pretty good at doing that.

53
00:02:39,595 --> 00:02:42,920
So, the idea behind Prolog is to describe the solution to

54
00:02:42,920 --> 00:02:47,105
a problem using logic and let the computer work out what the solution should be.

55
00:02:47,105 --> 00:02:53,540
Prolog was first developed in 1970 by Alan Colmerauer and Robert Kowalski among others.

56
00:02:53,540 --> 00:02:55,880
At the time, they thought that Prolog would be used for

57
00:02:55,880 --> 00:02:59,160
things like databases and expert systems.

58
00:02:59,930 --> 00:03:02,375
When I first started teaching this course,

59
00:03:02,375 --> 00:03:04,210
I used to say that there are two questions we

60
00:03:04,210 --> 00:03:06,385
could use to categorize programming languages,

61
00:03:06,385 --> 00:03:09,650
what is the nature of data and what is the nature of a program?

62
00:03:09,650 --> 00:03:12,480
Decided over the years that it's a bit too simplistic,

63
00:03:12,480 --> 00:03:15,940
so I don't use those questions much anymore but I liked the answers in Prolog,

64
00:03:15,940 --> 00:03:17,305
so I kept the slide.

65
00:03:17,305 --> 00:03:19,010
So, what is the nature of data?

66
00:03:19,010 --> 00:03:22,465
In Prolog, data consists of facts and rules about objects.

67
00:03:22,465 --> 00:03:24,775
They are kept in a database by the language.

68
00:03:24,775 --> 00:03:26,410
What is the nature of a program?

69
00:03:26,410 --> 00:03:31,100
Well, a program is a set of these facts and rules followed by a query.

70
00:03:31,670 --> 00:03:35,940
Now, that's a bit abstract so let's do a real example.

71
00:03:35,940 --> 00:03:37,980
So, on the top left you see a graph,

72
00:03:37,980 --> 00:03:40,610
it's directed and disconnected and on the right,

73
00:03:40,610 --> 00:03:43,120
you see a Prolog representation of this graph.

74
00:03:43,120 --> 00:03:46,895
It's not the only representation we could have used but it does what we want.

75
00:03:46,895 --> 00:03:48,860
They're all connected and the node names a

76
00:03:48,860 --> 00:03:50,960
through h are not reserved words are variables,

77
00:03:50,960 --> 00:03:52,880
they are simply patterns that exist,

78
00:03:52,880 --> 00:03:54,710
and we are the ones you choose how to interpret

79
00:03:54,710 --> 00:03:57,250
these patterns as a description of a graph.

80
00:03:57,250 --> 00:04:00,090
On the bottom left, you see three facts.

81
00:04:00,090 --> 00:04:02,250
First, that Socrates is human.

82
00:04:02,250 --> 00:04:05,600
Second, the fact that Socrates is the father of Jane.

83
00:04:05,600 --> 00:04:09,275
There was a huge scandal in the philosophy world in Ancient Greece when this happened,

84
00:04:09,275 --> 00:04:11,230
remember you heard it here first.

85
00:04:11,230 --> 00:04:13,790
One of the fun and frustrating things about computers,

86
00:04:13,790 --> 00:04:17,360
they believe anything we say whether it's a good idea or not.

87
00:04:17,360 --> 00:04:21,510
Finally, the third fact is that Zeus is the father of Apollo.

88
00:04:22,240 --> 00:04:25,090
Now, let's add some rules.

89
00:04:25,090 --> 00:04:26,955
The first rule says that,

90
00:04:26,955 --> 00:04:29,520
X is mortal if X is human.

91
00:04:29,520 --> 00:04:34,190
In Prolog the conclusion is on the left-hand side of the colon dash operator,

92
00:04:34,190 --> 00:04:36,665
and the patterns are on the right hand side,

93
00:04:36,665 --> 00:04:39,395
they hypotheses or subgoals.

94
00:04:39,395 --> 00:04:44,825
The second rule says that if X is the father of Y and X is human then Y is human.

95
00:04:44,825 --> 00:04:48,740
The last two rules spell out when there's a path from X to Y.

96
00:04:48,740 --> 00:04:54,005
Either X is connected to Y or X is connected to some Z that has a path to Y.

97
00:04:54,005 --> 00:04:56,330
The capital letters are variables and behave the way

98
00:04:56,330 --> 00:04:58,505
variables data in unification problems.

99
00:04:58,505 --> 00:05:02,840
They don't contain values per se but they unify with patterns.

100
00:05:02,840 --> 00:05:05,990
If a variable appears on the left-hand side of the colon dash,

101
00:05:05,990 --> 00:05:08,780
we understand that logically as being quantified with a

102
00:05:08,780 --> 00:05:12,065
"for all" and if it appears first on the right hand side,

103
00:05:12,065 --> 00:05:15,120
it is quantified within exists.

104
00:05:15,230 --> 00:05:18,380
So, now we have a small Prolog database,

105
00:05:18,380 --> 00:05:20,420
let's now run some queries against it.

106
00:05:20,420 --> 00:05:25,430
A Prolog REPL will present you with a prompt that looks like a question mark dash.

107
00:05:25,430 --> 00:05:29,980
After you type in a pattern Prolog will try to unify it with a database.

108
00:05:29,980 --> 00:05:33,150
So, if you type in human (socrates) then

109
00:05:33,150 --> 00:05:36,530
Prolog finds that there is a rule listed directly that says the same thing.

110
00:05:36,530 --> 00:05:41,615
So, trivially these two terms unify and prologue declares that this pattern to be true.

111
00:05:41,615 --> 00:05:45,570
If we ask mortal(socrates) things get more involved.

112
00:05:45,570 --> 00:05:48,020
The exact term mortal(socrates) is not

113
00:05:48,020 --> 00:05:51,920
listed but we do have a rule mortal(X) where X is a variable.

114
00:05:51,920 --> 00:05:55,015
Therefore, X will unify with socrates here.

115
00:05:55,015 --> 00:05:58,110
This term has a sub-goal though, human(X).

116
00:05:58,110 --> 00:06:00,450
Since X unifies with socrates,

117
00:06:00,450 --> 00:06:03,840
we replace the X with socrates and search for that.

118
00:06:03,840 --> 00:06:07,340
Now, you'll notice that when I read these Prolog terms out,

119
00:06:07,340 --> 00:06:11,120
I usually skip mentioning the parentheses and I feel

120
00:06:11,120 --> 00:06:15,930
like that's probably okay as long as you can actually see the slide when I'm doing it.

121
00:06:16,340 --> 00:06:18,830
Now, here's the next step.

122
00:06:18,830 --> 00:06:20,990
We want to be a little bit more explicit we have

123
00:06:20,990 --> 00:06:23,660
this rule mortal(X) if human(X) and then we

124
00:06:23,660 --> 00:06:28,520
unify mortal(X) with the mortal(socrates) that rule like the one on the bottom.

125
00:06:28,520 --> 00:06:31,510
So, if Socrates is human then Socrates is mortal.

126
00:06:31,510 --> 00:06:36,490
Prolog knows that Socrates is human so Prolog also deduces that Socrates is mortal.

127
00:06:36,490 --> 00:06:39,920
So incidentally, this whole thing about Socrates being mortal is

128
00:06:39,920 --> 00:06:45,090
a rough equivalent to the Hello World first program in other programming languages.

129
00:06:45,260 --> 00:06:48,425
Now, let's look at a more complicated example.

130
00:06:48,425 --> 00:06:50,910
We're going to ask if Jane is mortal.

131
00:06:51,370 --> 00:06:57,925
Well, that query unifies the same rule that X is mortal if X is human.

132
00:06:57,925 --> 00:07:01,210
That gives us this instance.

133
00:07:02,090 --> 00:07:07,335
Now, we can say that Jane is mortal if Jane is human so is Jane human.

134
00:07:07,335 --> 00:07:14,050
Well human(jane) unifies with human(Y) yielding the subgoals.

135
00:07:14,050 --> 00:07:17,120
We have to find some X such that X is the father of

136
00:07:17,120 --> 00:07:20,740
Jane and then we have to show that X is human.

137
00:07:20,740 --> 00:07:26,460
Now, we're in luck because father of X Jane unifies with fatherof(socrates, jane).

138
00:07:27,220 --> 00:07:30,845
Then this instantiates X for us.

139
00:07:30,845 --> 00:07:35,190
Now we just have to check if Socrates is human.

140
00:07:36,740 --> 00:07:39,470
Now, here's a couple for you to try,

141
00:07:39,470 --> 00:07:44,075
see if you can write a predicate exactlybetween and another predicate between.

142
00:07:44,075 --> 00:07:46,820
The difference is that exactlybetween only accepts

143
00:07:46,820 --> 00:07:50,060
connected but between works with paths.

144
00:07:50,060 --> 00:07:53,790
So, pause and resume when you're ready to see the answer.

145
00:07:55,450 --> 00:07:58,375
Well, here are the solutions.

146
00:07:58,375 --> 00:08:00,590
So, again exactlybetween we have

147
00:08:00,590 --> 00:08:06,150
two connected subgoals and between we have two path from subgoals.

148
00:08:08,270 --> 00:08:11,180
One thing that makes Prolog interesting is that

149
00:08:11,180 --> 00:08:13,130
we can put a variable into a query and then

150
00:08:13,130 --> 00:08:14,420
Prolog will give us a list of

151
00:08:14,420 --> 00:08:18,005
all the substitutions for that variable that made the query true.

152
00:08:18,005 --> 00:08:21,980
Here we ask who is the father of Apollo where who is a variable and

153
00:08:21,980 --> 00:08:25,550
Prolog will discover that this query unifies with fatherof(zeus,

154
00:08:25,550 --> 00:08:28,520
apollo) and report back that who can equal Zeus.

155
00:08:28,520 --> 00:08:31,620
The next query we try is to ask if there's a path from c to X,

156
00:08:31,620 --> 00:08:33,020
where X is a variable.

157
00:08:33,020 --> 00:08:36,025
The first result is that X equals a.

158
00:08:36,025 --> 00:08:39,050
This is because c is connected to a in the graph.

159
00:08:39,050 --> 00:08:40,909
Next you see a semicolon,

160
00:08:40,909 --> 00:08:43,390
this is actually the user's input on the REPL.

161
00:08:43,390 --> 00:08:46,300
Prolog will pass if it thinks that there could be more than one result,

162
00:08:46,300 --> 00:08:49,070
you can hit enter to accept the results you've gotten so far,

163
00:08:49,070 --> 00:08:52,310
or semicolon to search for another solution.

164
00:08:52,310 --> 00:08:56,915
The second solution, Prolog finds h since a is connected to h in the graph.

165
00:08:56,915 --> 00:09:01,430
The third and fourth solutions are both f. This happens because there are two paths

166
00:09:01,430 --> 00:09:06,865
from c to f in the graph and Prolog discovers both of them and reports them.

167
00:09:06,865 --> 00:09:09,505
So, if we look a bit more closely,

168
00:09:09,505 --> 00:09:12,020
when we first enter the query path from c,

169
00:09:12,020 --> 00:09:15,665
X the first rule it will unify with is this one,

170
00:09:15,665 --> 00:09:17,660
that there's a path from c to Y,

171
00:09:17,660 --> 00:09:21,540
if c is connected to Y. Prolog then searches for

172
00:09:21,540 --> 00:09:27,095
the subgoal c connected to Y and finds out that this unifies so c is connected to a.

173
00:09:27,095 --> 00:09:28,715
We ask it to search again,

174
00:09:28,715 --> 00:09:32,270
it drops a c is connected to a result and searches for another one that unifies,

175
00:09:32,270 --> 00:09:36,620
in this case, it unifies that c is connected to h. When asked for our third result,

176
00:09:36,620 --> 00:09:41,135
the connected subgoal fails and so Prolog backtracks to the top-level,

177
00:09:41,135 --> 00:09:46,975
since this particular rule for path from has no more answers Prolog goes to the next one.

178
00:09:46,975 --> 00:09:49,350
So, now Prolog will try these rules.

179
00:09:49,350 --> 00:09:54,665
They'll find some z that c is connected to and see if there's a path between those.

180
00:09:54,665 --> 00:10:03,450
That connected c, z subgoals find a and h but then we find a path from a and h to f. So,

181
00:10:03,450 --> 00:10:05,630
we're going to go over a few more syntactic things.

182
00:10:05,630 --> 00:10:08,870
This'll be quick but think of this part is more showing you the features,

183
00:10:08,870 --> 00:10:11,540
practice problems so make sure you get the details.

184
00:10:11,540 --> 00:10:14,090
Because Prolog is driven by unification,

185
00:10:14,090 --> 00:10:17,420
we have to tell it explicitly if you want to use arithmetic.

186
00:10:17,420 --> 00:10:21,455
Here's an example of the ever present factorial function.

187
00:10:21,455 --> 00:10:25,430
The first clause says that one is the factorial of zero or if you want to be more

188
00:10:25,430 --> 00:10:29,945
precise that the predicate facts succeeds on inputs zero and one.

189
00:10:29,945 --> 00:10:31,925
The second clause is three subgoals.

190
00:10:31,925 --> 00:10:37,835
M is N minus 1 says to subtract one from n and have M unify with that value.

191
00:10:37,835 --> 00:10:44,585
fact(M, Y) is just a recursive call and X is Y times N is another arithmetic operation.

192
00:10:44,585 --> 00:10:47,810
If you were to replace the is keyword by equal by mistake,

193
00:10:47,810 --> 00:10:53,510
then M would be replaced by the pattern N minus 1 and nothing would happen.

194
00:10:53,510 --> 00:10:56,225
Another thing to notice just to reiterate,

195
00:10:56,225 --> 00:10:58,640
functions never return values in Prolog.

196
00:10:58,640 --> 00:11:00,455
They either succeed or not.

197
00:11:00,455 --> 00:11:02,750
To have the experience of returning a value,

198
00:11:02,750 --> 00:11:05,720
you have one variable as an output variable.

199
00:11:05,720 --> 00:11:10,055
If you are familiar with the mathematical description of functions as relations,

200
00:11:10,055 --> 00:11:13,040
then this representation should remind you of that.

201
00:11:13,040 --> 00:11:16,895
Another syntax you're going to use is list notation.

202
00:11:16,895 --> 00:11:20,305
The empty list and singleton lists look just like they do at Haskell.

203
00:11:20,305 --> 00:11:22,700
Again, I've lists with multiple elements again just like in

204
00:11:22,700 --> 00:11:24,950
Haskell by separating elements with commas.

205
00:11:24,950 --> 00:11:28,385
Now, the head and tail representation is a bit different though.

206
00:11:28,385 --> 00:11:32,525
We keep the angle brackets and we put a vertical bar between

207
00:11:32,525 --> 00:11:36,800
H and T to represent that H is the first element and T is the remainder of the list.

208
00:11:36,800 --> 00:11:39,530
So, the big difference between Haskell though

209
00:11:39,530 --> 00:11:42,650
is that Prolog lists have no concept of monotonicity.

210
00:11:42,650 --> 00:11:48,120
Prolog doesn't care about the types and formats and what the elements are.

211
00:11:48,970 --> 00:11:54,205
So, let's combine lists and arithmetic syntax to write a length predicate.

212
00:11:54,205 --> 00:11:57,900
So, length is built into prologues we call it mylength.

213
00:11:57,900 --> 00:12:01,950
First clause says mylength of the empty list is zero and

214
00:12:01,950 --> 00:12:06,755
mylength of a list with a head and a tail is one more than the mylength of the tail.

215
00:12:06,755 --> 00:12:09,560
There is a one-character change you can make if you want

216
00:12:09,560 --> 00:12:11,930
to make this take the sum of the elements of lists.

217
00:12:11,930 --> 00:12:13,940
So, pause this and seeking to determine what that

218
00:12:13,940 --> 00:12:17,220
changes and resume when you're ready to see the answer.

219
00:12:19,130 --> 00:12:22,410
Here's the answer. Instead of just adding one,

220
00:12:22,410 --> 00:12:24,950
we add whatever's in H. If you want more practice,

221
00:12:24,950 --> 00:12:28,560
you can try writing product but we won't go over that here.

222
00:12:29,410 --> 00:12:32,670
Here's another example list Append.

223
00:12:32,670 --> 00:12:35,330
Again notice the very Prolog style of having

224
00:12:35,330 --> 00:12:40,010
the first two parameters that pattern be the input and the last parameter be the output.

225
00:12:40,010 --> 00:12:42,590
When you look at Prolog documentation it will indicate

226
00:12:42,590 --> 00:12:45,320
which variables are inputs and which ones are outputs.

227
00:12:45,320 --> 00:12:49,040
In many cases, variables can be either inputs or outputs.

228
00:12:49,040 --> 00:12:53,300
On line six and eight, we have Prolog find an X such that appending X to two,

229
00:12:53,300 --> 00:12:54,710
three gives us a list one, two,

230
00:12:54,710 --> 00:12:57,510
three, four or one, two, three.

231
00:12:58,270 --> 00:13:03,110
So, as a final example here's reverse written in Prolog.

232
00:13:03,110 --> 00:13:06,290
We use an auxiliary function with an accumulator to handle

233
00:13:06,290 --> 00:13:09,960
the verse in much the same way you do it in Haskell.

234
00:13:11,110 --> 00:13:14,000
So, that's enough for the introduction.

235
00:13:14,000 --> 00:13:16,200
You want to get a Prolog compilers such as

236
00:13:16,200 --> 00:13:19,590
SWI is free Prolog compiler and try these examples.

237
00:13:19,590 --> 00:13:23,130
You'll see some more examples on the course website.