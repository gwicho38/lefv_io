So we have developed sort of a bridge between two provenance tools ours called, yesWorkflow. Another one called, noWorkflow. And in particular, the no workflow tool creates these very large, very detailed graphs of Python runs. But this really explains the provenance in terms of the script. So in terms of function calls, variable updates and so on. It is often very hard, even if you zoom in and even if you filter out stuff, to see what the overall data flow is. For example here, if you want to know what is the lineage of this particular image, DRT240_11000_(electron vault) eV_002. Well, it is expressed in terms that are not really directly related to how you might think about this script or this workflow. It is explained, well there are print commands you know, or formatting commands, there are assignments to variables. So, it is what you get when you trace a program or script. It explains this in terms of the code. It does not explain it in terms of the high level data artifacts that you care about and the computational steps that you kind of, or you abstract lots of little details into one. It has all the details. So this is like looking sometimes for needle in a haystack, resembles stock or not seeing the forest for the trees. I like to think of it that way. And so what we've done together with the colleagues who developed this tool is we tried to get the best of both worlds. And this is we're going to show you in the hands on demos. So, I briefly mentioned this before, just so you know, we keep query prospective provenance information all by itself. So if you wanted to know what does a corrected image depend on. I don't even need to run the script if my model is correct, the one where I explicitly declared what the dependencies are. If I declared that correctly, I can just go upstream here in this graph and there's a lot of stuff here on the left hand side. It's not quite exactly my cut out of that but there's a lot of stuff that in this diagram that does not influence corrected image. So if I'm only interested what went into the corrected image, this thing's over here, the rejection log or-- that does not have an influence on that. How would I know that? By running a query on this? Yes! For a flow model. So here I run a query and say, "Well, show me what is upstream of corrected image". Those are the only things that could have influenced the result. Either way there's no guarantee that they all in fact have influenced it but they could have based on the model. But everything that's not shown here, the model is correct should not have influenced this result. So, even on the prospective provenance graph or the workflow which is call it, itself we can ask interesting questions and then, we can kind of marry if you like or create alias or maybe, it's maybe another a very tight coupling, it's not a tight marriage. It's more of an acquaintances relationship, I guess, between yesWorkflow and noWorkflow. So we have basically two different accounts, two different world views of a particular script and it's execution. And what the goal here is then is to bring those together. And so we had to build sort of a link between them and this link is established essentially through rules where we have information in one database schema, the one that noWorkflow has. And then, another schema, the one that yesWorkflow has. And then we have to use some sort of identifiers, names, locations of folders, and so on, file names. Things like that to build that bridge. And when it's all said and done, you can see a diagram here on the right which we call hybrid provenance. We call it hybrid provenance because it is a combination of the prospective and the rest, retrospective.