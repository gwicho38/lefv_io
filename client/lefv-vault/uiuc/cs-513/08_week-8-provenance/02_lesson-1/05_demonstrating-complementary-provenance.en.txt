Now there is sometimes the need to have even finer-grained dependencies. And I want to briefly report on a collaboration between our team, who has developed YesWorkflow, and another team from Brazil that has developed another system called noWorkflow. Now that sounds a little strange. So there's a YesWorkflow system and a noWorkflow system. So what noWorkflow is doing, well, first of all, what does noWorkflow stand for? It's not "against workflows," as the name might suggest, but it stands for "not only workflow," which is a little play on noSQL or "no sequel", which stands for either, depending who you ask, "We don't like sequel. We have other ways to do things, " or it stands for "not only SQL." So maybe there are specialized query mechanisms and languages and database models that are useful for certain applications. So, the noSQL kind of name I think gave rise for this group to decide, well, we call our system noWorkflow. And what it's about, as you shall see, it's about capturing provenance from script runs. So their attitude was to say, "Well, we need provenance not only from proper workflows but also from scripts." We kind of turned this around a little bit and said, "Well, but the scripts are kind of worthless too. So we say YesWorkflow." But the tools turn out to be very complimentary in their goals. Again, noWorkflow captures mostly runtime provenance, although it has a prospective provenance element as well. And YesWorkflow is mostly about prospective provenance, but it can also do something with retrospective provenance. So, they're sort of starting out at different ends, and in this little project, we found a way to use those systems with good effect together. So I'm gonna just briefly go into this demonstration, and then I'll do a hands-on demonstration myself. So the history of what I like to call the YesWorkflow-noWorkflow Demo or the Yin and Yang Demo is that we have demonstrated the use of YesWorkflow in combination with retrospective provenance. And, there was a research seminar at a certain venue in Dagstuhl , which is a well-known computer science research meeting place in Germany, and so we got together, the people behind YesWorkflow and the people behind noWorkflow. We got together and said, you know, we should really see whether we can build a bridge between these two kinds of provenance information and see what we can do with it. So, let me briefly, you know, explain how that thing works. So as I mentioned before, many workflows are not built using workflow systems, they build the scripts. So here you have a script. And so how do you see what the big picture is? How do you see the method? How do you see a workflow from that? It's very hard to decipher. And also, it's maybe not even in there because there are certain things that the code really doesn't talk about. Or sometimes you call an external function, if you call an external function, you don't know what the external function is doing, so you don't even have that code, maybe. So there are clearly limitations to what you can do by just looking at the script. On the other hand, if you monitor the execution of a script, you can collect a lot of fine-grained runtime provenance, and this is what the focus is of the noWorkflow system. So let me just show you this. So again, this is a group mostly based in Brazil. noWorkflow stands for "not only workflow". Their sort of starting point was the observation that scripts can have provenance too, or we should support provenance for scripts. And so the idea was to transparently capture some or all provenance from, in this particular case, from Python scripts. And then you can use queries to or other mechanisms to zoom into that problem. So what is that big graph that you see? We're gonna zoom in in a moment, but it is essentially runtime provenance captured from a script execution, so just as you see in the conceptual diagram in sort of this greenish-yellowish style. In this bluish style, you see retrospective provenance, trace information essentially, collected from the noWorkflow system. So imagine now you have a Python script. So you use the noWorkflow system to capture runtime provenance, and you can use the YesWorkflow system to model overall what your script is doing, and that we call, of course, prospective provenance. So here is an example of the script that I showed you earlier using YesWorkflow. Now you see some of the provenance using the noWorkflow system. So the way you run this — again, it works only for Python, so there is a little difference there. The YesWorkflow system lifts from, you know, based on, really, comments that you put, so annotations that you put inside of your comments in your script. So the YesWorkflow system doesn't care whether you annotate R or Matlab or Python or no script at all. You can create that model, you know, in a blank space if you don't have a script yet. You can use it as a design tool. The noWorkflow tool, on the other side, on the other hand, is really based on an implementation of a library that captures runtime provenance for Python scripts. So in particular, there's a Python profiling library that allows, for example, Python programmers to see, to profile their code, to see where's the time spent. You know, maybe my code runs slow. Which functions are called the most often? Where is the time really burnt? But you can use that kind of information and sort of hijack it, if you like, capture it, and sort of repackage it as retrospective provenance and, you know, enrich this information with also information about the script — sort of another kind of prospective provenance, and then create really informative, large, and detailed provenance graphs, the blue ones that you see here. So if you run, for example, this particular script for data collection that I showed earlier in YesWorkflow, you can run this in the noWorkflow tool and then you would get another kind of provenance, another kind of data lineage, now in terms of the script. So whereas the YesWorkflow diagram was in terms of your mental model and maybe in terms of the folders and files that are on disk, this is now in terms of the specific functions, in this case, Python functions in the code and changes to variables. So this both an advantage, and maybe also a difficulty with this approach is that you get a lot of fine-grained provenance, so when you think of a script that does a certain job, well, it does it using loops, using if-then-else, using function calls, using variables, and all of that good stuff, or all of that detail stuff is now available for you through the noWorkflow trace. OK? So our goal was to say, "Okay, well how about if we were to combine these different things?" We have the low level, in some sense, you know, code-oriented, script-oriented, code-oriented model of retrospective provenance, and we have the YesWorkflow model which is more conceptual and maybe you don't even have a script. But in this case we have both, and we wanted to put them together and see what we get. So this is what we're gonna explain in the remainder. So again, here, we have the YesWorkflow side of the same script, and I've already talked about it. You have these annotations, basically you put these in and out annotations in your script, and you connect them to those steps or code blocks, and then you get a diagram for free once you've wired it up correctly. And this, I also indicated previously, you can have a process view or a data view for free once you've created the workflow view first. And now, what are the kinds of questions that you can answer using this? So if you use YesWorkflow alone, without noWorkflow, without retrospective provenance, just the prospective stuff, you can already ask questions about data dependencies. So for example, you could say, what is the lineage of corrected_image? So if you have a corrected image artifact, you could say, OK, well, what is upstream of that? What are the things that might have influenced this or what are the things, what are the data items and maybe steps, from which this data could have been possibly derived? Because if you can't get to it, this seems to indicate that they're independent; and if you can get to it, it at least suggests that they may be dependent. So in this particular case, if you want to look at corrected_image, you can say, OK, compute everything from corrected_image upwards in my model. And this gives you sort of the specialized family history, just this particular part of the family. Think of it just on the mother's side or just on the father's side, right? So you're cutting out a lot of the stuff that maybe you're not interested in. If you want to know the lineage of your father or your mother, right, you get us a different graph. And this is what's happening here. If you're only interested in one part on the left or on the right, a certain other part goes out the window. You're saying, you know, I really want to focus on this particular aspect. So you can do this already with YesWorkflow. So you can write queries against these models, which is something that we're gonna exercise as part of the project. OK, so we get a smaller graph. Now, again, what was the goal with hours of collaboration here? It was to say, all right, so we have on the left, we have this conceptual workflow model; and on the right, we have a runtime trace that the noWorkflow system gives us. So in addition to maybe the files and the metadata that is deposited on disk or that's written to disk, maybe there's even log file information, there's various kinds of retrospective provenance that we could use. But in this particular case, since we have a Python script, we can use the noWorkflow system to give us this very fine-grained code-oriented provenance. And the goal for us was to see — can we get some value out of connecting these two kinds of provenance? Because the prospective model on the left may not have runtime information, although we've seen a little bit of that we can get for free using file and folder names. But there might be more that we want to know, and maybe we can't get that directly, so we want to maybe use the retrospective provenance information provided by noWorkflow. Conversely, the noWorkflow people should be interested in this as well because they say, well, our code-oriented view could be sort of refactored, reorganized into a more conceptual view if we built this bridge between those two worlds or these two models. And this is what we did. And to remind you of the bridge, at the very conceptual level, this bridge is something that, in a workflow system might already exist for free. So if instead of using a script, you would use a workflow system, then you have your workflow diagram on top, and then the execution of the workflow creates in a fairly obvious manner sort of an image or instances of that conceptual workflow as part of the problem's trace. So, in workflow-land on top, you have prospective provenance. If you use a workflow system you kind of get that for free. And then the retrospective provenance, so the traces, you then can also often get for free in a workflow system because the system often has mechanisms to record this. But if you don't use a workflow system, if you use a script, you'll have to find other ways to get those two levels built and then also to get them connected. And the connection can be a little bit of a headache depending on how fine-grained you want to do this and what exactly you want to do with it. OK. I should also mention since I talked earlier about the PROV model, the W3C PROV model, I want to point out that the provenance model, the standard provenance model, both OPM, the earlier standard, and then W3C PROV, both don't talk about workflows. They really talk just about retrospective provenance. So in another one of these projects called DataONE, we have extended the W3C PROV model to not only deal with retrospective provenance, which is where the W3C model really focuses on; but also attached to it a layer called, for workflow-land, basically for prospective provenance. So the ProvONE model, that's sort of a hybrid between using W3C PROV in the context of the DataONE project. That's why it's called ProvONE, so there's a little history right there. W3C PROV standard extended for DataONE use case where we have scientific workflows. This has been developed to allow this bridge building.