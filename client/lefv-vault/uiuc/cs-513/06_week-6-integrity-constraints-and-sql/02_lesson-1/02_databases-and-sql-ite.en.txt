[SOUND] We're going to run SQL lite, and then give the name of the data base we're going to use. So let's see whether we can run this,
SQLite survey.db. There it is says sqlite this is particular
version I have installed 3.8 and to help for usage hints why not? So .help, these dot commands
are self directives that SQLite command line directly understand. Again this maybe an advantage
of using a tool from the command line over using the GUI. Or a Firefox plugin often plugin or the GUIs may be easier at
first to get to know things. But then once you know your way around the
command line is actually very powerful and has maybe some additional functions
that the GUI maybe hides from you. So if I run help I see there's a lot
of kind of commands available here. I need to scroll a little bit, so some of
these we're going to use to help us Is command and
there's other of these commands. Again, you see they all start with a dot. And these are the sort of specific SQLite,
specific directives to do certain things. To load a file,
to change how results are displayed and so on but
the proper SQL is the dot command. So let's have first a look
maybe what's in the database, there is a command called schema I think,
.schema show the create statements and if the table is specified only sort
of table matching this pattern. Let's just say .schema, start
the SQLite with the survey db I want to get an idea of what's In the database. I say .schema, I say okay there's four
tables, Person table, Site table, Visited table and Survey table. Every table has a bunch of columns, and
we see the data type of the column. So we see the person table has
a person ID which is text or string or var character in other SQL dialects. There's a personal field and
the family field. We don't really quite know what that
means right now, but we'll find out. There's a site table, recite name,
latitude and longitude. These are typical friends of the grill
columns that can get confused. There's often data quality issues, lat long can sometimes be
flipped in your data set. Or they're off by 90 degrees or
180, sine errors and so on. Endless source of fun. And sort of a Visited table and
a Survey table. So okay, so we see the data is there. And let's have a look. If I look here in our website, we can also
look at what's supposedly in the table. So we'll confirm that in a moment. So there's a person table that has an ID,
personal, and family. So this naming of the columns,
I don't think is particularly fortunate. I guess this means family name,
and this means maybe first name. First and last name would be
maybe a more common way or surname and given name and yeah. All right, so be it. The site information. Sites have some sort of identifier,
DR-1, DR-3, MSK-4. They have a location. Lat, long, anybody can plug that into
Google Maps or something similar and see where that is. I don't know whether
they're interesting places. There's a visited table that says, okay, it has a timestamp when
a site was visited. There's an ID, we don't quite know yet
where that ID comes from. But we see the site id here being used. And then, there's timestamps, and
sometimes there isn't a timestamp, which makes it all sort of interesting for
queries. The surveys then, the actual data
that was measured, so maybe. This seems to indicate your
connection between the visitor table. Let's say there's and ID 619 and over here at the survey table
there's another ID 619. So that seems to correlate,
link these two together. So this site information or
this measurement was taken at that side. So this is like a foreign key
as we heard about before. So dyer was measuring a quantity. What quantity did he or she measure? Radiation, that's probably
what rad stands for. And then there's an actual value. So at a certain site,
a person was measuring a quantity and
recording a certain value, so that seems to be what's
in that simple database. Yeah, okay, so there's another command called .tables, which really is in a way more condensed. It just tells us what tables there are and
you've seen schema tells us not only what tables there
are but how they were created. So this gives us more detail. If we want to change how
SQL represents answers, we can use one of these commands. Let's first not use this command and then see what happens if I
just write a simple query. So let's maybe say,
I want to say select * from person. And I'm going to be a little bit lazy, we're just going to say just give me
everything that is in a person table. And I as I is usually in SQL I put
a semi colon at the end of my query. So I say select stuff from person, hit Enter and
then you see I get these answers. They're not exactly pretty. There's this vertical bar as a separator,
there's also no header line, yeah. Which is why we want to use these two
directives here we want to say well, can you please switch to column modes so that columns are aligned not
like this ugly like that, yeah? And also headers would be nice if I had
a header so I know what I'm looking at. We're going to do that let's
just put switch header on and if I run my query again
select stuff from person. At least there is a header but
it's still not nicely aligned so I need the other command, say column on,
or actually just column mode column. And if I now run my query again,
so let's start *from person;, now this looks like a table. Yeah, now I have the idea
how my table looks like. Now if I'm not interested in certain
columns I can either select or specify instead of star I specify
what interests me in particular. So I could say for example select
family comma personal from person so I only get I first get the last name,
actually. Look at this, I first get the Dyer,
Pabodie, Lake, yata yata, and then personal. And I don't get the id, okay? So think of this as a personal id,
the first column is a personal id, and then first name, last name,
or last name, first name. This case, I guess first name,
last name, yeah? But I want the last name first, and
then the first name, okay, here we go. We also notice that they're not ordered,
yeah. Something we're going to look at later. I think this is here, but there is statement called order by and
that's we ordered. Lets give it a try actually. FROM Person order by, let's say, family. A-ha, you see now it's
ordered by family name. In this case,
the family name does the job. But if there was multiple people
with the same family name, then we would maybe secondarily
sort it by first name then I would write the, second column
there as well by which I sort. This case again there's
no difference because, already sorting by family name
always sorts everything, yeah? Okay, you see also that case,
doesn't matter so I sometimes write select and from lower
case get exactly the same answer. Or if you prefer to write upper
case to show you what is SQL and what is part of the schema
that's also nice. So now you see SELECT, FROM and
ORDER BY are SQL keywords. So I put them in uppercase, and
the rest is from the database schema. Family and personal are column names,
or attribute names. Person is a table name. And again, family and personal, again,
column names or header names, if you like. All right, so far so good. And again, if you're totally crazy here
with your case, low case, upper case yeah. This is hardly readable. This is just to illustrate the point
that case doesn't matter, right? I don't know whether anybody
can actually read this. This looks it's interesting
how mixing lower and upper case mixed things very hard to read
but it still works, yeah, all right. So SQL with respect to the query
statements is case insensitive [COUGH] of course when it comes to the data
that is case sensitive here. You have the role that says
Dyer with the capital D and then another role with
dyer with a lower case. Those would be two different values. Okay we did this select star from person. When you're working in the shell,
you sometimes get this funny thing select star,
from person, yeah but you have to complete,
the statement with a semicolon. So you can enter nicely end
the long statements this way. Okay, you could repeat things, I don't know whether anybody would
want to do that but you can. Keeps twice the same column or
in this case three times the same column. Not very exciting select from person,
done, okay. Let's look at the next sorting and
removing duplicates. We already did that. Now I just want to make one quick
connection of course here we're at the level of duplicates
at the level of SQL. But recall that earlier on we
spent quite a bit of effort with Open Refine through find
duplicates in the table. When two strings are really just
detecting variants of one another, maybe representing the same menu,
the same city, the same street name or something like that. So when we work with a database here for
our data, quality purposes that are clean
purposes at this point. We have to have these things done
there's very limited functionality. There's some functionality in SQL but limited to deal with irregular expressions
and things like that that's we should have done this before before we got
our data into the database. All right, so
we can go to the survey table. Okay so schema survey, there's a table. Okay, It has these various columns taken,
person, quantity, reading. And if you wanted to see what
quantities are showing up in our table. At all,
I could say select quant from survey. Survey is a table here. The name survey is kind of overloaded,
there's a survey database, and there's a survey table
in the survey database. All right, now, oops, rad sal, rad sal,
maybe rad stands for, you know, hopefully there's meta data available that
stands for radiation, maybe salinity. Temp is probably temperature. But look at that,
lots of copies of the same stuff. What's going on? So where did the copies come from? If I just do a complete dump, if you like, of the survey table, yeah, then I see
there's a bunch of things in there. And if I now only project
on the third column, that's what that statement was doing,
there's a rad, there's a sal, there's another rad,
another salinity, and so on. So when I just say,
give me the third column, and I say nothing else, I shouldn't be too
surprised that SQL gives me duplicates. So, SQL, by default, doesn't give you a set semantics
like the Steel view we saw before. It was a question on which
order these answers returned. Well, the order, it doesn't matter. It's really a set. Here, SQL, and sometimes the order comes out in
the way the table is maybe processed. And then, also, duplicates are produced. So, you have to get rid of those
duplicates explicitly if you, if they bother you if
that's what you want to do. So, lets see what here our
tutorial proposes, it says, well how about you say SELECT DISTINCT,
okay? So that was the quant column, right? And then we could say, Distinct. And there's really only
three distinct values, okay? Now we could have done, why is it maybe useful to see
how many Quant values there are? I could for example count them
to something we really going to look at later but you see there's
21 rows but only 3 distinct values. So sometimes you just want to
report the non-distinct values maybe for
purposes of counting for example. All because the duplicate
doesn't bother you. Maybe there's reason. There's actually extra effort
to remove the duplicates and find out that there's three values, right? Because as I showed before,
if you look at the complete table, yeah, you just do a table scan,
you just output what you find. Apart from the fact that its
maybe a very large relation with our net its a very simple operation. You just run through. No extra work. But keeping check of how many
distinct values there are, is a little bit extra work that's why this
is distinct is a sort of separate feature. Okay, you can also look at distinct
combinations so if you look at. Where was something taken, at what site? Was a quantity taken from the survey, you can do it like so. And SELECT DISTINCT taken and
quantity from survey. And maybe if I wanted to know. If I were to remove the distinct here,
yeah. Then possibly I get duplicates again here,
let's see what I can spot one, I actually don't see one right now. Okay, but the point is really
the distinct applies can also apply to multiple attributes, yeah, okay. The order by I mentioned before, so we can order the person table,
the entries in the person table. For example by the ID of first name or
last name. We did this already. So, let's maybe do this variant because
the other one we already did before. So, we go to the person table, we want
to order them by id, so by person id but descending as opposed to ascending,
which is the default. So we see first is roe then there is
pb then there lake, there's dyer and there's danforth. But let's say, okay actually we
want to sort them by family name. So, So instead of order by id, we say order
by family name, yeah, descending. So we see, first comes Roerich then
Pabodie, Lake, Dyer and Danforth. In this case it might actually be the same
as the ID, but that's coincidence, right? The ID could be a number and
might be very different. Yeah, so we see we're ordering
here by the third column. Just to see a different variant
let's order by the first name. Descending, now we see Anderson is last. If you remove the descending It'll sort
it actually ascending and Frank, Frank. Notice this,
you see how there's two Frank's but the Pabodie Frank comes before
the Danforth Frank right? So maybe we want to sort it by
first name and then by family name. And now you see Danforth
is now first okay? So you got a lot of power there
with fairly simple statements. Or you can mix even
things like here is for example you want to go from the survey
record, the survey database. You order by taken, when was it taken, or rather not when was it taken but
where was it taken, right? The ID of the station, or
the ID of the measurement. This is something actually by
just looking at the data so far. It's not obvious. So we would have to look at the
documentation or metadata again so we can make the taken attribute ascending but
the person descending, okay? So, let's see whether
there's any example of this. Yeah, so here you see 734 for
example this pb but there's also lake. The name of the person is lake,
somewhat surprisingly. But because it's this ending,
right, pb comes before lake. I don't think,
well do you want to see that? Okay let's just put it there. Let's make a variation. Let's make person ascending and
taken descending, yeah. And then again you could again
look at the table now and confirm that this indeed happened. And there's also when
you do this one first, then this would be the column
by which you sort first. And then this one will be subsequent. There's also other variants. You could say first sort by this and
then sort by taken. Okay, seems at first a little boring, but remember that a lot of the benefit
that people got out of databases for a long time is also these
sort of different reports. Depending on how your
write your queries and how you sort your results there's
certain things that jump out at you. So this is your poor mans
data analytics if you like. Being able to write such queries. [MUSIC]