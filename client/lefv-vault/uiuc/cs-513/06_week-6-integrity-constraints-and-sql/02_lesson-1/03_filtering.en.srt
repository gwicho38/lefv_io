1
00:00:00,090 --> 00:00:08,703
[MUSIC]

2
00:00:08,703 --> 00:00:13,378
So what we mean by filtering is
actually quite a bit different from

3
00:00:13,378 --> 00:00:17,280
what we saw earlier from
the data log filter.

4
00:00:17,280 --> 00:00:21,260
That one was really just a very
high level switch in that system.

5
00:00:21,260 --> 00:00:24,110
Here, filtering is really
the way we think of it.

6
00:00:24,110 --> 00:00:27,430
We run a query,
we get a table as an answer.

7
00:00:27,430 --> 00:00:30,550
But in the table,
maybe only certain roles you want to keep.

8
00:00:31,730 --> 00:00:33,589
And this is the where clause.

9
00:00:33,589 --> 00:00:36,714
Okay, so for example, if we run the.

10
00:00:36,714 --> 00:00:39,127
This is a table, want to see.

11
00:00:39,127 --> 00:00:44,369
Select * from the visited table, visited.

12
00:00:44,369 --> 00:00:45,470
Let's see what's in there.

13
00:00:45,470 --> 00:00:47,140
Okay, that's the visited table.

14
00:00:47,140 --> 00:00:52,946
But maybe you're interested in only one of
the sites, say DR-1 as in th example here.

15
00:00:52,946 --> 00:00:55,324
Then we would say where.

16
00:00:55,324 --> 00:01:00,259
Okay, I'm going to highlight again
the SQL keywords to make it clear.

17
00:01:00,259 --> 00:01:03,473
So this is where clause
in SQL where I can say,

18
00:01:03,473 --> 00:01:06,360
I can specify now a condition on the row.

19
00:01:06,360 --> 00:01:10,618
These conditions are very similar to
the conditions we have in our data log

20
00:01:10,618 --> 00:01:11,656
rule in the body.

21
00:01:11,656 --> 00:01:15,655
We'll have a constraint that this
equals that, that's greater than this,

22
00:01:15,655 --> 00:01:17,016
this is not equal to that.

23
00:01:17,016 --> 00:01:22,800
So here we want to say okay, we want to
say maybe that the site equals DR1.

24
00:01:22,800 --> 00:01:26,480
And then we only get the DL1 tuples.

25
00:01:26,480 --> 00:01:31,160
Remember the story about
the case insensitivity?

26
00:01:31,160 --> 00:01:33,380
Well, if I put DR1 here, I get nothing.

27
00:01:34,600 --> 00:01:38,270
Because of course, the selection in here,
the condition, where a side equals this,

28
00:01:38,270 --> 00:01:39,960
is case sensitive.

29
00:01:39,960 --> 00:01:42,490
We're looking at a particular data value,
right?

30
00:01:42,490 --> 00:01:47,450
So this really makes a difference,
whereas it doesn't

31
00:01:47,450 --> 00:01:51,650
make a different whether I write select
from where uppercase or lowercase.

32
00:01:51,650 --> 00:01:53,370
That does not make a difference, okay?

33
00:01:54,570 --> 00:01:57,159
All right, and so here's a visual
representation of what's happening.

34
00:01:57,159 --> 00:02:01,135
We can think of the system going
through the table, row by row and

35
00:02:01,135 --> 00:02:05,628
checking whether the condition,
the where clause, is satisfied, and

36
00:02:05,628 --> 00:02:07,560
if it is, you keep the result.

37
00:02:08,610 --> 00:02:14,435
And then there's actually another feature,
it's a projection here.

38
00:02:14,435 --> 00:02:15,377
Let's look at this.

39
00:02:15,377 --> 00:02:19,369
So here we said select * from
visited where the site is this.

40
00:02:19,369 --> 00:02:24,030
So we want to sort of now we're drilling
down, we're looking only at this site.

41
00:02:24,030 --> 00:02:27,420
But maybe we only want the id
instead of the whole table.

42
00:02:27,420 --> 00:02:28,850
You see we get three columns here.

43
00:02:30,480 --> 00:02:31,710
Three rows and three columns.

44
00:02:31,710 --> 00:02:34,190
Maybe we only interested in the id.

45
00:02:34,190 --> 00:02:37,900
So we would just say select id from
this and now we get this answer.

46
00:02:39,170 --> 00:02:41,490
So in a way first we go
through table row by row.

47
00:02:43,100 --> 00:02:49,030
And the where clause tells us which row
to keep and which row to throw out.

48
00:02:49,030 --> 00:02:52,340
And when we're done with that, we saw
well which column should I focus on?

49
00:02:52,340 --> 00:02:55,050
And that's what that select id is for.

50
00:02:56,380 --> 00:02:57,940
Again, so there's a lot going on.

51
00:02:57,940 --> 00:02:59,670
Again, it's a little
bit of a crash course.

52
00:02:59,670 --> 00:03:01,800
It's either very boring or

53
00:03:01,800 --> 00:03:05,659
very challenging for you, depending
on whether you do or don't know this.

54
00:03:07,260 --> 00:03:11,230
So but this is very nice that

55
00:03:11,230 --> 00:03:15,800
we see here that the kind of tool phases
of how the scale statement is executed.

56
00:03:15,800 --> 00:03:21,090
So first with with the where statement
here which filters the rows.

57
00:03:21,090 --> 00:03:24,410
And the ones were down there,
the select statement,

58
00:03:24,410 --> 00:03:28,260
which really should be called project
because we're projecting on a column.

59
00:03:28,260 --> 00:03:30,950
This is rather unfortunate
terminology of SQL here.

60
00:03:30,950 --> 00:03:31,480
It's a projection.

61
00:03:31,480 --> 00:03:34,954
We're projecting only on the first column,
throwing away the second and

62
00:03:34,954 --> 00:03:36,500
the fifth column.

63
00:03:36,500 --> 00:03:38,400
And that's how we arrive at this result.

64
00:03:38,400 --> 00:03:42,975
So this is really critical that you get
a good understanding of how a basic SQL

65
00:03:42,975 --> 00:03:45,204
query works like select from where.

66
00:03:45,204 --> 00:03:50,059
You can then put the condition in
the where clause that selects the rows can

67
00:03:50,059 --> 00:03:53,280
be much more complicated
than just an equality.

68
00:03:53,280 --> 00:03:57,160
You can say for example well I
want the site to be this, but

69
00:03:57,160 --> 00:04:00,890
the date to be less than that.

70
00:04:00,890 --> 00:04:04,180
And since we use an ISO date,
it actually works.

71
00:04:04,180 --> 00:04:05,740
The normal comparison works here,

72
00:04:05,740 --> 00:04:08,860
even the string comparison
will work here for dates.

73
00:04:08,860 --> 00:04:12,810
Now if you compare dates you have to be
very careful whether you compare strings,

74
00:04:12,810 --> 00:04:16,460
then they better be
an isoformic which just works.

75
00:04:16,460 --> 00:04:18,638
Or if they're enough strings,

76
00:04:18,638 --> 00:04:23,731
then hopefully you use the whatever
built in support for comparing dates.

77
00:04:23,731 --> 00:04:27,536
But here,
again we go into the visitor table,

78
00:04:27,536 --> 00:04:33,012
we're focusing on the side,
the R1 and also we only keep the row.

79
00:04:33,012 --> 00:04:39,451
If it was done before January 1st, 1930.

80
00:04:39,451 --> 00:04:43,169
And sure enough we got 1927 dates here.

81
00:04:43,169 --> 00:04:48,806
If I were to remove the dated constraint,

82
00:04:48,806 --> 00:04:53,808
I get also a third row with 1932.

83
00:04:53,808 --> 00:04:57,770
If the input table format is
sort of messed up or dirty,

84
00:04:57,770 --> 00:05:02,435
then a scale will be very unhappy
in giving you the wrong result.

85
00:05:02,435 --> 00:05:07,196
So that's why with a typical data cleaning
pipeline, you would first have done

86
00:05:07,196 --> 00:05:11,816
something like open refine or maybe
regular expression based replacement,

87
00:05:11,816 --> 00:05:15,720
matching and replacement,
otherwise you're in trouble.

88
00:05:15,720 --> 00:05:18,041
In this particular case,
is this a string comparison?

89
00:05:18,041 --> 00:05:23,431
It works because the ISO standard
was carefully chosen to put year

90
00:05:23,431 --> 00:05:30,250
then month then day, so that a regular
string comparison will get the job done.

91
00:05:30,250 --> 00:05:32,390
If you use any of the other date formats,

92
00:05:32,390 --> 00:05:34,790
you could write special
code that compares them.

93
00:05:34,790 --> 00:05:39,750
But since pretty much any system has
a string comparison function built in,

94
00:05:39,750 --> 00:05:44,957
why not choose a representation so that
it works for free, in a way, for dates.

95
00:05:44,957 --> 00:05:49,064
I'm sure one of the rationales
why the ISO standards

96
00:05:49,064 --> 00:05:52,154
organization has chosen that format.

97
00:05:52,154 --> 00:06:02,542
[MUSIC]

98
00:06:02,542 --> 00:06:05,539
[SOUND]