1
00:00:00,000 --> 00:00:08,125
[MUSIC]

2
00:00:08,125 --> 00:00:12,970
So let's go to SQLite, to the sub
folder SQLite, and we open a shell,

3
00:00:12,970 --> 00:00:16,586
again you might do this
differently in your system,

4
00:00:16,586 --> 00:00:21,868
you might want to use a terminal window,
depending on what systems you have.

5
00:00:21,868 --> 00:00:27,310
So let's have an example, let's do
a simple recursive query from the SQL.

6
00:00:27,310 --> 00:00:30,021
So what we have,
let's start actually here with this view.

7
00:00:30,021 --> 00:00:35,984
Let's say we have a simple table
called org for organization and

8
00:00:35,984 --> 00:00:42,501
in the table, we have the name of
a person, so you see there's Alice,

9
00:00:42,501 --> 00:00:47,371
Bob, Cindy, Dave, Emma,
Fred, Gail, and Joe.

10
00:00:47,371 --> 00:00:51,591
And we have the height of a person,
maybe in centimeters.

11
00:00:52,760 --> 00:00:56,310
Those must be centimeters,
can't be inches, would be too large.

12
00:00:56,310 --> 00:01:01,390
And let's say every person has
a boss which is a foreign key

13
00:01:01,390 --> 00:01:07,220
constraint that goes
back to the table itself.

14
00:01:07,220 --> 00:01:10,930
So those of you who know databases
will find this very familiar.

15
00:01:10,930 --> 00:01:14,132
Those of you who don't,
let me just quickly explain this.

16
00:01:14,132 --> 00:01:19,164
So this references here says that boss is

17
00:01:19,164 --> 00:01:27,306
a foreign key that points back into
this table to the primary key.

18
00:01:27,306 --> 00:01:30,042
And if you have for
example a value of null,

19
00:01:30,042 --> 00:01:33,470
this indicates that Alice
doesn't have a boss.

20
00:01:33,470 --> 00:01:36,428
So apparently it looks like Alice
is the boss of a couple of people.

21
00:01:36,428 --> 00:01:40,890
So Bob, Cindy, for example work both for

22
00:01:40,890 --> 00:01:46,170
Alice, and Dave and Emma work for Bob.

23
00:01:46,170 --> 00:01:48,156
And Fred and Gail work for Cindy.

24
00:01:48,156 --> 00:01:49,640
And then there's also Joe who works for

25
00:01:49,640 --> 00:01:52,680
Jane which is interestingly
enough not in this table.

26
00:01:54,740 --> 00:01:57,660
So that would be actually integrity
violation that we could check for and

27
00:01:57,660 --> 00:01:58,389
that we could detect.

28
00:01:59,470 --> 00:02:03,240
Now let's say we want to do first,
we want to find out who works for

29
00:02:03,240 --> 00:02:05,650
Alice directly or indirectly.

30
00:02:05,650 --> 00:02:10,600
And this is something you need to
understand that in the relational algebra

31
00:02:10,600 --> 00:02:15,250
or in data log, without recursion or
in first order logic, we couldn't actually

32
00:02:15,250 --> 00:02:19,210
say this because we have to kind of
join a table over and over with itself.

33
00:02:19,210 --> 00:02:23,880
So we have to go for example,
if we want to know who works for Alice,

34
00:02:23,880 --> 00:02:28,090
we could kind of chase it back for
Alice, for example, Bob and Cindy works.

35
00:02:28,090 --> 00:02:28,730
But we're not done.

36
00:02:29,780 --> 00:02:33,880
So I mean, the simplest query we could
run is we just select basically the first

37
00:02:33,880 --> 00:02:39,150
column where this third column has Alice,
but then we could only one level

38
00:02:41,100 --> 00:02:46,470
and then with the answers, we'd have to
go in there again and keep doing this.

39
00:02:46,470 --> 00:02:49,980
And this sort of recursive process,
we'd traditionally can not do in SQL,

40
00:02:49,980 --> 00:02:52,640
but with this we can do it.

41
00:02:52,640 --> 00:02:54,360
So let's give this a try.

42
00:02:55,480 --> 00:02:57,006
Actually, what I'm going to
do maybe right away,

43
00:02:57,006 --> 00:02:59,760
what I'm going to show you
right away is the following.

44
00:02:59,760 --> 00:03:03,040
I'm going to show you this
with recursive definition.

45
00:03:03,040 --> 00:03:06,487
So with the recursive definition,
says okay,

46
00:03:06,487 --> 00:03:11,487
I'm going to define a new relation
called works_for_Alice(n) and

47
00:03:11,487 --> 00:03:15,620
n is the name, Yeah?

48
00:03:15,620 --> 00:03:20,590
And then I say AS, and
then I put the query.

49
00:03:20,590 --> 00:03:21,830
Okay, so what is this query.

50
00:03:21,830 --> 00:03:25,590
Well first of all, to kind of to bootstrap
this, this is one way to do this.

51
00:03:25,590 --> 00:03:26,920
I say Alice works for Alice.

52
00:03:27,920 --> 00:03:29,170
Okay?

53
00:03:29,170 --> 00:03:30,490
And then we do a union.

54
00:03:32,210 --> 00:03:36,830
Then we say okay, select from org and
works_for_alice, and

55
00:03:36,830 --> 00:03:40,420
see this is where the recursion is, okay?

56
00:03:40,420 --> 00:03:41,910
Maybe let me put this in a new line.

57
00:03:43,348 --> 00:03:48,640
So we're selecting the name from org,
which is our input table and

58
00:03:48,640 --> 00:03:51,480
then also for works_for_Alice,
so here's the recursion.

59
00:03:51,480 --> 00:03:56,480
We're defining, works_for_alice and
we're using works_for_alice, okay?

60
00:03:57,820 --> 00:03:59,630
And what is the joint condition?

61
00:03:59,630 --> 00:04:04,780
Here we say well, the organisation,
the boss is in the third column,

62
00:04:04,780 --> 00:04:11,565
so boss should be the same
as works_for_alice(n).

63
00:04:13,730 --> 00:04:18,160
So this basically, it's actually not
horribly clear to understand in SQL.

64
00:04:18,160 --> 00:04:21,770
If we write this in data log,
it's actually would be more clear so

65
00:04:21,770 --> 00:04:24,600
we can do a little exercises,
write this also in dialogue and

66
00:04:24,600 --> 00:04:26,246
in a moment just to see how that works.

67
00:04:26,246 --> 00:04:30,970
And then, So

68
00:04:30,970 --> 00:04:35,292
we've now define to recursive view and
for that recursive view for example for

69
00:04:35,292 --> 00:04:39,990
starters, let's just select everything,
let's see what's in there, okay?

70
00:04:39,990 --> 00:04:40,826
I'm going to do this.

71
00:04:42,572 --> 00:04:45,247
I'm going to create a shell,

72
00:04:45,247 --> 00:04:50,954
I don't know why it's just like this,
so I run SQLite 3.

73
00:04:50,954 --> 00:04:56,380
And I want to open this file here,
family SQL, okay?

74
00:04:56,380 --> 00:05:01,707
So I'm going to say read, you might
recall this from your sql tutorial,

75
00:05:01,707 --> 00:05:04,597
read family.sql and then we see aha,

76
00:05:04,597 --> 00:05:09,228
Alice, Bob, Cindy, Dave,
Emma, Fred and Gail up there.

77
00:05:11,858 --> 00:05:14,910
Let us just do this real quick for
data log.

78
00:05:17,180 --> 00:05:18,020
So we find this file.

79
00:05:18,020 --> 00:05:21,332
I'm just going to write it family DLV.

80
00:05:21,332 --> 00:05:22,470
I'm just going to create that.

81
00:05:23,940 --> 00:05:29,710
I'm going to hack this now into datalog,
okay?

82
00:05:29,710 --> 00:05:31,610
So how would we call these facts?

83
00:05:33,660 --> 00:05:35,400
Let me find a keyboard macro.

84
00:05:35,400 --> 00:05:38,240
Just so you see something else
that's a very powerful practical

85
00:05:38,240 --> 00:05:39,230
tool in data cleaning.

86
00:05:39,230 --> 00:05:42,013
If this is my dirty data table,
it's very dirty,

87
00:05:42,013 --> 00:05:45,780
it's written in SQL and
I want it to be in datalog.

88
00:05:45,780 --> 00:05:47,433
So maybe what I want to
do is the following.

89
00:05:47,433 --> 00:05:48,449
I'm going to do the following.

90
00:05:48,449 --> 00:05:53,940
I'm going to start recording a macro,
and how does that work?

91
00:05:53,940 --> 00:05:57,180
For example, I exercise ones, I show ones.

92
00:05:57,180 --> 00:06:01,668
What I want to do, for
example I want to replace all of that and

93
00:06:01,668 --> 00:06:04,884
I want to call it org and
I will go to the end.

94
00:06:04,884 --> 00:06:07,222
Then I delete the semicolon and
I put the period.

95
00:06:07,222 --> 00:06:10,060
Then I go to the beginning and
I go to the next line and I'm done.

96
00:06:10,060 --> 00:06:14,340
Now, I've defined a keyboard macro and

97
00:06:14,340 --> 00:06:16,829
I can execute it a number of times,
for example five times.

98
00:06:18,340 --> 00:06:20,710
So, these are all keyboard shortcuts,
okay?

99
00:06:20,710 --> 00:06:24,170
So I just execute it five times and
I need it two more times.

100
00:06:26,270 --> 00:06:29,760
Can be painful to learn this tool,
all the keystrokes.

101
00:06:29,760 --> 00:06:34,400
But once you have it,
it can be actually a power tool as well.

102
00:06:34,400 --> 00:06:37,834
So, it's null value,
I'm not sure how to deal with it.

103
00:06:37,834 --> 00:06:38,938
Let's use a lower case now.

104
00:06:38,938 --> 00:06:41,468
In datalog, in the datalog version,
we're using,

105
00:06:41,468 --> 00:06:45,480
there's not really a proper support for
null values, they haven't quite done it.

106
00:06:45,480 --> 00:06:47,270
So that's all we want, okay?

107
00:06:47,270 --> 00:06:50,380
So we've got our database table,
now in datalog.

108
00:06:50,380 --> 00:06:52,480
And now we want to run a query,
who works for Alice?

109
00:06:52,480 --> 00:06:55,825
So let's write a rule works for Alice.

110
00:06:58,331 --> 00:07:02,317
And then look, of course,
we use a variable N if.

111
00:07:02,317 --> 00:07:03,557
What's the base case?

112
00:07:03,557 --> 00:07:08,684
So here, you see we have
basically a base case in SQL and

113
00:07:08,684 --> 00:07:11,820
then we have the recursive view.

114
00:07:11,820 --> 00:07:16,766
So and datalog is actually kind of simple,
so initially maybe you want to say

115
00:07:16,766 --> 00:07:21,620
that Alice works for Alice,
that's kind of the base case.

116
00:07:21,620 --> 00:07:24,290
You can't make it any simpler than that,
can you?

117
00:07:24,290 --> 00:07:30,005
And now, the recursive case will say okay,
well somebody with a name N works for

118
00:07:30,005 --> 00:07:36,836
Alice if, Let's see,

119
00:07:39,599 --> 00:07:45,015
So somehow we need to get org, N,

120
00:07:48,912 --> 00:07:50,815
X, okay, so we have to do that.

121
00:07:54,440 --> 00:07:58,600
And works_for_alice(X).

122
00:08:00,310 --> 00:08:01,290
Okay, let's think about that.

123
00:08:01,290 --> 00:08:05,810
So if X works for Alice, yeah.

124
00:08:05,810 --> 00:08:07,570
Maybe we should give a schema,

125
00:08:07,570 --> 00:08:13,080
it's always a good practice to put
metadata wherever you work with data.

126
00:08:13,080 --> 00:08:21,310
So org is Employee,
that's what Height Height,

127
00:08:21,310 --> 00:08:27,790
I'm going to write this,
in centimeter, and then Boss, okay?

128
00:08:27,790 --> 00:08:29,480
That's all schema.

129
00:08:29,480 --> 00:08:35,080
So maybe we should say,
let's call this variable B for Boss,

130
00:08:35,080 --> 00:08:39,970
let's call this variable E for
employee and then this is the employee E.

131
00:08:41,630 --> 00:08:48,850
And so if B works for Alice and B is the
boss of E, then E also works for Alice.

132
00:08:50,140 --> 00:08:51,550
Fair enough, kind of simple, right?

133
00:08:51,550 --> 00:08:56,550
Once, like everything in life,
once you have it, life is good and simple.

134
00:08:56,550 --> 00:09:00,130
I'm going to write this even in one
line just to show you how neat and

135
00:09:00,130 --> 00:09:02,102
elegant life can be.

136
00:09:02,102 --> 00:09:10,095
Can even make this a little bit more self
explanatory and then we should be happy.

137
00:09:10,095 --> 00:09:14,718
So this is why I like also

138
00:09:14,718 --> 00:09:20,820
teaching data log because the the ideal
is much more evident from these.

139
00:09:20,820 --> 00:09:25,160
You still, in real life,
need to know SQL, because in some sense,

140
00:09:25,160 --> 00:09:26,290
it's much more powerful.

141
00:09:26,290 --> 00:09:29,170
It has all these aggregations and
group bys and nesting and

142
00:09:29,170 --> 00:09:31,940
all of that, which are kind of
painful to do in this language.

143
00:09:31,940 --> 00:09:33,040
But to get the idea,

144
00:09:33,040 --> 00:09:37,480
what we're doing, we're recursively
defining a relationship here.

145
00:09:37,480 --> 00:09:42,470
Works for Alice, in terms of
the organization or [org chart relation,

146
00:09:42,470 --> 00:09:44,010
this is hard to beat.

147
00:09:44,010 --> 00:09:45,920
Can't make it much simpler than that.

148
00:09:45,920 --> 00:09:50,802
So here's,
it's called a recursive view, and

149
00:09:50,802 --> 00:09:54,263
then we have here, the base case,

150
00:09:59,730 --> 00:10:03,029
We could also make a variant of the base
case, maybe I'll show that in a moment.

151
00:10:05,140 --> 00:10:11,340
And then let me just right it in this way,
and then I have here the recursion, right?

152
00:10:12,930 --> 00:10:18,130
And of course, there's also a join
between, do you want that join explicit?

153
00:10:18,130 --> 00:10:19,980
Everybody knows this by now, right?

154
00:10:19,980 --> 00:10:24,380
So if I wanted to make the join explicit,
I would say here, Boss1, Boss2, and

155
00:10:24,380 --> 00:10:31,930
then I would say somewhere in
this rule Boss1 equals Boss2.

156
00:10:31,930 --> 00:10:37,550
That's kind of the escalate way to do
it but then it feels like painful, and

157
00:10:37,550 --> 00:10:43,020
a little bit too verbal, so I'll just
put the Boss here, put the Boss there.

158
00:10:43,020 --> 00:10:46,830
And in this way a rule,
a data log rule resemble actually

159
00:10:46,830 --> 00:10:49,550
something that sometimes
called a query by example.

160
00:10:49,550 --> 00:10:54,680
Because if you think about it there
are some tools like Microsoft Access for

161
00:10:54,680 --> 00:10:57,700
example I think has sort
of a query by example mode.

162
00:10:57,700 --> 00:11:00,670
What's going on visually there is
very similar to what you do with

163
00:11:00,670 --> 00:11:03,440
the data log you really define a pattern.

164
00:11:03,440 --> 00:11:07,580
You say here Emp and here Emp must
be the same and here Boss and

165
00:11:07,580 --> 00:11:10,540
here Boss must be the same that
actually kind of very neat.

166
00:11:10,540 --> 00:11:17,270
So let's run this, again it like
to split this window that way.

167
00:11:17,270 --> 00:11:19,413
I don't like it that way, let's see.

168
00:11:23,136 --> 00:11:25,750
Whatever, okay side by side.

169
00:11:25,750 --> 00:11:30,440
Let's quit SQLite and lets see,
are we in the right directory?

170
00:11:30,440 --> 00:11:35,585
Yeah, we have a family.dlv file there and,
Right,

171
00:11:35,585 --> 00:11:37,640
we split it this way,
we kind of like it better that way.

172
00:11:37,640 --> 00:11:41,525
And now we call this dlv tool and

173
00:11:41,525 --> 00:11:46,890
say family.dlv and maybe we just want
to filter on the recursive view.

174
00:11:46,890 --> 00:11:53,076
So we say -filter=works.for _alice.

175
00:11:53,076 --> 00:11:59,860
Yep, we have a syntax error somewhere,
where is it, the quotes, okay.

176
00:12:01,040 --> 00:12:04,790
This particular data system does
like quotes, it wants double quotes.

177
00:12:04,790 --> 00:12:08,020
Okay, of course oops.

178
00:12:08,020 --> 00:12:11,140
So, what do we need to do here is we query
replace a single code with the double

179
00:12:11,140 --> 00:12:13,110
quotes, done.

180
00:12:15,960 --> 00:12:20,890
And now, we can do it again and
we see Alice,

181
00:12:20,890 --> 00:12:24,640
Bob, Cindy, Dave, Emma, Fred and
Gail all work for Alice.

182
00:12:24,640 --> 00:12:30,370
Also know that Joel and
Jane do not work for Alice, okay?

183
00:12:30,370 --> 00:12:34,320
So I think that's quite neat and
nice how we do this data log.

184
00:12:36,750 --> 00:12:39,260
All right, how would we find
out whether everybody works for

185
00:12:39,260 --> 00:12:40,840
Alice if we have an integrity
constraint memory?

186
00:12:40,840 --> 00:12:42,230
One more example while we're on it.

187
00:12:43,260 --> 00:12:44,550
A brief integrity constraint.

188
00:12:45,850 --> 00:12:49,430
Let's say you want to see,
maybe you have a company, and so

189
00:12:49,430 --> 00:12:52,910
everybody has to work for Alice.

190
00:12:52,910 --> 00:12:53,590
How would you do that?

191
00:12:54,690 --> 00:12:55,810
As a denial constraint.

192
00:12:57,470 --> 00:13:03,344
[SOUND] Find those Emp that don't work for
Alice.

193
00:13:03,344 --> 00:13:06,280
So that's not difficult to do.

194
00:13:06,280 --> 00:13:11,650
So in integrity concern violations,
this is just a convention.

195
00:13:11,650 --> 00:13:14,728
So we say go away there.

196
00:13:14,728 --> 00:13:19,894
integrity concern violation and e,

197
00:13:19,894 --> 00:13:26,900
maybe the employee that doesn't work for
Alice.

198
00:13:28,060 --> 00:13:29,400
Now we have a problem,
how do we right that?

199
00:13:31,190 --> 00:13:35,938
In a way we want to say not.

200
00:13:35,938 --> 00:13:42,000
Works_for_alice(Emp), is
there a problem with this?

201
00:13:42,000 --> 00:13:43,340
It looks pretty good.

202
00:13:44,430 --> 00:13:45,132
What's the problem with this?

203
00:13:49,147 --> 00:13:50,800
Let's run it, let's have a look.

204
00:13:52,790 --> 00:13:55,620
So I want to look at the integrity
concern violations, right?

205
00:13:55,620 --> 00:13:59,740
I see all_alice.

206
00:13:59,740 --> 00:14:01,562
It says the rule is not safe.

207
00:14:01,562 --> 00:14:04,127
Why is the rule not safe?

208
00:14:04,127 --> 00:14:09,723
So safety, as a reminder it says every
variable, whether it's in the head or

209
00:14:09,723 --> 00:14:14,250
in the body,
must also occur positively in the body.

210
00:14:14,250 --> 00:14:18,090
So we need a predicate
that gives us a bindings

211
00:14:18,090 --> 00:14:21,540
x I can iterate that if we have
to program this out in code.

212
00:14:21,540 --> 00:14:25,140
And did not have a database approach,
we would have to write and generate and

213
00:14:25,140 --> 00:14:28,250
iterate that runs over the employees,
a loop.

214
00:14:28,250 --> 00:14:32,914
So we want to say emp (E) let's say,
do it like this.

215
00:14:32,914 --> 00:14:38,850
So rename this to E but where do
we get the employee relation from.

216
00:14:38,850 --> 00:14:40,360
We don't have that right now.

217
00:14:40,360 --> 00:14:43,429
Well we can do this by defining,

218
00:14:43,429 --> 00:14:48,773
in practice we would probably
have such as a relation but

219
00:14:48,773 --> 00:14:56,589
here we're just going to define
it emp(E) :- org(E Either this,

220
00:14:59,087 --> 00:15:03,930
Or, That.

221
00:15:03,930 --> 00:15:07,330
If the employee shows up in the first or
third column, this is a union view, yeah,

222
00:15:07,330 --> 00:15:09,160
the sequence will be the union.

223
00:15:09,160 --> 00:15:10,280
So I think now we are in business.

224
00:15:10,280 --> 00:15:15,224
So we have defined what

225
00:15:15,224 --> 00:15:19,397
employees exist?

226
00:15:19,397 --> 00:15:21,520
And this is basically

227
00:15:24,150 --> 00:15:28,410
Union of Emp and Boss columns, right.

228
00:15:29,580 --> 00:15:30,460
That's what this is.

229
00:15:31,760 --> 00:15:33,760
All right so now, we should be business.

230
00:15:33,760 --> 00:15:37,410
Now, this variable e has a finite value.

231
00:15:37,410 --> 00:15:39,840
We know where to grab it from and

232
00:15:39,840 --> 00:15:44,570
now we can look whether
integral concern violation is.

233
00:15:46,090 --> 00:15:47,371
That everybody works for Alice.

234
00:15:49,250 --> 00:15:50,360
So let's go to the Shell.

235
00:15:51,360 --> 00:15:52,297
So we're going to run this again.

236
00:15:55,078 --> 00:16:01,190
So a certain mister Null, mister or miss
Null And Joe and Jane don't work for Alex.

237
00:16:01,190 --> 00:16:04,800
You see that null is not treated
especially considered in the normal value

238
00:16:04,800 --> 00:16:09,300
here by data look, okay.

239
00:16:09,300 --> 00:16:12,749
So in particular we've found Joe and
Jane so we can look what's going on.

240
00:16:12,749 --> 00:16:14,838
Do we have to move them
to another department?

241
00:16:14,838 --> 00:16:16,371
Do we have to fire them?

242
00:16:16,371 --> 00:16:20,973
Or maybe we have to abandon the constraint
that says everybody wants to work for

243
00:16:20,973 --> 00:16:21,889
Alice, okay.

244
00:16:21,889 --> 00:16:27,680
All right, so I think that this shows you
a nice set of simple example of recursion.

245
00:16:27,680 --> 00:16:31,482
Also one thing you see, you see the data
log since we have recursive views and

246
00:16:31,482 --> 00:16:32,384
very naturally.

247
00:16:32,384 --> 00:16:37,060
So we can also write in term
constraints that involve recursion.

248
00:16:37,060 --> 00:16:39,760
Not a big deal at all,
it's just like a regular view.

249
00:16:39,760 --> 00:16:43,667
It just so happens that it was
defined recursively, okay.

250
00:16:43,667 --> 00:16:46,340
So much for
data log let's switch back to SQL light.

251
00:16:48,110 --> 00:16:52,490
So here is our family in SQL.

252
00:16:54,070 --> 00:16:55,269
Let's look at this other query.

253
00:16:56,340 --> 00:16:59,830
Let's say we want to instead of
outputting who's working for

254
00:16:59,830 --> 00:17:01,670
Alice, let's do something more fancy.

255
00:17:01,670 --> 00:17:05,135
Let's do some aggregation to
some data analysis, okay.

256
00:17:05,135 --> 00:17:10,942
So what we want to do here is we want to
select the average height from org.

257
00:17:10,942 --> 00:17:13,549
Where the org name is in
the relation works for

258
00:17:13,549 --> 00:17:16,820
Alice which we just defined recursively.

259
00:17:16,820 --> 00:17:19,388
So we've recursively defined
who is working for Alice.

260
00:17:19,388 --> 00:17:25,195
So we got lots of joins right,
we go all the way down to hierarchy and

261
00:17:25,195 --> 00:17:29,440
now we're doing aggregation
on top of that.

262
00:17:29,440 --> 00:17:32,577
So we aggregate the height
from the org for

263
00:17:32,577 --> 00:17:38,145
those people who are in the recursive
view called works for Alice, okay.

264
00:17:38,145 --> 00:17:43,058
So a lot of stuff going on there, And

265
00:17:43,058 --> 00:17:47,025
so let's start our sqlite again.

266
00:17:47,025 --> 00:17:50,337
And let's say we're going to
read family.sql and

267
00:17:50,337 --> 00:17:54,375
it turns out because the select
statement is uncommented,

268
00:17:54,375 --> 00:17:58,630
we'll get the answer right
away just like before.

269
00:17:58,630 --> 00:18:02,590
174 here is your average.

270
00:18:03,650 --> 00:18:06,750
People work for Alice let's just
see whether how do we test that.

271
00:18:06,750 --> 00:18:09,560
Let's make some Joe and

272
00:18:09,560 --> 00:18:14,380
Jane don't work,so Joe work for
Jane and Joe is two meters.

273
00:18:15,630 --> 00:18:23,070
Let's see whether a change effects this,
okay.

274
00:18:24,910 --> 00:18:27,170
I'm not sure it might actually complain.

275
00:18:27,170 --> 00:18:30,870
Yeah, because we loaded it again.

276
00:18:30,870 --> 00:18:31,830
We didn't drop the table.

277
00:18:31,830 --> 00:18:37,050
So I think the simplest thing is let me
just quit this and just start it again.

278
00:18:39,430 --> 00:18:41,420
I mean we can fix this by
dropping the table, but

279
00:18:41,420 --> 00:18:42,870
I don't want to go there right now.

280
00:18:44,070 --> 00:18:46,010
And the average is still 175.

281
00:18:46,010 --> 00:18:50,020
That doesn't prove anything but

282
00:18:50,020 --> 00:18:55,690
it's a hint that maybe indeed our
average didn't include John and Jane.

283
00:18:55,690 --> 00:18:58,940
In contrast let's Gail life,
Gail works for

284
00:18:58,940 --> 00:19:03,860
Cindy and Cindy works for Alice,
so let's make Gail two meters.

285
00:19:03,860 --> 00:19:08,650
Let's make her three meters,
she's really large, tall I mean, okay.

286
00:19:08,650 --> 00:19:09,252
So let's try that.

287
00:19:16,254 --> 00:19:22,548
And now the average height of
the people working for Alice is 192.

288
00:19:22,548 --> 00:19:26,603
So that's three meter person gave a boost,
that's a giant right there.

289
00:19:26,603 --> 00:19:29,343
Okay, very good.

290
00:19:29,343 --> 00:19:34,125
That's two maybe one more query and

291
00:19:34,125 --> 00:19:37,800
this is the one here below.

292
00:19:42,550 --> 00:19:45,570
So this one else leave up here.

293
00:19:45,570 --> 00:19:47,154
The second query here is a.

294
00:19:54,304 --> 00:19:55,490
So what does this do?

295
00:19:58,060 --> 00:20:01,730
Just sort of plot
the hierarchy if you like.

296
00:20:02,810 --> 00:20:07,120
So what this is doing it defines
a recursive view called under_alice

297
00:20:07,120 --> 00:20:09,860
where we have a name and a level.

298
00:20:09,860 --> 00:20:14,880
So like how many levels down
is the employee below Alice?

299
00:20:14,880 --> 00:20:18,900
So maybe you initialize this,
you see the same pattern like here.

300
00:20:18,900 --> 00:20:22,200
You start with Alice as a base and
then you have a union.

301
00:20:22,200 --> 00:20:27,030
So again here you start with Alice and
then you have a union, actually union all.

302
00:20:27,030 --> 00:20:30,200
We can look at the,
what difference it makes.

303
00:20:31,420 --> 00:20:35,520
And then what do we do?

304
00:20:35,520 --> 00:20:42,200
So we select the name and then we
increase the level here in the output.

305
00:20:42,200 --> 00:20:46,690
And what I've done here we join the org
table which is our base table on what we

306
00:20:46,690 --> 00:20:48,594
should define recursive view.

307
00:20:48,594 --> 00:20:55,548
And we join it with the recursive view,
we join it.

308
00:20:55,548 --> 00:20:59,394
What was in the data log rule just
the same variable occurring twice,

309
00:20:59,394 --> 00:21:01,265
we have to be very explicit here.

310
00:21:01,265 --> 00:21:06,199
Yeah, so it's the boss and
the org table has the same value.

311
00:21:06,199 --> 00:21:10,634
Has the same person as the under_alice
recursive view that we're defining

312
00:21:10,634 --> 00:21:11,261
the name.

313
00:21:13,392 --> 00:21:20,190
And then we want to order this,
By the second.

314
00:21:21,280 --> 00:21:22,620
We order this by the second column.

315
00:21:24,040 --> 00:21:27,550
And then the level, so
we do some little trick,

316
00:21:27,550 --> 00:21:30,310
we do a little string processing trick.

317
00:21:30,310 --> 00:21:34,920
We take a number of dots which
is determined by the level.

318
00:21:34,920 --> 00:21:37,290
Okay, that's a little fanciness there.

319
00:21:38,330 --> 00:21:39,890
Let's see how that will work.

320
00:21:41,720 --> 00:21:47,090
So let's quit this and
restart and read it in again.

321
00:21:48,190 --> 00:21:50,570
So we still see our old
average that's from before.

322
00:21:50,570 --> 00:21:54,020
And now we see that Alice has Bob and

323
00:21:54,020 --> 00:21:58,360
Cindy working for them and
Dave and Ema has Bob.

324
00:22:00,280 --> 00:22:04,877
Bob has Dave and Ema working for him and
Cindy has Fred and Gail working for him.

325
00:22:04,877 --> 00:22:09,408
A kind of nice nifty little example there
that you see you can do such things

326
00:22:09,408 --> 00:22:10,160
in SQL.

327
00:22:10,160 --> 00:22:14,790
It's a little bit out there on the not
as typical SQL but you can do this.

328
00:22:14,790 --> 00:22:16,850
So to outpost an example as well.

329
00:22:20,030 --> 00:22:21,058
One more example before the break.

330
00:22:25,644 --> 00:22:27,723
So what's the other example
you want to look at?

331
00:22:31,344 --> 00:22:35,744
So let's look at what
briefly what this is.

332
00:22:35,744 --> 00:22:40,909
We don't need to go all into it.

333
00:22:40,909 --> 00:22:42,665
But we see there's
a little maths going on.

334
00:22:42,665 --> 00:22:47,554
Let's just see whether we get the big
structural going on towards on

335
00:22:47,554 --> 00:22:51,002
this class or
crazy that class for that matter.

336
00:22:51,002 --> 00:22:54,900
Let's see.

337
00:22:54,900 --> 00:22:58,830
So we start with somehow that we
start with some initialization values

338
00:22:58,830 --> 00:23:00,483
of -2 and -1.

339
00:23:00,483 --> 00:23:03,650
And then there's some selection,

340
00:23:03,650 --> 00:23:07,730
and it seems like we have some sort of
termination condition or some condition.

341
00:23:09,780 --> 00:23:13,120
Boy, this is just too much for me, okay?

342
00:23:13,120 --> 00:23:14,775
Let's just run it let's see what it is,
okay?

343
00:23:14,775 --> 00:23:16,099
I haven't tried this in a while.

344
00:23:18,900 --> 00:23:20,370
So let's see.

345
00:23:22,170 --> 00:23:26,820
Read mandelbrot which is the guy who
cannot amendend this, not the SQL but

346
00:23:26,820 --> 00:23:27,790
the maths behind it.

347
00:23:28,900 --> 00:23:29,400
Okay.

348
00:23:30,640 --> 00:23:36,670
So pretty fancy to make this your

349
00:23:36,670 --> 00:23:42,420
puzzle of the week to figure out why
is this working and what is this doing?

350
00:23:42,420 --> 00:23:44,950
So not so clear, okay.

351
00:23:44,950 --> 00:23:49,250
But let's do something and
that's really the final one here.

352
00:23:49,250 --> 00:23:54,559
Sudoku, okay,
anybody play Sudoku here occasionally?

353
00:23:56,150 --> 00:24:00,730
Okay, well maybe you can explain this
skill query then in the break to me.

354
00:24:00,730 --> 00:24:04,990
Okay, so
it's another WITH RECURSIVE query here and

355
00:24:07,630 --> 00:24:13,620
the input here is a linear
encoding of a Sudoku puzzle.

356
00:24:13,620 --> 00:24:19,252
So if you were breaking this down into,
so for matrix form basically the dots

357
00:24:19,252 --> 00:24:25,071
correspond to the values that you don't
get no to the digits from zero to nine.

358
00:24:25,071 --> 00:24:29,146
And the numbers that are there that's
your puzzle, those numbers are there.

359
00:24:29,146 --> 00:24:33,888
Let's see whether we get the hang of that,

360
00:24:33,888 --> 00:24:41,004
I guess somewhere down here in
this highly complex query that has

361
00:24:41,004 --> 00:24:46,170
recursion and
subqueries not exists in here.

362
00:24:46,170 --> 00:24:47,505
And somewhere here,

363
00:24:47,505 --> 00:24:52,187
you do some fancy arithmetics where
you access with a substring function.

364
00:24:52,187 --> 00:24:58,155
You access basically your board on which
you try to solve the constraint and,

365
00:25:02,104 --> 00:25:05,273
When the constraint is satisfied, or
not satisfied you return a result.

366
00:25:05,273 --> 00:25:10,310
And then not exist basically forces
it to try out other combinations.

367
00:25:12,200 --> 00:25:17,710
So yeah, alright let's have a look.

368
00:25:17,710 --> 00:25:21,720
Would be nice to have a better
visualization for this so

369
00:25:21,720 --> 00:25:24,880
you could actually see that
it does the job at hand.

370
00:25:26,590 --> 00:25:34,180
So you quit this one and
start this one and then we read.

371
00:25:35,660 --> 00:25:37,170
The Sudoku, okay.

372
00:25:37,170 --> 00:25:42,266
Okay you see that was a little bit
of a delay actually I apply for

373
00:25:42,266 --> 00:25:46,386
this program just putting
other things in there.

374
00:25:46,386 --> 00:25:50,780
It can take quite a while then actually
it's not super efficient as it

375
00:25:50,780 --> 00:25:55,268
constraints over but it's nice to see
that and I think you can do this.

376
00:25:55,268 --> 00:26:05,268
[MUSIC]