And now, we're gonna switch over to our, sort of, crash course, if you like, introduction to SQL, and in particular using SQLite. So, I'm gonna, first, motivate a little bit why we're doing this, and then work through some examples. So, why are we using database research results in general and SQLite maybe in particular? So there's a lot of work has been done in this area. I mean databases are really ubiquitous. They're out there. They're used in the real world a lot. There's not only the fact that these are used a lot in practice, but there's also again the theory behind it, which is, you could argue, just as valuable or similarly valuable. So, from conceptual modeling, database normalization, data integration, data cleaning, integrity constraints, repair - there's a lot of work there. So, taking a database person's view on this really gives us a lot of mileage. So, the world runs on databases. For those of you interested in more research you think it's also intellectually satisfying and gratifying, I think. There's a lot of interesting research you can still do. SQLite is a nice, fun system to work with. It's not for all purposes. It has a sort of a niche that it occupies, basically using SQLite sort of personally in your personal environment, rather than in a server setting and so we'll see more of that. So, I'm going back to a slide that I showed earlier in this course where we see different integrity constraint violations. We remember them. We've now actually worked with some of them, checked them and even repaired them automatically or generated all possible solutions. And so again, these are things that we cannot fix, for example, with a tool like OpenRefine. But once we have, I mean, some of them we might, like this one, date of birth, this column, right? This is part of, you can use regular expressions to match that, maybe translate it; in OpenRefine, you can cluster, you can detect duplicates. Yeah? We've done that in OpenRefine. But then if you have complex relationship where what's written in one table affects what's in the other table, or even functional dependencies like here. We need databases. So, this is what we already have been looking at. So uniqueness constraints, different representations. There's all these different kinds of errors that we might have to deal with. Databases are also ubiquitous. I don't know whether I've shown this before, but this is a snapshot here that's out there about, I guess, chocolate raisins, and you see it has SQL in it. Select stuff from equipment table where equipment ID equals four. Assuming this is an actual picture, stuff like this happens in practice and this just means that somebody when they're, you know, trying to pull out an ingredients list or something, or in this case equipment, this product may contain - what is it - residues of or produced in a facility that also processes nuts. Right? For people who have allergy to nuts, for example. Who knows what that message was? But instead of the message, we get the SQL query that should have probably retrieved the message. So, this is an actual snapshot. If I look at the snapshot here, this is taken by myself a while ago. And I went to website, and there's all these SQL error messages. That doesn't look like an advertisement for SQL, but it shows that a lot of the web. When we go to webpage, what's behind the web is often a database server. In this case, some application broke. We can nicely either blame it on the web server that interacts with a, maybe, database back end or some somewhere in between or, of course, the database itself might have a problem. It's hard to see from this who to point a finger at. Okay, so SQL is everywhere. SQLite is a rather unusual SQL database. It is a typically used databases, of course. You have a database server and then clients connect to the server and then lots of different users simultaneously can use the database and so on. SQLite, think of it more as your sort of personal database, so it's very different in terms of the architecture. But for our purposes in class, it's just fine. So there are situations where SQLite works really well. There's also examples where it doesn't work so well. But in embedded devices, internet of things. And also really this is, I think, an interesting different perspective. I'll say something about it in a moment, that you think of the underlying database format as an application file format, you know. You might all know or heard about things like XML and JSON and all these various exchange syntax. But then, if you work with the data, you're always left to work with the data in the application program. Maybe you have an XML parser. Maybe it ends up in an XML database, or you have a JSON parser. Easy to parse, but now you have an application that works with the data. If you decide to use SQLite for certain applications, you have a full-fledged database engine right there. So apparently, again, according to the advertisement, truth in advertisement, SQLite works across platforms on different systems, and you can then use it as a file format that has powerful query capabilities built in, query and analytical capabilities. So, if you look around on the website, you can see some sort of advertisement. I just thought, you know, whether you buy into this or not, it is a very convenient, little database that you can use for all purposes. I'll just want to point out a few quotes that I thought was interesting because there's in some sense sometimes also discussion, sort of the primacy of data versus code. You know, what's more important? Is the data more important? Is the code more important? Depends really on the kind of specific question that you have. But just to make you think about these things, I put a few quotes here. So there's a legendary book on software engineering called the "Mythical Man-Month" and it talks about how representations are the essence of programming. So, and the quote here specifically says, "Show me your flow charts and conceal your tables, and I shall continue to be mystified. Show me your tables, and I won't usually need your flowcharts; they will be obvious." So, in a way, this makes a point about, you know, code is all good and makes everything run, but it's often the data that you really need to have a good understanding of to really understand what's going on. Rob Pike in "Rules of Programming" has a similar quote here, "Data dominates. If you've chosen the right data structures and organized things well, the algorithms will almost always be self-evident. Data structures, not algorithms, are central to programming." Well, this is a strong statement. You know your algorithms prof might disagree and so, but it is an interesting perspective. And then another fellow who you may or may not agree with but I'll just put the quote here -- Linus Torvalds, Torvalds of Linux fame. He said, "Bad programmers worry about the code. Good programmers worry about data structures and their relationships." That was just to give you a little bit of different perspective on life, if nothing else. All right. So where is SQL found? Basically everywhere. In this room, there's probably at this moment, I bet, a dozen, 50 instances of SQLite running right now. Might be on your smart watch. It's suddenly on your smartphone. It's in your web browser that you use right now. It's everywhere. So you are running SQLite right now. Okay. So, that's good to know. So, check it out. This is some numbers from the creator of SQLite, but I don't think we need to get into this. For a little bit database system, it has actually quite powerful features. It has, of course, things like keys and indexes and even things like spatial indexes and so on. But it has limitations, too. 64-way joins normally, if as a human write your queries, 64 joins or 64-way joins are fairly large. But sometimes you have applications where queries are generated by a program, then this could actually be a real limitation. But, for our purposes, this is not gonna be so bad. So this would be also some system that I would encourage you to use in maybe in your project. So maybe you know already Postgres or mySQL or another database system, Oracle. But just to get another perspective, maybe even if you know another database system, you want to try this out in your project at the end. Okay. So let's look right into it. Oh, by the way, different date formats is something that's always an issue with data quality. Right? We know that dates can be represented in different ways. And when we consume data, we get big headaches about trying to align the data, get it into a canonical form. Dates are of course so important that SQLite also has different ways to expose, you know, print out, if you like, the date. So there's different formats. Another quote, Eric Busboom says "I proposed to my wife in SQLite. It's just that awesome." I don't know somebody's a little exaggerating, maybe. All right. You can also, if use Firefox as a browser, there's a plug-in for it. So I'm gonna use, in a moment, SQLite from the command line. Like, I like that kind of flexibility of the command line, but some of you might prefer to have, sort of, a more graphical user interface, and the nice thing is there's a plug-in for Firefox, in particular, there might be other for other browsers as well. So you can use SQLite from the browser. So I'll just walk you through a couple of screenshots. You would start by customizing your extensions, and hopefully you'll find a SQLite manager that you can search as an extension. You can edit. You might want to actually move it up there to your toolbar so that you have SQLite as a little Firefox extension there, ready for you. And then you have, you know, some nice icons that tell you a little bit what you can do. Maybe open a database, create new ones, run queries, and so on. So here's an example from a database that comes from an example from another, sort of, crash course that we gave on using SQLite. You can import, for example, CSV files. How do you get your data initially into a database? One way to do it is if you have a CSV file, comma separated values file. Something maybe you export from Excel, and say, okay, now I wanna work in a database with it. You can make it import that. You can also do this from the command line, you know. Maybe we will have an example of that as well. Once you have the data there, again in the Firefox browser, things look fairly as you would expect them. You have, for example, you see also through the color coding, you get a little extra features here with missing data and then given data and then sort of special, the row ID, numeric data, has a little different color. So you can work quite nicely with the system, so you can explore the different tables of this data; this particular database has maybe two different tables here. Number of tables is two. You can select a table. You see also here, yeah, because of the color coding, you see interesting. Get an overview of what's in your database. See the number of rows. And then you can run simple queries. So, for example, here we say, we run a simple SQL query. We'll do an example in a moment with another simple database. So much for advertisement for using the system, what we're gonna be using, and now we're gonna walk through an example that you can then also drill down further, so if offline you can work with that. There's an organization called Software Carpentry that tries to teach certain skills including programming but also database querying, data issues to the masses, if you like, to scientists who are not necessarily computer scientists or programmers. And so they have very nice material that we can make use of here for our purposes, and in particular, I'm gonna jump into this topic of using databases and SQL.