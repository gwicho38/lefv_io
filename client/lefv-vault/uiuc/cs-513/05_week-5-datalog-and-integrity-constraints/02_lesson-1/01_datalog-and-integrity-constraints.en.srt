1
00:00:00,000 --> 00:00:08,102
[MUSIC]

2
00:00:08,102 --> 00:00:10,080
DataLog and integrity constraints.

3
00:00:10,080 --> 00:00:13,430
I will just remind you of what we're
doing and then I will jump into repair.

4
00:00:13,430 --> 00:00:18,400
So our starting point here was that dirty
and clean data be viewed as consistent or

5
00:00:18,400 --> 00:00:19,480
inconsistent data.

6
00:00:19,480 --> 00:00:22,120
Again here, we have a sample data
set from on of the readings,

7
00:00:22,120 --> 00:00:24,570
the paper by Bertossi 2011.

8
00:00:24,570 --> 00:00:27,670
Among the most basic and most important
integrity constraints we have functional

9
00:00:27,670 --> 00:00:31,590
dependencies, also known as key
constraints in relational databases and

10
00:00:31,590 --> 00:00:34,530
also inclusion dependencies
which are related to referential

11
00:00:34,530 --> 00:00:39,440
integrity constraints, where a child
table, the foreign key of that Child Table

12
00:00:39,440 --> 00:00:43,750
references the Primary
key of the Parent Table.

13
00:00:43,750 --> 00:00:45,130
Okay, so we've looked at it before.

14
00:00:45,130 --> 00:00:50,420
We've also looked at how such constraints
can be modeled in logic rules,

15
00:00:50,420 --> 00:00:56,190
we found the logic notation to be a little
tricky at first and we learned about then

16
00:00:56,190 --> 00:01:01,570
alternative in some sense more practical
notation for applications called Datalog.

17
00:01:01,570 --> 00:01:05,630
And so we've seen that integrity
constraint violations can be modeled

18
00:01:05,630 --> 00:01:06,331
as queries.

19
00:01:06,331 --> 00:01:10,550
I want to say if I have
a student pupil xy and

20
00:01:10,550 --> 00:01:15,040
another student pupil xz,
and y and z are different,

21
00:01:15,040 --> 00:01:19,030
that's going to be a problem so, I speak
over integrity constraint violation, why?

22
00:01:19,030 --> 00:01:24,040
Because, originally we said that these two
that the first column should determine

23
00:01:24,040 --> 00:01:27,060
all the other columns, in this case
the second column there's only one.

24
00:01:27,060 --> 00:01:29,890
That really says that
the first column is a key or

25
00:01:29,890 --> 00:01:31,550
a primary key of this relationship.

26
00:01:31,550 --> 00:01:34,222
So whenever I see X, Y and I see X, Z,

27
00:01:34,222 --> 00:01:37,950
the only way this is possible
is that Y is equal to Z.

28
00:01:37,950 --> 00:01:39,750
We're looking basically at the same row.

29
00:01:39,750 --> 00:01:44,510
There cannot be two rows with the single
X and different sort of Y and Z values.

30
00:01:44,510 --> 00:01:48,022
And this is how you would write a test
rule that checks one of these integrity

31
00:01:48,022 --> 00:01:49,378
constraints is true or not.

32
00:01:49,378 --> 00:01:53,752
I also previously and I won't repeat it
here, showed you how there is a little

33
00:01:53,752 --> 00:01:58,268
correspondence between the different
dialects of relational query languages

34
00:01:58,268 --> 00:02:03,310
from Datalog which we did in this class to
SQL, which we start a little bit today.

35
00:02:03,310 --> 00:02:06,900
And then other, more theoretical formalism
called, the relational algebra and

36
00:02:06,900 --> 00:02:08,000
relational calculus.

37
00:02:08,000 --> 00:02:08,620
In particular,

38
00:02:08,620 --> 00:02:12,490
the relational algebra has operations
like this butterfly here like a join.

39
00:02:12,490 --> 00:02:14,490
And this is the basis for

40
00:02:14,490 --> 00:02:17,750
what's inside of a relational
database when we do query planning.

41
00:02:17,750 --> 00:02:21,260
When a database takes an SQL query, it
translates it to an algebra expression and

42
00:02:21,260 --> 00:02:24,620
then it looks at sort of various
statistics of the database and

43
00:02:24,620 --> 00:02:27,450
tries to optimize the execution plan,
okay?

44
00:02:27,450 --> 00:02:32,570
So, those are all things you learn about
in a specialized class on databases.

45
00:02:32,570 --> 00:02:36,414
Here the point was that whatever you
can ask in one of these formalisms, you

46
00:02:36,414 --> 00:02:40,576
can also ask in the other, so there are
equivalent ways to ask the same question.

47
00:02:40,576 --> 00:02:44,296
And I really want you to understand that
it doesn't matter so much what language

48
00:02:44,296 --> 00:02:47,920
you use, it's really the underlying
question that's of importance.

49
00:02:47,920 --> 00:02:50,700
So, when we ask integrity
constraint questions, for example,

50
00:02:50,700 --> 00:02:54,280
we check integrity constraints, we start
with the question, the logic questions,

51
00:02:54,280 --> 00:02:58,920
and we translate it into either Datalog or
SQL in order to check the constraint.

52
00:02:58,920 --> 00:03:01,720
Here we use a system called DLV.

53
00:03:01,720 --> 00:03:06,720
Which can be used as a Datalog engine but
is actually much more powerful because it

54
00:03:06,720 --> 00:03:11,380
can also do repairs which other regular
Datalog systems or SQL cannot do.

55
00:03:11,380 --> 00:03:15,560
We also discussed previously
issues around safety of rules.

56
00:03:15,560 --> 00:03:19,085
There's a simple statement
about when a rule is safe but

57
00:03:19,085 --> 00:03:21,637
it's kind of subtle what that all means?

58
00:03:21,637 --> 00:03:25,984
The simple statement is that every
variable that occurs in a rule must occur

59
00:03:25,984 --> 00:03:27,620
positively in the body.

60
00:03:27,620 --> 00:03:30,180
In particular, you cannot have a variable
in the head that doesn't show up

61
00:03:30,180 --> 00:03:31,000
in the body.

62
00:03:31,000 --> 00:03:34,340
And also you can't have a variable that
shows up only under a negated goal.

63
00:03:34,340 --> 00:03:38,640
It must also exist under a positive goal,
so without the not.

64
00:03:38,640 --> 00:03:44,020
And we played with this, and the idea
was that the positive goal that must

65
00:03:44,020 --> 00:03:48,270
exist in every rule to be safe
is then used as a generator.

66
00:03:48,270 --> 00:03:50,810
So, if you're like
a practically thinking person,

67
00:03:50,810 --> 00:03:55,680
you can think of every of these
positive atoms in the body of rule.

68
00:03:55,680 --> 00:03:57,080
This one is negative with a naught.

69
00:03:57,080 --> 00:03:59,810
But if it's positive,
you can think of them as integrators.

70
00:03:59,810 --> 00:04:01,730
They generate possible values.

71
00:04:01,730 --> 00:04:06,600
And this is not the case when you have a
negated goal with not, they don't generate

72
00:04:06,600 --> 00:04:10,925
values they act as filters they test
values, so you have to value first.

73
00:04:10,925 --> 00:04:15,265
Okay, that's the rationale behind this
rule of safety, I think we did this before

74
00:04:15,265 --> 00:04:19,047
and as you do the exercise you will
probably stumble across that you write

75
00:04:19,047 --> 00:04:23,210
down something and maybe the system
will say this rule is not safe.

76
00:04:23,210 --> 00:04:26,090
And then you hopefully be
reminded that every variable must

77
00:04:26,090 --> 00:04:28,518
occur positively in the body for
the rule to work.

78
00:04:28,518 --> 00:04:32,400
And then we have example of
integrity constraints checking here.

79
00:04:32,400 --> 00:04:35,070
In particular, this little data set

80
00:04:35,070 --> 00:04:38,070
is the one that you're going to
work with as a test dataset.

81
00:04:38,070 --> 00:04:41,475
And there are different integrity
constraints functional dependencies.

82
00:04:41,475 --> 00:04:45,734
And other constraints that you're
asked to test on the dataset.

83
00:04:45,734 --> 00:04:55,734
[MUSIC]