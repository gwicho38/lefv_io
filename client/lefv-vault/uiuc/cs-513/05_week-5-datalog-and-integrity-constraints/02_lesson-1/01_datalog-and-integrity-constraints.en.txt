[MUSIC] DataLog and integrity constraints. I will just remind you of what we're
doing and then I will jump into repair. So our starting point here was that dirty
and clean data be viewed as consistent or inconsistent data. Again here, we have a sample data
set from on of the readings, the paper by Bertossi 2011. Among the most basic and most important
integrity constraints we have functional dependencies, also known as key
constraints in relational databases and also inclusion dependencies
which are related to referential integrity constraints, where a child
table, the foreign key of that Child Table references the Primary
key of the Parent Table. Okay, so we've looked at it before. We've also looked at how such constraints
can be modeled in logic rules, we found the logic notation to be a little
tricky at first and we learned about then alternative in some sense more practical
notation for applications called Datalog. And so we've seen that integrity
constraint violations can be modeled as queries. I want to say if I have
a student pupil xy and another student pupil xz,
and y and z are different, that's going to be a problem so, I speak
over integrity constraint violation, why? Because, originally we said that these two
that the first column should determine all the other columns, in this case
the second column there's only one. That really says that
the first column is a key or a primary key of this relationship. So whenever I see X, Y and I see X, Z, the only way this is possible
is that Y is equal to Z. We're looking basically at the same row. There cannot be two rows with the single
X and different sort of Y and Z values. And this is how you would write a test
rule that checks one of these integrity constraints is true or not. I also previously and I won't repeat it
here, showed you how there is a little correspondence between the different
dialects of relational query languages from Datalog which we did in this class to
SQL, which we start a little bit today. And then other, more theoretical formalism
called, the relational algebra and relational calculus. In particular, the relational algebra has operations
like this butterfly here like a join. And this is the basis for what's inside of a relational
database when we do query planning. When a database takes an SQL query, it
translates it to an algebra expression and then it looks at sort of various
statistics of the database and tries to optimize the execution plan,
okay? So, those are all things you learn about
in a specialized class on databases. Here the point was that whatever you
can ask in one of these formalisms, you can also ask in the other, so there are
equivalent ways to ask the same question. And I really want you to understand that
it doesn't matter so much what language you use, it's really the underlying
question that's of importance. So, when we ask integrity
constraint questions, for example, we check integrity constraints, we start
with the question, the logic questions, and we translate it into either Datalog or
SQL in order to check the constraint. Here we use a system called DLV. Which can be used as a Datalog engine but
is actually much more powerful because it can also do repairs which other regular
Datalog systems or SQL cannot do. We also discussed previously
issues around safety of rules. There's a simple statement
about when a rule is safe but it's kind of subtle what that all means? The simple statement is that every
variable that occurs in a rule must occur positively in the body. In particular, you cannot have a variable
in the head that doesn't show up in the body. And also you can't have a variable that
shows up only under a negated goal. It must also exist under a positive goal,
so without the not. And we played with this, and the idea
was that the positive goal that must exist in every rule to be safe
is then used as a generator. So, if you're like
a practically thinking person, you can think of every of these
positive atoms in the body of rule. This one is negative with a naught. But if it's positive,
you can think of them as integrators. They generate possible values. And this is not the case when you have a
negated goal with not, they don't generate values they act as filters they test
values, so you have to value first. Okay, that's the rationale behind this
rule of safety, I think we did this before and as you do the exercise you will
probably stumble across that you write down something and maybe the system
will say this rule is not safe. And then you hopefully be
reminded that every variable must occur positively in the body for
the rule to work. And then we have example of
integrity constraints checking here. In particular, this little data set is the one that you're going to
work with as a test dataset. And there are different integrity
constraints functional dependencies. And other constraints that you're
asked to test on the dataset. [MUSIC]