1
00:00:00,000 --> 00:00:08,598
[MUSIC]

2
00:00:08,598 --> 00:00:11,210
Welcome back to Theory and
Practice of Data Cleaning.

3
00:00:11,210 --> 00:00:13,777
In this lecture we're going to
look at regular expressions again,

4
00:00:13,777 --> 00:00:15,421
this time from a practical perspective.

5
00:00:17,030 --> 00:00:19,780
But first let's have a brief
reminder of what the Theory of

6
00:00:19,780 --> 00:00:21,210
Regular Expressions was about.

7
00:00:21,210 --> 00:00:25,180
Regular languages are also
called Type-3 languages and

8
00:00:25,180 --> 00:00:28,590
they are generated by regular grammars or
Type-3 grammars.

9
00:00:28,590 --> 00:00:31,470
We saw a somewhat painful
example at the last lecture,

10
00:00:31,470 --> 00:00:35,840
how we could generate a floating
point number using a Type-3 grammar.

11
00:00:35,840 --> 00:00:40,090
That's also another important application
in computer science for regular languages,

12
00:00:40,090 --> 00:00:44,470
namely they are recognized by finite
automaton, or by a finite automata.

13
00:00:44,470 --> 00:00:48,250
But really for our purposes, what we
want to do with regular expressions, is we

14
00:00:48,250 --> 00:00:52,340
want to use them to match and extract
data and use them for data cleaning.

15
00:00:52,340 --> 00:00:57,236
So here was the particular grammar that we
looked at the last time, that can be used

16
00:00:57,236 --> 00:01:02,233
to generate the floating point number,
and as you see it's rather tedious,

17
00:01:02,233 --> 00:01:07,070
and so instead we can use a much
more compact concise expression,

18
00:01:07,070 --> 00:01:11,520
the regular expression at the bottom
to match any floating point number.

19
00:01:11,520 --> 00:01:15,010
So we will now look at this particular
regular expression and take it apart and

20
00:01:15,010 --> 00:01:19,060
learn along the way some of the basic
ingredients of regular expressions.

21
00:01:19,060 --> 00:01:22,590
So here we go, so let's take the following
use case, let's say you have a file,

22
00:01:22,590 --> 00:01:25,380
a text file, and
it has floating point numbers in it, and

23
00:01:25,380 --> 00:01:27,550
maybe you want to extract
as a first phase,

24
00:01:27,550 --> 00:01:30,650
you want to extract all the floating
point numbers out of that file.

25
00:01:30,650 --> 00:01:34,660
So that might be programming code, where
you have assignments like pi equals this

26
00:01:34,660 --> 00:01:39,310
number, or e equals that number, so
how would you get out just the numbers?

27
00:01:39,310 --> 00:01:42,804
So this particular regular expression that
you can see here would do the trick, and

28
00:01:42,804 --> 00:01:47,090
it's kind of complex, but we can tease
it apart and understand what's going on.

29
00:01:47,090 --> 00:01:48,660
So the first part, the bracket and

30
00:01:48,660 --> 00:01:53,560
then the minus plus character inside of
that bracket, is called a Character set.

31
00:01:53,560 --> 00:01:57,250
So whatever's inside of a Character set,
matches any single character, so

32
00:01:57,250 --> 00:01:58,282
just one character.

33
00:01:58,282 --> 00:02:05,750
So [-+] matches either a minus or
a plus, and only one of those.

34
00:02:05,750 --> 00:02:08,020
Then we have after that a question mark,
so

35
00:02:08,020 --> 00:02:11,840
the question mark here, I can point you
to it, this particular question mark

36
00:02:11,840 --> 00:02:16,510
is indicating an optional element, so
whatever comes to the left of it, may or

37
00:02:16,510 --> 00:02:20,080
may not actually exist in
our string that we match.

38
00:02:20,080 --> 00:02:24,360
So these means, the minus and the plus
sign in particular, they are optional.

39
00:02:24,360 --> 00:02:27,190
So whatever's to the left
of it that's optional, so

40
00:02:27,190 --> 00:02:31,610
that makes the question mark an indication
of an optional element to the left of it.

41
00:02:33,040 --> 00:02:35,780
So what comes next is
another character set,

42
00:02:35,780 --> 00:02:40,696
in this case, [0 to 9], and this
introduces also the element of a Range.

43
00:02:40,696 --> 00:02:47,830
So 0-9 in brackets means, match any single
character that's inside of this range, in

44
00:02:47,830 --> 00:02:52,980
this case a digit between 0 and 9, so this
does not match a multiple digits just yet.

45
00:02:54,410 --> 00:02:58,680
However, you see there's a star right
after this bracket expression, and

46
00:02:58,680 --> 00:03:02,980
the star means, it matches 0 or
more occurrences.

47
00:03:02,980 --> 00:03:06,870
So in a way the star is sort of a more
powerful version of the question mark.

48
00:03:06,870 --> 00:03:10,030
The question mark would match 0 or
1 occurrences, but

49
00:03:10,030 --> 00:03:12,920
the star also can be
matching 0 occurrences, so

50
00:03:12,920 --> 00:03:18,130
you may not have a digit in fact, or it
can mean, it matches any number of digits.

51
00:03:18,130 --> 00:03:19,470
So if you have a very long or

52
00:03:19,470 --> 00:03:23,290
large number, you might as well
match that with this star.

53
00:03:23,290 --> 00:03:28,750
Going down further the list,
we see now the dot, the period.

54
00:03:28,750 --> 00:03:33,570
Now, there's a period right there, and
normally a dot matches any character.

55
00:03:33,570 --> 00:03:38,200
So itself kind of a wildcard,
any character, except line breaks.

56
00:03:38,200 --> 00:03:41,590
Now preceding this dot is a backslash, and

57
00:03:41,590 --> 00:03:45,150
the backslash means we're going to
escape the following character.

58
00:03:45,150 --> 00:03:50,150
So although dot usually matches any
character, because we put the escape

59
00:03:50,150 --> 00:03:55,170
character backslash in front of it,
now the next character is taken literally.

60
00:03:55,170 --> 00:03:56,890
So we match really the period,

61
00:03:56,890 --> 00:04:00,520
that particular symbol,
we don't match any character.

62
00:04:00,520 --> 00:04:03,010
So a dot would match any character, but

63
00:04:03,010 --> 00:04:06,810
we do not want in our floating point
number to match any character.

64
00:04:06,810 --> 00:04:09,890
So here, if you see in the floating point
number here, like in a number pi, and

65
00:04:09,890 --> 00:04:14,260
in the number e, there's really
a literal dot, a literal period.

66
00:04:14,260 --> 00:04:18,050
And that's what we want to match, which is
why we need to use this escape character.

67
00:04:19,290 --> 00:04:24,060
And then how this expression continue,
then we have 0 to 9 again,

68
00:04:24,060 --> 00:04:26,670
a character set, but then with a plus, so

69
00:04:26,670 --> 00:04:32,250
we must have at least one digit
after the optional decimal point.

70
00:04:32,250 --> 00:04:35,860
So after the optional decimal point, it's
optional because of the question mark, but

71
00:04:35,860 --> 00:04:38,690
now we really have to have
at least one digit, and

72
00:04:38,690 --> 00:04:42,550
that's what the [0-9]+ indicates.

73
00:04:42,550 --> 00:04:46,180
All right, and then finally, in a floating
point number, if the numbers are large or

74
00:04:46,180 --> 00:04:50,260
small, we have an exponent,
we have the scientific notation, and

75
00:04:50,260 --> 00:04:53,850
we have a whole group here that has
a couple of different elements.

76
00:04:53,850 --> 00:04:58,540
So we have a round parenthesis here, and
then we have a bunch of things inside, and

77
00:04:58,540 --> 00:05:02,185
then the closing parenthesis, and then
again a question mark to indicate that,

78
00:05:02,185 --> 00:05:06,530
that whole group, as a group, may or may
not be there, so it occurs 0 or 1 times.

79
00:05:07,680 --> 00:05:10,350
Now how does that exponent look like,
if it is there?

80
00:05:10,350 --> 00:05:14,900
It is either a lower case e or an upper
case e, and you see here in the example,

81
00:05:14,900 --> 00:05:19,440
we have both cases, the number pi here
is expressed using the lower case e for

82
00:05:19,440 --> 00:05:24,020
the exponent,
whereas the Euler's number, that's ESD,

83
00:05:24,020 --> 00:05:27,980
Euler's number, has an upper case
E here to indicate the exponent.

84
00:05:29,220 --> 00:05:34,221
So we may have a lower case or an upper
case e, and we must have a lower or

85
00:05:34,221 --> 00:05:37,955
upper case e,
if you want to go inside of this group.

86
00:05:37,955 --> 00:05:42,650
Then we have optionally assigned a
negative or a positive sign for exponent,

87
00:05:42,650 --> 00:05:47,489
if it omits the sign then of course it's
going to be considered a positive number,

88
00:05:47,489 --> 00:05:48,880
so that's optional.

89
00:05:49,960 --> 00:05:54,060
And then the exponent, if you've gotten up
this point, we have to have again, one or

90
00:05:54,060 --> 00:05:57,870
more digits, so
we say [0-9] as a range, and

91
00:05:57,870 --> 00:06:02,220
then + to indicate there's one or
more of those, not zero.

92
00:06:02,220 --> 00:06:06,840
You can't have an e and then nothing
after it, that would not be correct.

93
00:06:06,840 --> 00:06:11,990
And then again, that question mark around
the whole capture group, so the group

94
00:06:11,990 --> 00:06:16,520
starts here and ends here, and then the
question mark applies to the whole group,

95
00:06:16,520 --> 00:06:20,130
so this group may or may not be there,
it may or may not need to be matched.

96
00:06:20,130 --> 00:06:24,080
And that's called a Capturing group,
it groups multiple tokens,

97
00:06:24,080 --> 00:06:27,980
that's one function of it, so
we can refer back to it later, and

98
00:06:27,980 --> 00:06:32,090
it's also used for example, in this case,
to indicate that the group may or

99
00:06:32,090 --> 00:06:34,200
may not be there using this question mark.

100
00:06:34,200 --> 00:06:36,740
So that was sort of taking
apart this particular

101
00:06:36,740 --> 00:06:38,830
expression that matches
floating point numbers.

102
00:06:40,100 --> 00:06:42,380
Now when we match with
regular expressions,

103
00:06:42,380 --> 00:06:46,680
we have to distinguish two cases
where things can go wrong.

104
00:06:46,680 --> 00:06:51,530
One is called the false negative, maybe
you want to match a floating point number,

105
00:06:51,530 --> 00:06:54,050
an email address, something like that, and

106
00:06:54,050 --> 00:06:57,240
your pattern just doesn't match
the things it should match.

107
00:06:57,240 --> 00:07:00,700
We can think of this as a false negative,
because it says no this doesn't match,

108
00:07:00,700 --> 00:07:01,930
when really you want it to match.

109
00:07:02,960 --> 00:07:07,000
So probably you will notice this pretty
soon, because you'll notice that

110
00:07:07,000 --> 00:07:10,020
you're missing some results when you're
testing your regular expression,

111
00:07:10,020 --> 00:07:13,950
trying it out,
you will not find what you're looking for.

112
00:07:13,950 --> 00:07:15,450
So what's the remedy here?

113
00:07:15,450 --> 00:07:18,210
So in this case,
you need to relax the regular expression.

114
00:07:18,210 --> 00:07:18,850
What does that mean?

115
00:07:18,850 --> 00:07:21,230
You need to make it more encompassing, so

116
00:07:21,230 --> 00:07:25,190
it matches more of the desired
strings that you want to match.

117
00:07:25,190 --> 00:07:28,700
Now there's a little bit of a catch here,
because it's easy to make

118
00:07:28,700 --> 00:07:31,740
a regular expression accept more things,
or match more things.

119
00:07:31,740 --> 00:07:36,160
But you have to also avoid matching
false positives, so what is that?

120
00:07:36,160 --> 00:07:40,410
So a false positive is when your
regular expression matches something,

121
00:07:40,410 --> 00:07:45,530
which it shouldn't, so now you get
sort of false positive data back.

122
00:07:45,530 --> 00:07:48,280
And the false positives
are often not notice at

123
00:07:48,280 --> 00:07:51,080
first because maybe they
occur only sporadically.

124
00:07:51,080 --> 00:07:55,177
You might not notice that your regular
expression is sort of too permissive,

125
00:07:55,177 --> 00:07:59,021
it's allowing too many matches until
much later, when strings occur,

126
00:07:59,021 --> 00:08:03,660
where this false positive really
kicks in and you see the false match.

127
00:08:03,660 --> 00:08:04,820
So what is the remedy here?

128
00:08:04,820 --> 00:08:07,310
In this case, you need to
tighten the regular expression.

129
00:08:07,310 --> 00:08:08,400
You need to make it so

130
00:08:08,400 --> 00:08:11,640
that it matches fewer strings,
in order to avoid the false matches.

131
00:08:13,200 --> 00:08:15,130
So this thing can get pretty tricky.

132
00:08:15,130 --> 00:08:18,330
And in fact you can think of this almost,
as a sport.

133
00:08:18,330 --> 00:08:21,870
I show here another of these XKCD comics,

134
00:08:21,870 --> 00:08:25,640
showing their sport called
regular expression golf.

135
00:08:25,640 --> 00:08:30,300
And regular expression golf is really
the attempt to or the effort to

136
00:08:30,300 --> 00:08:34,530
find regular expressions that match
certain names, but not certain others.

137
00:08:34,530 --> 00:08:36,660
So have a look at that comic,
it's quite entertaining.

138
00:08:37,790 --> 00:08:41,910
Now since it is so difficult to get
the right regular expression sometimes.

139
00:08:41,910 --> 00:08:47,000
It's really a balancing act between
the positive and the negative matches.

140
00:08:47,000 --> 00:08:50,630
And even if there is an exact or
near regular expression solution,

141
00:08:50,630 --> 00:08:55,190
sometimes you just might not want to go
with a overly complex regular expression.

142
00:08:55,190 --> 00:08:57,420
Because those are difficult to debug and
maintain.

143
00:08:57,420 --> 00:09:00,390
Maybe there's certain change
is coming into the data,

144
00:09:00,390 --> 00:09:02,620
certain other cases you need to consider.

145
00:09:02,620 --> 00:09:05,580
And then working with such
a monstrous regular expression

146
00:09:05,580 --> 00:09:07,100
might be really difficult.

147
00:09:07,100 --> 00:09:09,730
So there's one thing you
can do in this case.

148
00:09:09,730 --> 00:09:12,080
Which is to keep the regular
expression for what it's good,

149
00:09:12,080 --> 00:09:15,750
which is matching certain patterns,
hopefully are not too complicated.

150
00:09:15,750 --> 00:09:20,130
And then use code to deal
with other special cases.

151
00:09:20,130 --> 00:09:23,640
So, it might be better in practice
to allow some false positives.

152
00:09:23,640 --> 00:09:26,810
And then use software, little program
snippets, to check the semantics.

153
00:09:26,810 --> 00:09:29,780
So, this is often much better in practice,
but here's an example.

154
00:09:29,780 --> 00:09:34,270
Let's say you want to extract dates from
a data set like this one here, 02/29/2000.

155
00:09:34,270 --> 00:09:37,940
Turns out this is not
in a standard format.

156
00:09:37,940 --> 00:09:41,130
So we might have to actually transform
it into the ISO standard, so

157
00:09:41,130 --> 00:09:43,032
we can compare it with other dates.

158
00:09:43,032 --> 00:09:46,230
However, first of all,
we have to extract it.

159
00:09:46,230 --> 00:09:48,440
So if you extract that,
we might say well wait a minute.

160
00:09:48,440 --> 00:09:51,600
February 29th of 2000,
is that even a valid date?

161
00:09:51,600 --> 00:09:54,150
So that's sort of a quality
issue right there.

162
00:09:54,150 --> 00:09:57,880
Now we could try, and maybe in this
case it would be rather futile.

163
00:09:57,880 --> 00:10:00,910
In cases like this we could try to
come up with a very clever regular

164
00:10:00,910 --> 00:10:02,860
expression to match this.

165
00:10:02,860 --> 00:10:05,250
But if you think about it,
it's much easier to take and

166
00:10:05,250 --> 00:10:08,080
much more maintainable to take
a simple regular expression

167
00:10:08,080 --> 00:10:12,020
that matches just the pattern, month,
day and year with a slash in between.

168
00:10:12,020 --> 00:10:13,100
It's very easy to write down.

169
00:10:13,100 --> 00:10:16,870
And then have some logic in
your application program or

170
00:10:16,870 --> 00:10:20,570
in your script that then checks
whether that date makes sense.

171
00:10:20,570 --> 00:10:23,590
So below here, I've copied
the basic logic, the basic code.

172
00:10:23,590 --> 00:10:25,668
Although it's not completely trivial, but

173
00:10:25,668 --> 00:10:28,770
this really figures out whether
a year is a leap year or not.

174
00:10:28,770 --> 00:10:31,870
And if it is a leap year,
29th of February would be okay.

175
00:10:31,870 --> 00:10:33,530
And if it's not a leap year,
it wouldn't be okay.

176
00:10:34,560 --> 00:10:38,330
So again, this is sort of a separation
of concerns, a separation of labor.

177
00:10:38,330 --> 00:10:39,770
So a regular expression is really used for

178
00:10:39,770 --> 00:10:43,620
the simple extraction and
matching an extraction of the data.

179
00:10:43,620 --> 00:10:47,140
And then you have some code to
really look deeper into the issue.

180
00:10:47,140 --> 00:10:49,900
Even though sometimes this might be
possible to do with a regular expression,

181
00:10:49,900 --> 00:10:52,360
in practice you probably
don't want to do that.

182
00:10:52,360 --> 00:10:55,140
All right, now let's look
a little bit more closely at some

183
00:10:55,140 --> 00:10:59,360
of the particular constructs that
we have with regular expressions.

184
00:10:59,360 --> 00:11:02,580
And often what you want to do here is
really print out the cheat sheet that

185
00:11:02,580 --> 00:11:04,560
you can find from the resources or
on the web.

186
00:11:04,560 --> 00:11:07,900
Anywhere that really summarizes
the most important special cases here.

187
00:11:07,900 --> 00:11:13,630
So we've already seen the dot character
matches any character except the new line,

188
00:11:13,630 --> 00:11:16,580
so this is a very useful
wildcard character.

189
00:11:16,580 --> 00:11:19,080
If you want to use a literal dot,
as we've seen before,

190
00:11:19,080 --> 00:11:21,260
you have to escape it with a \.

191
00:11:21,260 --> 00:11:23,710
Now there's other special characters and

192
00:11:23,710 --> 00:11:26,310
character classes that are pre-defined for
you.

193
00:11:26,310 --> 00:11:28,420
So you could define them in other ways,
but it's just for

194
00:11:28,420 --> 00:11:30,046
convenience defined as follows.

195
00:11:30,046 --> 00:11:34,630
So \W, \ lowercase w, matches a word.

196
00:11:34,630 --> 00:11:37,095
That's usually for example,
alpha-numeric characters.

197
00:11:37,095 --> 00:11:42,100
\D mentions a digit, so
instead of what you've seen before in

198
00:11:42,100 --> 00:11:47,430
the character class bracket,
then 0-9 and closing brackets.

199
00:11:47,430 --> 00:11:51,880
We could just use \ lower case d to
measure digits, much more convenient.

200
00:11:51,880 --> 00:11:54,590
So word character, a digit character and

201
00:11:54,590 --> 00:11:58,580
then \S itself stands for
a whitespace character.

202
00:11:58,580 --> 00:12:00,400
So what's a whitespace,
whitespace character is for

203
00:12:00,400 --> 00:12:03,410
example the blank, the space bar
that you have on the keyboard.

204
00:12:03,410 --> 00:12:07,080
But also tabs, for example would be
considered a whitespace character.

205
00:12:07,080 --> 00:12:10,610
Now sometimes you want to match
everything but a whitespace character, or

206
00:12:10,610 --> 00:12:13,690
everything but
a word character or a digit.

207
00:12:13,690 --> 00:12:16,800
And in this case, there's a convention for
regular expressions

208
00:12:16,800 --> 00:12:21,830
that you write the letter W,
D or S in uppercase.

209
00:12:21,830 --> 00:12:26,625
So \W means, match any non word character,
everything but a word character.

210
00:12:26,625 --> 00:12:29,935
\D similarly, everything but a digit.

211
00:12:29,935 --> 00:12:33,970
\S, capital S means everything but
a whitespace character.

212
00:12:33,970 --> 00:12:35,930
So compared to classes we've seen before,

213
00:12:35,930 --> 00:12:40,660
abc in brackets really means one of these,
a or b or c.

214
00:12:40,660 --> 00:12:46,530
If we have a or hat symbol inside
of the bracket specifically there,

215
00:12:46,530 --> 00:12:48,180
then it means also negation.

216
00:12:48,180 --> 00:12:52,572
It means match any character that
is not an a, or not a b or not a c.

217
00:12:52,572 --> 00:12:55,780
So it matches everything but
those characters.

218
00:12:55,780 --> 00:12:57,630
But only again a single character.

219
00:12:57,630 --> 00:13:00,070
And then we have ranges,
we've seen this before.

220
00:13:00,070 --> 00:13:01,940
So this would be part
of every cheat sheet.

221
00:13:01,940 --> 00:13:04,590
If you say a through g with a dash,

222
00:13:04,590 --> 00:13:06,880
that matches any single
character between a and g.

223
00:13:06,880 --> 00:13:10,630
All right, then we have so called anchors.

224
00:13:10,630 --> 00:13:13,790
Anchors are sometimes useful if you
want to match at the beginning or

225
00:13:13,790 --> 00:13:15,740
end of a string or line.

226
00:13:15,740 --> 00:13:18,850
So for example if you use this symbol or
hat symbol.

227
00:13:18,850 --> 00:13:19,840
And then followed by, for

228
00:13:19,840 --> 00:13:24,610
example, abc, this will match sequence
abc at the start of the string.

229
00:13:24,610 --> 00:13:28,530
Or if you put a dollar sign,
this will match in this particular case,

230
00:13:28,530 --> 00:13:31,460
the sequence abc if it occurs
at the end of the string.

231
00:13:31,460 --> 00:13:35,930
Then you can also match at other places
for example, at a word boundary.

232
00:13:35,930 --> 00:13:39,810
So word boundaries for
example sequence of wide space characters.

233
00:13:39,810 --> 00:13:44,130
So if you want to match xyz, and
then there's, for example, a space or

234
00:13:44,130 --> 00:13:46,070
something similar maybe a new line.

235
00:13:46,070 --> 00:13:51,772
This new word starts maybe there's
other word boundary options than xyz,

236
00:13:51,772 --> 00:13:54,180
\b would match that.

237
00:13:54,180 --> 00:13:58,410
If on the other hand you want to
match xyz within a word, so

238
00:13:58,410 --> 00:14:01,530
xyz is followed by maybe uvw.

239
00:14:01,530 --> 00:14:04,880
So there's no word boundaries,
but maybe inside of a word.

240
00:14:04,880 --> 00:14:08,790
Then you would use the capital
B to match a non-word boundary.

241
00:14:08,790 --> 00:14:12,400
So these are anchors that anchor basically
the thing that you want to match

242
00:14:12,400 --> 00:14:14,950
to the beginning or end of the line,
or beginning, or end of a word.

243
00:14:14,950 --> 00:14:17,080
Or compliment of that in the last case.

244
00:14:18,110 --> 00:14:21,890
So another common construct here
are called escape characters.

245
00:14:21,890 --> 00:14:25,700
So if you want to escape a character,
then we put a \ in front of it.

246
00:14:25,700 --> 00:14:30,710
And, therefore, indicate that this
character is to interpret literally.

247
00:14:30,710 --> 00:14:33,940
So, for example, a dot character
by itself matches any character.

248
00:14:33,940 --> 00:14:35,860
But if we want to literally match a dot,

249
00:14:35,860 --> 00:14:40,470
a period, like in the floating point
number, and we have to say \..

250
00:14:40,470 --> 00:14:44,530
Similarly, characters like * or
the \ itself or question mark,

251
00:14:44,530 --> 00:14:48,190
all of these special characters that have
a special meaning in regular expressions.

252
00:14:48,190 --> 00:14:52,580
If you want to match them literally,
we then need to use a \ in front of them.

253
00:14:52,580 --> 00:14:56,300
To indicate through the system,
hey I really need this character,

254
00:14:56,300 --> 00:14:59,910
I don't mean the special
character with a special meaning.

255
00:14:59,910 --> 00:15:03,290
Now if we have, for
example, a tab character or

256
00:15:03,290 --> 00:15:05,380
a new line character or a carriage return.

257
00:15:05,380 --> 00:15:08,780
So there's a subtle difference
between a new line or a linefeed and

258
00:15:08,780 --> 00:15:09,560
a carriage return.

259
00:15:09,560 --> 00:15:13,020
Depending on whether you're on a Windows
machine, for example, or on a Mac, or

260
00:15:13,020 --> 00:15:14,330
in a Linux machine.

261
00:15:14,330 --> 00:15:18,430
But these are basically new line and
carriage return characters.

262
00:15:18,430 --> 00:15:20,590
How would you match those?

263
00:15:20,590 --> 00:15:24,000
Because they might be in your text file,
so we have special symbols for that.

264
00:15:24,000 --> 00:15:26,849
So \t, \n, and

265
00:15:26,849 --> 00:15:32,080
\r respectively match a tab, a line feed,
and a carriage return character.

266
00:15:32,080 --> 00:15:33,680
You can also get special symbols.

267
00:15:33,680 --> 00:15:37,720
You want to match a special symbol,
that you're looking for maybe in a text.

268
00:15:37,720 --> 00:15:40,070
So you can use a unicode escaped code.

269
00:15:40,070 --> 00:15:43,740
For example here \u00A9 would
match the copyright character,

270
00:15:43,740 --> 00:15:47,450
which is a special unicode character.

271
00:15:47,450 --> 00:15:51,740
All right, so
we also looked previously at groups.

272
00:15:51,740 --> 00:15:55,500
So groups, for
example here we see two groups.

273
00:15:55,500 --> 00:15:57,730
We have a first group that matches.

274
00:15:57,730 --> 00:16:02,335
0 or 9 is a digit one or
more time, so that's a number.

275
00:16:02,335 --> 00:16:06,860
The number at least one digit,
possibly, as many digits as you like.

276
00:16:06,860 --> 00:16:09,790
And we put that in parenthesis to say,
okay, that's going to be a group.

277
00:16:09,790 --> 00:16:13,370
And then we have maybe
wide space characters.

278
00:16:13,370 --> 00:16:18,610
So, \s* indicates zero or
more wide space characters.

279
00:16:18,610 --> 00:16:19,640
And then we have another group.

280
00:16:19,640 --> 00:16:20,560
And what is the second group?

281
00:16:20,560 --> 00:16:23,330
Well the second group is lower
case letters between a and z,

282
00:16:23,330 --> 00:16:25,240
one or more of those.

283
00:16:25,240 --> 00:16:28,330
And so again,
the parenthesis are used for grouping.

284
00:16:28,330 --> 00:16:32,590
For example, we put behind the group
a question mark to indicate

285
00:16:32,590 --> 00:16:34,490
that the group itself is optional.

286
00:16:34,490 --> 00:16:36,720
But another use of the group
is as a back reference.

287
00:16:36,720 --> 00:16:40,890
So we can say, well the groups are
numbered left to right from one to end.

288
00:16:40,890 --> 00:16:44,680
In this case we have two groups and
when we say \1, what

289
00:16:44,680 --> 00:16:49,370
we're saying is we're referencing back
whatever was matched by the first group.

290
00:16:49,370 --> 00:16:53,670
So for example if we have
an expression such as \2, \1 for

291
00:16:53,670 --> 00:16:58,360
two groups, we can basically check for
a simple palindromes.

292
00:16:58,360 --> 00:17:02,730
Okay, so in this case the second
group would match this word

293
00:17:02,730 --> 00:17:05,770
from a to z several characters of those.

294
00:17:05,770 --> 00:17:08,090
And then followed by a digit or

295
00:17:08,090 --> 00:17:12,704
number, sequence of numbers, a sequence
of digits making up a number that's \1.

296
00:17:13,900 --> 00:17:16,580
All right so,
where are groups useful in practice?

297
00:17:16,580 --> 00:17:18,300
Groups are used for transformations, so

298
00:17:18,300 --> 00:17:22,370
we come back to our some learning example
that we've looked a couple of times.

299
00:17:22,370 --> 00:17:27,060
Assume for example you want to capture
a date in the format two digits for

300
00:17:27,060 --> 00:17:31,030
the month, followed by slash and
two digits for the day and

301
00:17:31,030 --> 00:17:33,750
in another slash and
then four digit for a year.

302
00:17:33,750 --> 00:17:37,841
So, the regular expression here the first
one over here would match that, pattern,

303
00:17:37,841 --> 00:17:41,790
so the pattern in the abstract is
described here, and we would say well,

304
00:17:41,790 --> 00:17:44,110
we have a group that
starts out as a digit.

305
00:17:44,110 --> 00:17:48,480
So that's our \d, and
then there's a curly braces.

306
00:17:48,480 --> 00:17:52,190
And curly braces, we have the number 2
here that indicates that we want exactly

307
00:17:52,190 --> 00:17:53,890
two occurrences of that.

308
00:17:53,890 --> 00:17:55,920
So we could also say one or
two occurrences, for

309
00:17:55,920 --> 00:17:57,590
example, in the case of a month.

310
00:17:57,590 --> 00:18:01,710
Sometimes that they're just written
with a single digit instead of two.

311
00:18:01,710 --> 00:18:05,600
So this regular expression would force
a match of two digits for the month,

312
00:18:05,600 --> 00:18:09,230
February for example would have to be
written 02, and that's the first group and

313
00:18:09,230 --> 00:18:12,760
then we have a slash, so
over here we see that there's a slash, and

314
00:18:12,760 --> 00:18:15,350
then we have a second group and
again that's another group of

315
00:18:15,350 --> 00:18:20,650
precisely two digits and we have another
slash and a group of exactly four digits.

316
00:18:20,650 --> 00:18:23,780
So, this matches precisely
this kinds of dates.

317
00:18:23,780 --> 00:18:27,230
Now, if you wanted to transform this
kind dates into a standard date,

318
00:18:27,230 --> 00:18:29,090
say the ISO standard format.

319
00:18:29,090 --> 00:18:34,110
So, we can integrate with other data sets
and we have a normalised representation.

320
00:18:34,110 --> 00:18:37,740
We could do that by referring
back to those previous groups.

321
00:18:37,740 --> 00:18:41,300
So, depending on the particular
circumstance you might use a back slash,

322
00:18:41,300 --> 00:18:44,080
one, two, three, or
in this case, a dollar symbol.

323
00:18:44,080 --> 00:18:48,090
So you insert the captured result, so for
example if you were to use a Python script

324
00:18:48,090 --> 00:18:52,590
or a similar scripting language you might
then say okay I'm going to match strings

325
00:18:52,590 --> 00:18:57,660
using this regular expression and
then when I output my transformed string,

326
00:18:57,660 --> 00:19:02,190
I want to output them in the ISO formats
so first starting with here, then a dash

327
00:19:02,190 --> 00:19:07,400
instead of a slash and the month and
then the dash again and then the date.

328
00:19:07,400 --> 00:19:09,480
And in this case I would
have to reorder the group.

329
00:19:09,480 --> 00:19:13,020
So it's really nice that I can refer
back to the groups which is why I put

330
00:19:13,020 --> 00:19:17,161
the parenthesis in the first place so I
could extract pieces of the overall match,

331
00:19:17,161 --> 00:19:19,821
smaller group and
then rearrange them in this case.

332
00:19:19,821 --> 00:19:23,992
So this case we would see dollar three, of
course measures the year that was the last

333
00:19:23,992 --> 00:19:27,160
group, followed by dash then dollar one,
that was the month.

334
00:19:27,160 --> 00:19:29,260
There was the first group.

335
00:19:29,260 --> 00:19:32,070
And then dollar two,
that is the middle group.

336
00:19:32,070 --> 00:19:34,290
And that was for the day.

337
00:19:34,290 --> 00:19:36,970
So again, this can be used for
example in Python,

338
00:19:36,970 --> 00:19:40,090
in the OpenRefine tool that
we're going to study and so on.

339
00:19:40,090 --> 00:19:41,410
All right let's summarize.

340
00:19:41,410 --> 00:19:44,230
We've now looked at regular expressions
how they are used in practice.

341
00:19:44,230 --> 00:19:48,280
So regular expressions are a powerful
language for pattern matching, extraction,

342
00:19:48,280 --> 00:19:49,790
and transformation.

343
00:19:49,790 --> 00:19:53,150
They have roots in computer science where
they are studied in the theory of formal

344
00:19:53,150 --> 00:19:53,890
languages.

345
00:19:53,890 --> 00:19:55,890
But they're really also
widely used in practice,

346
00:19:55,890 --> 00:19:59,470
and may save the day for
data extraction or data transformation.

347
00:19:59,470 --> 00:20:00,890
Which really makes them very helpful and

348
00:20:00,890 --> 00:20:03,490
important for us for
data quality assessment.

349
00:20:03,490 --> 00:20:08,240
And we even have matching data and then
maybe cleaning it, fixing it right away.

350
00:20:08,240 --> 00:20:11,900
For some people regular expressions are
a bit of an acquired taste which is like

351
00:20:11,900 --> 00:20:15,600
with other acquired tastes they can
be quite addictive after some time.

352
00:20:15,600 --> 00:20:19,716
And you might be considered as having
special powers if your master regular

353
00:20:19,716 --> 00:20:20,577
expressions.

354
00:20:20,577 --> 00:20:30,891
[MUSIC]

355
00:20:30,891 --> 00:20:34,451
[SOUND]