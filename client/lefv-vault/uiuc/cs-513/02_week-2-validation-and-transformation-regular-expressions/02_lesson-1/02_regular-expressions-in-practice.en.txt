[MUSIC] Welcome back to Theory and
Practice of Data Cleaning. In this lecture we're going to
look at regular expressions again, this time from a practical perspective. But first let's have a brief
reminder of what the Theory of Regular Expressions was about. Regular languages are also
called Type-3 languages and they are generated by regular grammars or
Type-3 grammars. We saw a somewhat painful
example at the last lecture, how we could generate a floating
point number using a Type-3 grammar. That's also another important application
in computer science for regular languages, namely they are recognized by finite
automaton, or by a finite automata. But really for our purposes, what we
want to do with regular expressions, is we want to use them to match and extract
data and use them for data cleaning. So here was the particular grammar that we
looked at the last time, that can be used to generate the floating point number,
and as you see it's rather tedious, and so instead we can use a much
more compact concise expression, the regular expression at the bottom
to match any floating point number. So we will now look at this particular
regular expression and take it apart and learn along the way some of the basic
ingredients of regular expressions. So here we go, so let's take the following
use case, let's say you have a file, a text file, and
it has floating point numbers in it, and maybe you want to extract
as a first phase, you want to extract all the floating
point numbers out of that file. So that might be programming code, where
you have assignments like pi equals this number, or e equals that number, so
how would you get out just the numbers? So this particular regular expression that
you can see here would do the trick, and it's kind of complex, but we can tease
it apart and understand what's going on. So the first part, the bracket and then the minus plus character inside of
that bracket, is called a Character set. So whatever's inside of a Character set,
matches any single character, so just one character. So [-+] matches either a minus or
a plus, and only one of those. Then we have after that a question mark,
so the question mark here, I can point you
to it, this particular question mark is indicating an optional element, so
whatever comes to the left of it, may or may not actually exist in
our string that we match. So these means, the minus and the plus
sign in particular, they are optional. So whatever's to the left
of it that's optional, so that makes the question mark an indication
of an optional element to the left of it. So what comes next is
another character set, in this case, [0 to 9], and this
introduces also the element of a Range. So 0-9 in brackets means, match any single
character that's inside of this range, in this case a digit between 0 and 9, so this
does not match a multiple digits just yet. However, you see there's a star right
after this bracket expression, and the star means, it matches 0 or
more occurrences. So in a way the star is sort of a more
powerful version of the question mark. The question mark would match 0 or
1 occurrences, but the star also can be
matching 0 occurrences, so you may not have a digit in fact, or it
can mean, it matches any number of digits. So if you have a very long or large number, you might as well
match that with this star. Going down further the list,
we see now the dot, the period. Now, there's a period right there, and
normally a dot matches any character. So itself kind of a wildcard,
any character, except line breaks. Now preceding this dot is a backslash, and the backslash means we're going to
escape the following character. So although dot usually matches any
character, because we put the escape character backslash in front of it,
now the next character is taken literally. So we match really the period, that particular symbol,
we don't match any character. So a dot would match any character, but we do not want in our floating point
number to match any character. So here, if you see in the floating point
number here, like in a number pi, and in the number e, there's really
a literal dot, a literal period. And that's what we want to match, which is
why we need to use this escape character. And then how this expression continue,
then we have 0 to 9 again, a character set, but then with a plus, so we must have at least one digit
after the optional decimal point. So after the optional decimal point, it's
optional because of the question mark, but now we really have to have
at least one digit, and that's what the [0-9]+ indicates. All right, and then finally, in a floating
point number, if the numbers are large or small, we have an exponent,
we have the scientific notation, and we have a whole group here that has
a couple of different elements. So we have a round parenthesis here, and
then we have a bunch of things inside, and then the closing parenthesis, and then
again a question mark to indicate that, that whole group, as a group, may or may
not be there, so it occurs 0 or 1 times. Now how does that exponent look like,
if it is there? It is either a lower case e or an upper
case e, and you see here in the example, we have both cases, the number pi here
is expressed using the lower case e for the exponent,
whereas the Euler's number, that's ESD, Euler's number, has an upper case
E here to indicate the exponent. So we may have a lower case or an upper
case e, and we must have a lower or upper case e,
if you want to go inside of this group. Then we have optionally assigned a
negative or a positive sign for exponent, if it omits the sign then of course it's
going to be considered a positive number, so that's optional. And then the exponent, if you've gotten up
this point, we have to have again, one or more digits, so
we say [0-9] as a range, and then + to indicate there's one or
more of those, not zero. You can't have an e and then nothing
after it, that would not be correct. And then again, that question mark around
the whole capture group, so the group starts here and ends here, and then the
question mark applies to the whole group, so this group may or may not be there,
it may or may not need to be matched. And that's called a Capturing group,
it groups multiple tokens, that's one function of it, so
we can refer back to it later, and it's also used for example, in this case,
to indicate that the group may or may not be there using this question mark. So that was sort of taking
apart this particular expression that matches
floating point numbers. Now when we match with
regular expressions, we have to distinguish two cases
where things can go wrong. One is called the false negative, maybe
you want to match a floating point number, an email address, something like that, and your pattern just doesn't match
the things it should match. We can think of this as a false negative,
because it says no this doesn't match, when really you want it to match. So probably you will notice this pretty
soon, because you'll notice that you're missing some results when you're
testing your regular expression, trying it out,
you will not find what you're looking for. So what's the remedy here? So in this case,
you need to relax the regular expression. What does that mean? You need to make it more encompassing, so it matches more of the desired
strings that you want to match. Now there's a little bit of a catch here,
because it's easy to make a regular expression accept more things,
or match more things. But you have to also avoid matching
false positives, so what is that? So a false positive is when your
regular expression matches something, which it shouldn't, so now you get
sort of false positive data back. And the false positives
are often not notice at first because maybe they
occur only sporadically. You might not notice that your regular
expression is sort of too permissive, it's allowing too many matches until
much later, when strings occur, where this false positive really
kicks in and you see the false match. So what is the remedy here? In this case, you need to
tighten the regular expression. You need to make it so that it matches fewer strings,
in order to avoid the false matches. So this thing can get pretty tricky. And in fact you can think of this almost,
as a sport. I show here another of these XKCD comics, showing their sport called
regular expression golf. And regular expression golf is really
the attempt to or the effort to find regular expressions that match
certain names, but not certain others. So have a look at that comic,
it's quite entertaining. Now since it is so difficult to get
the right regular expression sometimes. It's really a balancing act between
the positive and the negative matches. And even if there is an exact or
near regular expression solution, sometimes you just might not want to go
with a overly complex regular expression. Because those are difficult to debug and
maintain. Maybe there's certain change
is coming into the data, certain other cases you need to consider. And then working with such
a monstrous regular expression might be really difficult. So there's one thing you
can do in this case. Which is to keep the regular
expression for what it's good, which is matching certain patterns,
hopefully are not too complicated. And then use code to deal
with other special cases. So, it might be better in practice
to allow some false positives. And then use software, little program
snippets, to check the semantics. So, this is often much better in practice,
but here's an example. Let's say you want to extract dates from
a data set like this one here, 02/29/2000. Turns out this is not
in a standard format. So we might have to actually transform
it into the ISO standard, so we can compare it with other dates. However, first of all,
we have to extract it. So if you extract that,
we might say well wait a minute. February 29th of 2000,
is that even a valid date? So that's sort of a quality
issue right there. Now we could try, and maybe in this
case it would be rather futile. In cases like this we could try to
come up with a very clever regular expression to match this. But if you think about it,
it's much easier to take and much more maintainable to take
a simple regular expression that matches just the pattern, month,
day and year with a slash in between. It's very easy to write down. And then have some logic in
your application program or in your script that then checks
whether that date makes sense. So below here, I've copied
the basic logic, the basic code. Although it's not completely trivial, but this really figures out whether
a year is a leap year or not. And if it is a leap year,
29th of February would be okay. And if it's not a leap year,
it wouldn't be okay. So again, this is sort of a separation
of concerns, a separation of labor. So a regular expression is really used for the simple extraction and
matching an extraction of the data. And then you have some code to
really look deeper into the issue. Even though sometimes this might be
possible to do with a regular expression, in practice you probably
don't want to do that. All right, now let's look
a little bit more closely at some of the particular constructs that
we have with regular expressions. And often what you want to do here is
really print out the cheat sheet that you can find from the resources or
on the web. Anywhere that really summarizes
the most important special cases here. So we've already seen the dot character
matches any character except the new line, so this is a very useful
wildcard character. If you want to use a literal dot,
as we've seen before, you have to escape it with a \. Now there's other special characters and character classes that are pre-defined for
you. So you could define them in other ways,
but it's just for convenience defined as follows. So \W, \ lowercase w, matches a word. That's usually for example,
alpha-numeric characters. \D mentions a digit, so
instead of what you've seen before in the character class bracket,
then 0-9 and closing brackets. We could just use \ lower case d to
measure digits, much more convenient. So word character, a digit character and then \S itself stands for
a whitespace character. So what's a whitespace,
whitespace character is for example the blank, the space bar
that you have on the keyboard. But also tabs, for example would be
considered a whitespace character. Now sometimes you want to match
everything but a whitespace character, or everything but
a word character or a digit. And in this case, there's a convention for
regular expressions that you write the letter W,
D or S in uppercase. So \W means, match any non word character,
everything but a word character. \D similarly, everything but a digit. \S, capital S means everything but
a whitespace character. So compared to classes we've seen before, abc in brackets really means one of these,
a or b or c. If we have a or hat symbol inside
of the bracket specifically there, then it means also negation. It means match any character that
is not an a, or not a b or not a c. So it matches everything but
those characters. But only again a single character. And then we have ranges,
we've seen this before. So this would be part
of every cheat sheet. If you say a through g with a dash, that matches any single
character between a and g. All right, then we have so called anchors. Anchors are sometimes useful if you
want to match at the beginning or end of a string or line. So for example if you use this symbol or
hat symbol. And then followed by, for example, abc, this will match sequence
abc at the start of the string. Or if you put a dollar sign,
this will match in this particular case, the sequence abc if it occurs
at the end of the string. Then you can also match at other places
for example, at a word boundary. So word boundaries for
example sequence of wide space characters. So if you want to match xyz, and
then there's, for example, a space or something similar maybe a new line. This new word starts maybe there's
other word boundary options than xyz, \b would match that. If on the other hand you want to
match xyz within a word, so xyz is followed by maybe uvw. So there's no word boundaries,
but maybe inside of a word. Then you would use the capital
B to match a non-word boundary. So these are anchors that anchor basically
the thing that you want to match to the beginning or end of the line,
or beginning, or end of a word. Or compliment of that in the last case. So another common construct here
are called escape characters. So if you want to escape a character,
then we put a \ in front of it. And, therefore, indicate that this
character is to interpret literally. So, for example, a dot character
by itself matches any character. But if we want to literally match a dot, a period, like in the floating point
number, and we have to say \.. Similarly, characters like * or
the \ itself or question mark, all of these special characters that have
a special meaning in regular expressions. If you want to match them literally,
we then need to use a \ in front of them. To indicate through the system,
hey I really need this character, I don't mean the special
character with a special meaning. Now if we have, for
example, a tab character or a new line character or a carriage return. So there's a subtle difference
between a new line or a linefeed and a carriage return. Depending on whether you're on a Windows
machine, for example, or on a Mac, or in a Linux machine. But these are basically new line and
carriage return characters. How would you match those? Because they might be in your text file,
so we have special symbols for that. So \t, \n, and \r respectively match a tab, a line feed,
and a carriage return character. You can also get special symbols. You want to match a special symbol,
that you're looking for maybe in a text. So you can use a unicode escaped code. For example here \u00A9 would
match the copyright character, which is a special unicode character. All right, so
we also looked previously at groups. So groups, for
example here we see two groups. We have a first group that matches. 0 or 9 is a digit one or
more time, so that's a number. The number at least one digit,
possibly, as many digits as you like. And we put that in parenthesis to say,
okay, that's going to be a group. And then we have maybe
wide space characters. So, \s* indicates zero or
more wide space characters. And then we have another group. And what is the second group? Well the second group is lower
case letters between a and z, one or more of those. And so again,
the parenthesis are used for grouping. For example, we put behind the group
a question mark to indicate that the group itself is optional. But another use of the group
is as a back reference. So we can say, well the groups are
numbered left to right from one to end. In this case we have two groups and
when we say \1, what we're saying is we're referencing back
whatever was matched by the first group. So for example if we have
an expression such as \2, \1 for two groups, we can basically check for
a simple palindromes. Okay, so in this case the second
group would match this word from a to z several characters of those. And then followed by a digit or number, sequence of numbers, a sequence
of digits making up a number that's \1. All right so,
where are groups useful in practice? Groups are used for transformations, so we come back to our some learning example
that we've looked a couple of times. Assume for example you want to capture
a date in the format two digits for the month, followed by slash and
two digits for the day and in another slash and
then four digit for a year. So, the regular expression here the first
one over here would match that, pattern, so the pattern in the abstract is
described here, and we would say well, we have a group that
starts out as a digit. So that's our \d, and
then there's a curly braces. And curly braces, we have the number 2
here that indicates that we want exactly two occurrences of that. So we could also say one or
two occurrences, for example, in the case of a month. Sometimes that they're just written
with a single digit instead of two. So this regular expression would force
a match of two digits for the month, February for example would have to be
written 02, and that's the first group and then we have a slash, so
over here we see that there's a slash, and then we have a second group and
again that's another group of precisely two digits and we have another
slash and a group of exactly four digits. So, this matches precisely
this kinds of dates. Now, if you wanted to transform this
kind dates into a standard date, say the ISO standard format. So, we can integrate with other data sets
and we have a normalised representation. We could do that by referring
back to those previous groups. So, depending on the particular
circumstance you might use a back slash, one, two, three, or
in this case, a dollar symbol. So you insert the captured result, so for
example if you were to use a Python script or a similar scripting language you might
then say okay I'm going to match strings using this regular expression and
then when I output my transformed string, I want to output them in the ISO formats
so first starting with here, then a dash instead of a slash and the month and
then the dash again and then the date. And in this case I would
have to reorder the group. So it's really nice that I can refer
back to the groups which is why I put the parenthesis in the first place so I
could extract pieces of the overall match, smaller group and
then rearrange them in this case. So this case we would see dollar three, of
course measures the year that was the last group, followed by dash then dollar one,
that was the month. There was the first group. And then dollar two,
that is the middle group. And that was for the day. So again, this can be used for
example in Python, in the OpenRefine tool that
we're going to study and so on. All right let's summarize. We've now looked at regular expressions
how they are used in practice. So regular expressions are a powerful
language for pattern matching, extraction, and transformation. They have roots in computer science where
they are studied in the theory of formal languages. But they're really also
widely used in practice, and may save the day for
data extraction or data transformation. Which really makes them very helpful and important for us for
data quality assessment. And we even have matching data and then
maybe cleaning it, fixing it right away. For some people regular expressions are
a bit of an acquired taste which is like with other acquired tastes they can
be quite addictive after some time. And you might be considered as having
special powers if your master regular expressions. [MUSIC] [SOUND]