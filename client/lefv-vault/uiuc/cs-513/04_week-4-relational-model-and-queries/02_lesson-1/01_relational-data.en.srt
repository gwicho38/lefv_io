1
00:00:00,000 --> 00:00:07,564
[MUSIC]

2
00:00:07,564 --> 00:00:10,900
Welcome back to Theory and
Practice of Data Cleaning.

3
00:00:10,900 --> 00:00:14,113
In this video I want to introduce
the relational model and

4
00:00:14,113 --> 00:00:16,970
to show how we can work
with relational data.

5
00:00:16,970 --> 00:00:19,466
So first,
let's put us in the context however.

6
00:00:19,466 --> 00:00:22,490
So, we started out with
regular expressions.

7
00:00:22,490 --> 00:00:24,150
We were looking at synthetic issues.

8
00:00:24,150 --> 00:00:27,830
How can we use regular expressions
to define patterns for matching and

9
00:00:27,830 --> 00:00:28,900
extracting data?

10
00:00:28,900 --> 00:00:33,015
In this way using regular expression
we were able to check the conformance

11
00:00:33,015 --> 00:00:35,255
of certain data strings in our raw data.

12
00:00:35,255 --> 00:00:38,875
For example, whether our data was
conforming to the ISO date format,

13
00:00:38,875 --> 00:00:42,665
which is four digits for the year,
a dash, then two digits for

14
00:00:42,665 --> 00:00:45,245
the month, another dash, and
then two digits for the day.

15
00:00:45,245 --> 00:00:48,335
If the data does not conform to
this structure, to this pattern,

16
00:00:48,335 --> 00:00:51,815
then we would bring it into a canonical
form, for example, using a script.

17
00:00:51,815 --> 00:00:55,465
Another tool that we've learned so
far is OpenRefine, which uses regular

18
00:00:55,465 --> 00:01:00,260
expressions, but is In general a much more
powerful tool we can use to profile and

19
00:01:00,260 --> 00:01:02,610
clean data, one column at a time.

20
00:01:02,610 --> 00:01:05,580
So one particularly powerful
feature of OpenRefine

21
00:01:05,580 --> 00:01:08,740
was the use of
similarity-based clustering.

22
00:01:08,740 --> 00:01:12,155
But in the end we were working
with OpenRefine to clean up

23
00:01:12,155 --> 00:01:16,225
data in a single column and bringing
the data then into a canonical form.

24
00:01:16,225 --> 00:01:20,505
But what about a more complex issue that
span multiple columns in our data tables?

25
00:01:20,505 --> 00:01:21,795
What about logical errors?

26
00:01:21,795 --> 00:01:25,872
How shall we deal with this kind of
data quality issues at the schema and

27
00:01:25,872 --> 00:01:27,132
that the semantic level.

28
00:01:27,132 --> 00:01:30,332
So here's an example of you seen
before where we have two tables,

29
00:01:30,332 --> 00:01:32,432
a Person table and Address table and

30
00:01:32,432 --> 00:01:36,270
some of the data quality issues should
have been address with OpenRefine.

31
00:01:36,270 --> 00:01:39,080
But even if you have cleaned
your data using OpenRefine,

32
00:01:39,080 --> 00:01:43,850
some other kinds of issues about dirty
data can still make it into your tables.

33
00:01:43,850 --> 00:01:45,280
So how shall we deal with those?

34
00:01:45,280 --> 00:01:49,170
For example, you might have integrity
constraints that span multiple tables,

35
00:01:49,170 --> 00:01:53,390
maybe a foreign key that goes from
the person table to the address table or

36
00:01:53,390 --> 00:01:54,900
maybe you have duplicates.

37
00:01:54,900 --> 00:01:57,780
Or maybe you have some illogical
contradictions in your data.

38
00:01:57,780 --> 00:02:00,940
So never mind the pattern issues,
the syntactic issues,

39
00:02:00,940 --> 00:02:02,560
that OpenRefine addresses.

40
00:02:02,560 --> 00:02:05,816
What about the semantic and
structural issues?

41
00:02:05,816 --> 00:02:09,372
Issues at the schema level, when we
load data into a database we can than

42
00:02:09,372 --> 00:02:12,520
use the database technology
to deal with those issues.

43
00:02:12,520 --> 00:02:15,780
So here's an overview of our work flow,
simplified overview.

44
00:02:15,780 --> 00:02:19,270
So we started out with raw
data that is often dirty and

45
00:02:19,270 --> 00:02:23,820
then we use a tool like OpenRefine to
do some sort of pattern based cleaning,

46
00:02:23,820 --> 00:02:27,490
again using regular expressions,
using clustering and so on.

47
00:02:27,490 --> 00:02:31,560
The next step, we can then load this data
once it has gone through this initial data

48
00:02:31,560 --> 00:02:33,920
cleaning, we can load it
into a database system.

49
00:02:33,920 --> 00:02:38,210
And once the data is in a database system,
we then can exploit the powerful database

50
00:02:38,210 --> 00:02:42,430
technology to run queries and
to check integrity constraints.

51
00:02:42,430 --> 00:02:44,320
So this will be the focus of this video.

52
00:02:44,320 --> 00:02:45,970
How shall we go about doing this?

53
00:02:45,970 --> 00:02:50,150
First, we have to understand what
are relational databases and

54
00:02:50,150 --> 00:02:54,110
what is the underlying data model,
the relational model?

55
00:02:54,110 --> 00:02:56,360
We will then look at query languages,

56
00:02:56,360 --> 00:03:00,680
in particular we will look at the logic
base approach first called Datalog.

57
00:03:00,680 --> 00:03:02,220
And we will learn about the facts and

58
00:03:02,220 --> 00:03:05,190
rules and queries and
integrity constraints in another video.

59
00:03:05,190 --> 00:03:09,560
Another advantage of looking at Datalog is
that there's a very rich body of research

60
00:03:09,560 --> 00:03:11,390
both in theory and in practice.

61
00:03:11,390 --> 00:03:14,015
So Datalog while not as widely use as SQL,

62
00:03:14,015 --> 00:03:17,840
has still found niche applications
including an industry.

63
00:03:17,840 --> 00:03:22,083
And then finally we will move on to look
at the really dominant database query

64
00:03:22,083 --> 00:03:26,840
line which in the real world which is SQL,
the structured query language.

65
00:03:26,840 --> 00:03:30,430
On the right, you will see again the
overall workflow that we follow here from

66
00:03:30,430 --> 00:03:33,990
raw data through pattern based
data cleaning with OpenRefine

67
00:03:33,990 --> 00:03:38,610
into database system which then
will allow us to use queries and

68
00:03:38,610 --> 00:03:43,820
integrity constraint mechanisms to
check the logical quality of the data.

69
00:03:43,820 --> 00:03:46,400
So, here we need a little refresher, or

70
00:03:46,400 --> 00:03:49,000
if you like, a crash course,
on the relational model.

71
00:03:49,000 --> 00:03:51,110
So data is often organized into relations.

72
00:03:51,110 --> 00:03:52,960
We might know this from spreadsheets.

73
00:03:52,960 --> 00:03:56,130
But when we think of the relational
model in the context of databases,

74
00:03:56,130 --> 00:03:57,940
we have a very particular model in mind.

75
00:03:57,940 --> 00:04:02,656
The database model called Relational
Databases was pioneered by Edgar Codd in

76
00:04:02,656 --> 00:04:03,663
the 1970s.

77
00:04:03,663 --> 00:04:07,813
So it's been out there for quite a while,
but it's been an industry standard and

78
00:04:07,813 --> 00:04:10,210
sort of a leading technology ever since.

79
00:04:10,210 --> 00:04:12,580
So how is data organized
in the Relational Database?

80
00:04:12,580 --> 00:04:16,320
Well, first we have data in relations or
tables as we call them and

81
00:04:16,320 --> 00:04:19,270
then the tables are organized
into rows and columns.

82
00:04:19,270 --> 00:04:22,470
Typically we really think of
them as organized into rows, or

83
00:04:22,470 --> 00:04:26,500
tuples sometimes, and then the columns
are sometimes also called attributes in

84
00:04:26,500 --> 00:04:28,050
the Relational Database world.

85
00:04:28,050 --> 00:04:33,140
And we can then distinguish the first
row if you like which is very special,

86
00:04:33,140 --> 00:04:36,950
which is the header or
schema level information from the body or

87
00:04:36,950 --> 00:04:39,600
the actual instances which
contain the actual data.

88
00:04:39,600 --> 00:04:41,460
Some more terminology in this context, so

89
00:04:41,460 --> 00:04:45,770
we're really focusing today in this
video on the Relational Model, and

90
00:04:45,770 --> 00:04:49,490
then a Relational Schema is really
the kind of header information,

91
00:04:49,490 --> 00:04:53,300
the set of attributes, so the tables or
relations, their names and

92
00:04:53,300 --> 00:04:57,880
their attributes, and then the Relational
Database instance to make it clear.

93
00:04:57,880 --> 00:05:02,110
We can say the word instance, so the
Relational Database instance consists of

94
00:05:02,110 --> 00:05:07,020
the data itself, the particular rows that
are spread across all these columns.

95
00:05:07,020 --> 00:05:11,540
And last not least, RDBMS stands for
Relational Database Management System.

96
00:05:11,540 --> 00:05:14,090
Those are of course the systems
on which we run the actual

97
00:05:14,090 --> 00:05:15,850
queries that we're interested in.

98
00:05:15,850 --> 00:05:17,790
So if you more worked in
the Relational Model,

99
00:05:17,790 --> 00:05:22,210
the Relational Model is really close
closely related to predicate logic.

100
00:05:22,210 --> 00:05:25,090
Sometimes also called first
order predicate logic.

101
00:05:25,090 --> 00:05:29,338
So although it was in some sense invented
as a technology in the 70s, the underlying

102
00:05:29,338 --> 00:05:32,524
foundations of the Relational Model
are even older than that and

103
00:05:32,524 --> 00:05:36,250
they are in some sense the foundations
of our logical thinking if you like.

104
00:05:36,250 --> 00:05:39,110
A very particular model to
which the Relational Model

105
00:05:39,110 --> 00:05:42,033
is closely related is used for
conceptual modeling and

106
00:05:42,033 --> 00:05:45,910
that's called the Entity-Relationship
model or Model.

107
00:05:45,910 --> 00:05:52,580
So here in the slide you see at the center
left a thumbnail of such as an Model.

108
00:05:52,580 --> 00:05:56,380
The key idea here is that we
structure the world into entities and

109
00:05:56,380 --> 00:05:59,330
relationships that model
our application domain.

110
00:05:59,330 --> 00:06:01,910
This is a very simple yet
very powerful model.

111
00:06:01,910 --> 00:06:05,320
Look at the first idea of the things
that you want to store in the database.

112
00:06:05,320 --> 00:06:08,560
And there are many tools that
allow you to go from an Models or

113
00:06:08,560 --> 00:06:11,880
from a conceptualization
of your application domain

114
00:06:11,880 --> 00:06:14,760
automatically to a relational
database schema.

115
00:06:14,760 --> 00:06:18,680
So you can create tables from your
Relational Model automatically

116
00:06:18,680 --> 00:06:19,950
with many tools.

117
00:06:19,950 --> 00:06:24,650
The Relation Model is also very flexible,
it allows us to represent for

118
00:06:24,650 --> 00:06:28,450
example XML data,
graph data, or object data.

119
00:06:28,450 --> 00:06:32,050
And in fact there are extensions
to relational databases that

120
00:06:32,050 --> 00:06:37,250
support these particular variants of data
models in a very efficient way such as

121
00:06:37,250 --> 00:06:39,120
object relational databases.

122
00:06:39,120 --> 00:06:43,660
But the main reason why we study
the Relational Model here is because it

123
00:06:43,660 --> 00:06:48,150
allows us to use queries against
the relational data that we have and

124
00:06:48,150 --> 00:06:51,090
therefore check the quality and
integrity of our data.

125
00:06:51,090 --> 00:06:55,020
So, the relational model, for the purposes
of this class is really interesting,

126
00:06:55,020 --> 00:06:57,170
because we can query that data and

127
00:06:57,170 --> 00:07:00,240
run checks on the data and
ask questions about the data.

128
00:07:00,240 --> 00:07:03,070
So what are the query languages
that are typically associated with

129
00:07:03,070 --> 00:07:03,970
the relational model?

130
00:07:03,970 --> 00:07:05,750
Well, as I already indicated,

131
00:07:05,750 --> 00:07:09,190
the Relational Model is closely related
to first order predicate calculus,

132
00:07:09,190 --> 00:07:14,090
sometimes called FOL, or just FO,
or RC for the relational calculus.

133
00:07:14,090 --> 00:07:18,490
Then, this relational calculus or
first order logic, is not extremely

134
00:07:18,490 --> 00:07:22,940
convenient for really writing practical
queries against the relational database.

135
00:07:22,940 --> 00:07:26,720
So there is a much more intuitive rule
base language called Datalog, and

136
00:07:26,720 --> 00:07:31,970
it is this language Datalog that we will
be using to run our first queries and

137
00:07:31,970 --> 00:07:34,710
integrity constraints against a database.

138
00:07:34,710 --> 00:07:38,060
From a database course which
this is of course not, but

139
00:07:38,060 --> 00:07:42,900
from a database course you would know and
learn additional query mechanisms,

140
00:07:42,900 --> 00:07:46,630
in particular the Relational Algebra,
here also abbreviated as RA.

141
00:07:46,630 --> 00:07:51,050
And the Relational Algebra is the first
step of a database system to go from

142
00:07:51,050 --> 00:07:55,190
a query, from a high level
query into an execution plan

143
00:07:55,190 --> 00:07:57,190
that the database system can optimize.

144
00:07:57,190 --> 00:08:01,680
And the query language most commonly
used for querying relational data is,

145
00:08:01,680 --> 00:08:04,600
of course, SQL,
the Structured Query Language.

146
00:08:04,600 --> 00:08:08,450
And although it is outside of the scope of
this course to give a deep introduction

147
00:08:08,450 --> 00:08:13,440
into SQL, we will do a brief review
since we will need SQL to answer some

148
00:08:13,440 --> 00:08:17,980
of the questions about data quality and
integrity that we have in this course.

149
00:08:17,980 --> 00:08:22,850
So, the main focus, again, for studying
the Relational Model is it allows us

150
00:08:22,850 --> 00:08:27,840
to store all kinds of data
in convenient form, and

151
00:08:27,840 --> 00:08:31,970
then we have a powerful query language or,
in fact, a family of query languages

152
00:08:31,970 --> 00:08:35,040
that we can employ to ask
questions about the data and,

153
00:08:35,040 --> 00:08:38,840
in particular, to check the logical
integrity of the data, and

154
00:08:38,840 --> 00:08:43,790
spot errors this way using integrity
constraints expressed as queries.

155
00:08:43,790 --> 00:08:46,600
On this slide I give
a high level overview and

156
00:08:46,600 --> 00:08:50,520
connection of the different formalisms for
querying relational databases.

157
00:08:50,520 --> 00:08:54,940
Much could be said about this but
I will just give a high level overview.

158
00:08:54,940 --> 00:08:58,310
So we will look again at SQL,
the structured query language.

159
00:08:58,310 --> 00:09:01,890
Which is basically structured as if

160
00:09:01,890 --> 00:09:05,300
you would write a query in
stylized form of English.

161
00:09:05,300 --> 00:09:10,390
So there is a form to express queries
in this something like select

162
00:09:10,390 --> 00:09:11,330
certain attributes or

163
00:09:11,330 --> 00:09:17,540
columns from certain relations
where certain conditions are met.

164
00:09:17,540 --> 00:09:19,170
So this is the SQL query language.

165
00:09:19,170 --> 00:09:22,210
And there is another
more theoretical language

166
00:09:22,210 --> 00:09:25,690
that is used in the implementation
of relational databases, and

167
00:09:25,690 --> 00:09:29,950
that you also study in a database course,
it's called the relational algebra.

168
00:09:29,950 --> 00:09:33,600
And it has mathematical
operations that work on tables or

169
00:09:33,600 --> 00:09:35,530
relations as we call them.

170
00:09:35,530 --> 00:09:39,920
And then produce new output relations or
tables as a result.

171
00:09:39,920 --> 00:09:42,680
So, you will see these Greek letters.

172
00:09:42,680 --> 00:09:45,850
Sigma for selection, pi for projection.

173
00:09:45,850 --> 00:09:50,810
Then you see a butterfly,
which is join operation, and a delta for

174
00:09:50,810 --> 00:09:55,870
renaming or a row, in fact, for renaming
a union operator and a set difference.

175
00:09:55,870 --> 00:09:59,740
So these relational algebra operators
are something that you would study in

176
00:09:59,740 --> 00:10:01,570
a relational database course.

177
00:10:01,570 --> 00:10:05,340
Closer for
us to home is the relational calculus.

178
00:10:05,340 --> 00:10:07,200
Although we will not say
too much about it, but

179
00:10:07,200 --> 00:10:13,220
it is the formalism used to query
relational structures in logic so

180
00:10:13,220 --> 00:10:18,280
we see some symbols there, there's the
universal quantifier for all xF basically

181
00:10:18,280 --> 00:10:22,440
when making a statement in logic and say
that for every x the following is true.

182
00:10:22,440 --> 00:10:27,290
Then f is again an expression in logic
what can be an exteseteial qualifier we

183
00:10:27,290 --> 00:10:29,850
can it is the case that
a certain thing is true and

184
00:10:29,850 --> 00:10:34,660
then we have other logical operators for
and and or not.

185
00:10:34,660 --> 00:10:38,770
Again it would go too far to go into
these in greater detail here but

186
00:10:38,770 --> 00:10:42,850
it is important to know that the formal
under pinnings of the language

187
00:10:42,850 --> 00:10:47,400
we do study data log are in fact
based in logic, mathematicians.

188
00:10:47,400 --> 00:10:51,850
And logicians would be happy to use
the relational calculus or first order

189
00:10:51,850 --> 00:10:56,990
predicate logic to express queries and
questions about relational structures.

190
00:10:56,990 --> 00:10:58,580
As practitioners however, we're not so

191
00:10:58,580 --> 00:11:02,530
happy with this formalism which is why
we use a language such as Datalog.

192
00:11:02,530 --> 00:11:04,530
To make all of this
a little bit more concrete,

193
00:11:04,530 --> 00:11:07,740
I have here on this slide
a very simple example.

194
00:11:07,740 --> 00:11:10,990
So imagine you have a relational
schema that has two tables.

195
00:11:10,990 --> 00:11:13,200
One table called the employee table, and

196
00:11:13,200 --> 00:11:18,300
it has three columns called employee,
salary, and department number.

197
00:11:18,300 --> 00:11:22,030
So the idea of the employee table is that
it stores information about employees,

198
00:11:22,030 --> 00:11:24,320
their salary, and
the department in which they work.

199
00:11:24,320 --> 00:11:26,680
And then there's a second
table called the DeptNo.

200
00:11:26,680 --> 00:11:29,470
Which has, again,
an identifier for the department,

201
00:11:29,470 --> 00:11:32,220
and then also a manager for
that department.

202
00:11:32,220 --> 00:11:36,030
And you could imagine that the manager for
the department is himself or

203
00:11:36,030 --> 00:11:37,770
herself an employee.

204
00:11:37,770 --> 00:11:38,930
So there's two tables and

205
00:11:38,930 --> 00:11:41,145
there's some connections between
Between these two tables.

206
00:11:41,145 --> 00:11:44,305
And there might be similar
relationships even within a table.

207
00:11:44,305 --> 00:11:48,065
And of course, we cannot use a tool like
OpenRefine that will not help us here.

208
00:11:48,065 --> 00:11:50,485
So we really need to jump
into this database world,

209
00:11:50,485 --> 00:11:53,560
then use query languages to
explore these relationships.

210
00:11:53,560 --> 00:11:57,120
So let's say we want to ask a question, in
this case not yet an integrity constraint,

211
00:11:57,120 --> 00:12:00,890
just a simple question about the data, and
we want to create maybe a relationship

212
00:12:00,890 --> 00:12:03,800
between employees and
the managers that they work for.

213
00:12:03,800 --> 00:12:04,950
How would we do this?

214
00:12:04,950 --> 00:12:08,420
So we would look at the employee table,
we would look at the department table and

215
00:12:08,420 --> 00:12:12,180
then we would bring together this
kind of information from both tables.

216
00:12:12,180 --> 00:12:13,870
This is called a join operation.

217
00:12:13,870 --> 00:12:16,960
So this is the butterfly symbol
in the relational algebra.

218
00:12:16,960 --> 00:12:20,985
In SQL, we would say for example,
the following which is almost natural.

219
00:12:20,985 --> 00:12:26,015
Language so we would say select an
employee and a manager so denoted here emp

220
00:12:26,015 --> 00:12:29,625
and manager, from the two tables that
we have which is the employee table and

221
00:12:29,625 --> 00:12:33,055
the department table but subject to
certain condition and the condition is we

222
00:12:33,055 --> 00:12:37,965
want to say that the department
mentioned in the employee name table.

223
00:12:37,965 --> 00:12:42,225
That would be the third column shall
be equal to the department number and

224
00:12:42,225 --> 00:12:44,700
the department table which
is the first column there.

225
00:12:44,700 --> 00:12:49,120
So, we have to have some sort of agreement
on the third column of the employee table,

226
00:12:49,120 --> 00:12:54,250
and the first column, the department table
as these rows align and have the same

227
00:12:54,250 --> 00:12:58,780
value there then we want to report who's
the employee and who is the manager.

228
00:12:58,780 --> 00:13:01,910
That way we have joined the information
from those two tables and

229
00:13:01,910 --> 00:13:05,680
have some sence uncovered or
revealed a new piece of information.

230
00:13:05,680 --> 00:13:08,260
I don't want to go into the details
of the relational algebra here but

231
00:13:08,260 --> 00:13:10,780
you see there are some sort
of mathematical notation

232
00:13:10,780 --> 00:13:15,560
that tells us how these two tables
are combined to create a joint table and

233
00:13:15,560 --> 00:13:19,340
then we project on some
results column of interest.

234
00:13:19,340 --> 00:13:23,520
Even less pleasant maybe to the untrained
eye is the relational calculus or

235
00:13:23,520 --> 00:13:25,030
predicate logic formula.

236
00:13:25,030 --> 00:13:29,390
So I will not mention too much about
it but rather focus on the last

237
00:13:29,390 --> 00:13:32,580
item here on this line which is
the Datalog rule because in some sense,

238
00:13:32,580 --> 00:13:35,610
this Datalog rule says exactly
the same as all the other rules,

239
00:13:35,610 --> 00:13:38,840
only that it is much more intuitive and
easy to understand.

240
00:13:38,840 --> 00:13:43,270
So Datalog rule has two parts, the left
hand side and the right hand side.

241
00:13:43,270 --> 00:13:46,170
On the left hand side in some
sense you see the conclusion or

242
00:13:46,170 --> 00:13:48,100
answer to a particular question.

243
00:13:48,100 --> 00:13:52,420
In this case the answer is a relation
called boss, so it is the boss or manager

244
00:13:52,420 --> 00:13:57,230
table if you like which pairs together
an employee and the employee's manager.

245
00:13:57,230 --> 00:14:00,440
And on the right hand side of
the rule we have the query condition,

246
00:14:00,440 --> 00:14:01,810
the body of the rule.

247
00:14:01,810 --> 00:14:06,160
That tells us how shall we find this
pair of an employee and a manager.

248
00:14:06,160 --> 00:14:09,040
The body of the rule is intuitively
quite easy to understand.

249
00:14:09,040 --> 00:14:12,340
It is, in some sense,
a logical pattern that describes,

250
00:14:12,340 --> 00:14:16,190
almost by way of an example, how these
two tables are to be combined, so

251
00:14:16,190 --> 00:14:20,320
we see that we picked from the employee
table, a triple of values,

252
00:14:20,320 --> 00:14:23,510
three variables, Emp,
salary and department number.

253
00:14:23,510 --> 00:14:27,980
And then the comma is really the logical
end, and we see it, well also in addition,

254
00:14:27,980 --> 00:14:32,410
we want to have from the department
table a pair of values,

255
00:14:32,410 --> 00:14:34,230
department number and the manager.

256
00:14:34,230 --> 00:14:37,980
And here, it is important to understand
that the department number If we pick

257
00:14:37,980 --> 00:14:39,700
the department table, and

258
00:14:39,700 --> 00:14:43,770
the department number that we picked
from the employee table, call inside.

259
00:14:43,770 --> 00:14:48,260
When those are the same, then we want to
report that fact and then in some sense we

260
00:14:48,260 --> 00:14:52,580
apply the rules that are from the right
to the left and we report that we found

261
00:14:52,580 --> 00:14:57,630
the pair between an employee and
the employees boss or manager.

262
00:14:57,630 --> 00:14:59,550
So let's summarize what we've seen so far.

263
00:14:59,550 --> 00:15:02,800
We started out with the syntactic
data cleaning operations that

264
00:15:02,800 --> 00:15:04,640
we started in previous videos.

265
00:15:04,640 --> 00:15:09,670
And we have now begun to venture in the
central part of this cause the schema and

266
00:15:09,670 --> 00:15:13,300
semantics in particular we started
out with a relational model.

267
00:15:13,300 --> 00:15:18,130
At least we understand that the relational
allows us to store all kinds of data

268
00:15:18,130 --> 00:15:21,850
in a flexible manner and in particular
it will allow us to query and

269
00:15:21,850 --> 00:15:26,540
ask questions about the data and check for
integrity violations and then report them.

270
00:15:26,540 --> 00:15:30,869
And this will be the subject of the next
video where we'll talk about Datalog and

271
00:15:30,869 --> 00:15:32,561
then subsequently about SQL.

272
00:15:32,561 --> 00:15:42,561
[MUSIC]