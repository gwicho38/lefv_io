/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TodoistCompletedTasks
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/updateFileContent.ts
var import_obsidian4 = require("obsidian");

// src/fetchTasks.ts
var import_obsidian = require("obsidian");
function generateRawTodoistTask(task, isSubtaskRendering) {
  if (isSubtaskRendering) {
    return {
      taskId: task.item.id,
      parentId: task.item.parent_id,
      content: task.item.content,
      dateCompleted: task.item.completed_at,
      projectId: task.project.id
    };
  } else {
    return {
      taskId: task.task_id,
      parentId: null,
      content: task.content,
      dateCompleted: task.completed_at,
      projectId: task.project_id
    };
  }
}
async function fetchTasks(authToken, timeFrames, renderSubtasks) {
  const {
    timeStartFormattedDate,
    timeStartFormattedTime,
    timeEndFormattedDate,
    timeEndFormattedTime
  } = timeFrames;
  const limit = renderSubtasks ? 30 : 200;
  let mappedResults = [];
  try {
    const url = `https://api.todoist.com/sync/v9/completed/get_all?since=` + timeStartFormattedDate + `T` + timeStartFormattedTime + `&until=` + timeEndFormattedDate + `T` + timeEndFormattedTime + `&limit=${limit}`;
    const completedTasksMetadata = await fetch(url, {
      headers: {
        Authorization: `Bearer ${authToken}`
      }
    }).then(function(response) {
      return response.json();
    });
    if (completedTasksMetadata.items.length === 0) {
      return mappedResults;
    }
    const projectsMetadata = completedTasksMetadata.projects;
    new import_obsidian.Notice(completedTasksMetadata.items.length + " completed tasks found. Processing...");
    if (renderSubtasks) {
      const completedTasksPromises = completedTasksMetadata.items.map(async (task) => {
        return fetchSingleTask(authToken, task.task_id);
      });
      mappedResults = await Promise.all(completedTasksPromises);
      let childTasks = mappedResults.filter((task) => task.parentId !== null);
      let queuedParentTasks = [];
      childTasks.forEach((task) => {
        const parentTask = mappedResults.find((t) => t.taskId === task.parentId);
        if (!parentTask && !queuedParentTasks.includes(task.parentId)) {
          let missedParentTask = fetchSingleTask(authToken, task.parentId);
          mappedResults.push(missedParentTask);
          queuedParentTasks.push(task.parentId);
        }
      });
      mappedResults = await Promise.all(mappedResults);
      mappedResults.forEach((task) => {
        const taskMetadata = completedTasksMetadata.items.find((t) => t.task_id === task.taskId);
        if (!taskMetadata) {
          task.dateCompleted = null;
        } else {
          task.dateCompleted = taskMetadata.completed_at;
        }
      });
    } else {
      mappedResults = completedTasksMetadata.items.map((task) => {
        return generateRawTodoistTask(task, renderSubtasks);
      });
    }
    return {
      tasksResults: mappedResults,
      projectsResults: projectsMetadata
    };
  } catch (e) {
    let errorMsg = "";
    switch (e.httpStatusCode) {
      case void 0:
        errorMsg = `There was a problem pulling data from Todoist. Is your internet connection working?`;
        break;
      case 403:
        errorMsg = "Authentication with todoist server failed. Check that your API token is set correctly in the settings.";
        break;
      default:
        `There was a problem pulling data from Todoist. ${e.responseData}`;
    }
    console.log(errorMsg, e);
    new import_obsidian.Notice(errorMsg);
    throw e;
  }
}
async function fetchSingleTask(authToken, parentId) {
  try {
    const url = `https://api.todoist.com/sync/v9/items/get?item_id=${parentId}`;
    let parentTask = await fetch(url, {
      headers: {
        Authorization: `Bearer ${authToken}`
      }
    });
    const task = await parentTask.json();
    return generateRawTodoistTask(task, true);
  } catch (e) {
    let errorMsg = "";
    switch (e.httpStatusCode) {
      case void 0:
        errorMsg = `There was a problem pulling data from Todoist. Is your internet connection working?`;
        break;
      case 403:
        errorMsg = "Authentication with todoist server failed. Check that your API token is set correctly in the settings.";
        break;
      default:
        `There was a problem pulling data from Todoist. ${e.responseData}`;
    }
    console.log(errorMsg, e);
    new import_obsidian.Notice(errorMsg);
    throw e;
  }
}

// src/formatTasks.ts
var import_obsidian2 = require("obsidian");
function prepareTasksForRendering(tasks) {
  let childTasks = tasks.filter((task) => task.parentId !== null);
  let renderedTasks = [];
  function convertToDateObj(date) {
    if (date === null) {
      return null;
    }
    return new Date(date);
  }
  tasks.forEach((task) => {
    if (task.parentId === null) {
      renderedTasks.push({
        taskId: task.taskId,
        content: task.content,
        dateCompleted: convertToDateObj(task.dateCompleted),
        projectId: task.projectId,
        childTasks: []
      });
    }
  });
  childTasks.forEach(async (task) => {
    const parentTaskIndex = renderedTasks.findIndex((t) => t.taskId === task.parentId);
    renderedTasks[parentTaskIndex].childTasks.push({
      taskId: task.taskId,
      content: task.content,
      dateCompleted: convertToDateObj(task.dateCompleted),
      projectId: task.projectId,
      childTasks: []
    });
  });
  return renderedTasks;
}
function renderTasksAsText(tasks, projectsMetadata, settings) {
  function renderTaskFinishDate(task) {
    if (task.dateCompleted === null) {
      return "N/A";
    }
    if (settings.taskPostfix.includes("{task_finish_date}")) {
      const formattedDate = (0, import_obsidian2.moment)(task.dateCompleted).format("YYYY-MM-DD");
      return formattedDate;
    }
    if (settings.taskPostfix.includes("{task_finish_datetime}")) {
      const formattedDate = (0, import_obsidian2.moment)(task.dateCompleted).format("YYYY-MM-DD HH:mm");
      return formattedDate;
    }
    if (settings.taskPostfix.includes("{current_date}")) {
      const formattedDate = (0, import_obsidian2.moment)(task.dateCompleted).format("YYYY-MM-DD");
      return formattedDate;
    }
    if (settings.taskPostfix.includes("{current_datetime}")) {
      const formattedDate = (0, import_obsidian2.moment)(task.dateCompleted).format("YYYY-MM-DD HH:mm");
      return formattedDate;
    }
  }
  function renderTaskPostfix(task) {
    let regex = /{task_finish_date}|{task_finish_datetime}|{current_date}|{current_datetime}/g;
    return settings.taskPostfix.replace(regex, renderTaskFinishDate(task));
  }
  function renderTaskPrefix(task, index) {
    let regex = /{auto_increment}/g;
    return settings.taskPrefix.replace(regex, `${index + 1}`);
  }
  try {
    let renderProjectHeader = function(project) {
      if (settings.renderProjectsHeaders) {
        return `
* ${project.name}
`;
      }
      return "";
    }, renderTaskText = function(tasks2, settings2) {
      return tasks2.reverse().map((t, index) => {
        let formattedParentPrefix = renderTaskPrefix(t, index);
        let formattedParentPostfix = renderTaskPostfix(t);
        let returnString = "";
        if (settings2.renderProjectsHeaders) {
          returnString = `    ${formattedParentPrefix} ${t.content} ${formattedParentPostfix}`;
        } else {
          returnString = `${formattedParentPrefix} ${t.content} ${formattedParentPostfix}`;
        }
        if (t.childTasks.length > 0) {
          const childTasks = t.childTasks.reverse().map((childTask, index2) => {
            let formattedChildPrefix = renderTaskPrefix(childTask, index2);
            let formattedPostfix = renderTaskPostfix(childTask);
            if (settings2.renderProjectsHeaders) {
              return `        ${formattedChildPrefix} ${childTask.content} ${formattedPostfix}`;
            } else {
              return `    ${formattedChildPrefix} ${childTask.content} ${formattedPostfix}`;
            }
          });
          returnString += "\n" + childTasks.join("\n");
        }
        return returnString;
      });
    };
    let allTasks = "";
    if (settings.renderProjectsHeaders) {
      for (const [key, project] of Object.entries(projectsMetadata)) {
        let projectTasks = tasks.filter((task) => task.projectId === key);
        allTasks += renderProjectHeader(project);
        let formattedTasks = renderTaskText(projectTasks, settings);
        allTasks += formattedTasks.join("\n");
      }
      allTasks = allTasks + `
`;
      return allTasks;
    } else {
      let formattedTasks = renderTaskText(tasks, settings);
      formattedTasks = formattedTasks.join("\n");
      formattedTasks = `
` + formattedTasks + `
`;
      return formattedTasks;
    }
  } catch (error) {
    console.log(error);
    new import_obsidian2.Notice("There was a problem formatting your tasks. Check the console for more details.", 1e4);
    return "";
  }
}

// src/constants.ts
var CONSTANTS_SEGMENTS = {
  templatedSegmentStart: "%% TCT_TEMPLATED_START 1999-12-01 00:00 %%",
  templatedSegmentEnd: "%% TCT_TEMPLATED_END 2022-04-28 23:59 %%"
};
var CONSTANTS_REGEX = {
  regexStartCompiled: new RegExp(`(${CONSTANTS_SEGMENTS.templatedSegmentStart.slice(0, 22)})+( \\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2} )+(${CONSTANTS_SEGMENTS.templatedSegmentStart.slice(0, 2)})`, "g"),
  regexEndCompiled: new RegExp(`(${CONSTANTS_SEGMENTS.templatedSegmentEnd.slice(0, 20)})+( \\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2} )+(${CONSTANTS_SEGMENTS.templatedSegmentEnd.slice(0, 2)})`, "g")
};
var FETCH_STRATEGIES = {
  today: "today",
  lastNHours: "lastNHours",
  fromFile: "fromFile"
};

// src/utils.ts
var import_obsidian3 = require("obsidian");
function getTimeframesForUsersToday() {
  let currentTime = new Date();
  currentTime.setHours(0, 0, 0, 0);
  const taskStartInServerTime = currentTime.getTime() + currentTime.getTimezoneOffset() * 60 * 1e3;
  const timeStartFormattedDate = (0, import_obsidian3.moment)(taskStartInServerTime).format("YYYY-MM-DD");
  const timeStartFormattedTime = (0, import_obsidian3.moment)(taskStartInServerTime).format("HH:mm");
  const taskEndInServerTime = currentTime.getTime() + currentTime.getTimezoneOffset() * 60 * 1e3 + 24 * 60 * 60 * 1e3;
  const timeEndFormattedDate = (0, import_obsidian3.moment)(taskEndInServerTime).format("YYYY-MM-DD");
  const timeEndFormattedTime = (0, import_obsidian3.moment)(taskEndInServerTime).format("HH:mm");
  return {
    timeStartFormattedDate,
    timeStartFormattedTime,
    timeEndFormattedDate,
    timeEndFormattedTime
  };
}
function getTimeframesForLastNHours(hours) {
  let currentTime = new Date();
  const taskStartInServerTime = currentTime.getTime() + currentTime.getTimezoneOffset() * 60 * 1e3 - hours * 60 * 60 * 1e3;
  const timeStartFormattedDate = (0, import_obsidian3.moment)(taskStartInServerTime).format("YYYY-MM-DD");
  const timeStartFormattedTime = (0, import_obsidian3.moment)(taskStartInServerTime).format("HH:mm");
  const taskEndInServerTime = currentTime.getTime() + currentTime.getTimezoneOffset() * 60 * 1e3;
  const timeEndFormattedDate = (0, import_obsidian3.moment)(taskEndInServerTime).format("YYYY-MM-DD");
  const timeEndFormattedTime = (0, import_obsidian3.moment)(taskEndInServerTime).format("HH:mm");
  return {
    timeStartFormattedDate,
    timeStartFormattedTime,
    timeEndFormattedDate,
    timeEndFormattedTime
  };
}
function getTimeframesForLastNHoursWithoutOffset(hours) {
  let currentTime = new Date();
  const taskStartInServerTime = currentTime.getTime() - hours * 60 * 60 * 1e3;
  const timeStartFormattedDate = (0, import_obsidian3.moment)(taskStartInServerTime).format("YYYY-MM-DD");
  const timeStartFormattedTime = (0, import_obsidian3.moment)(taskStartInServerTime).format("HH:mm");
  const taskEndInServerTime = currentTime.getTime();
  const timeEndFormattedDate = (0, import_obsidian3.moment)(taskEndInServerTime).format("YYYY-MM-DD");
  const timeEndFormattedTime = (0, import_obsidian3.moment)(taskEndInServerTime).format("HH:mm");
  return {
    timeStartFormattedDate,
    timeStartFormattedTime,
    timeEndFormattedDate,
    timeEndFormattedTime
  };
}
function getTimeFromKeySegments(fileContent) {
  const startString = fileContent.match(CONSTANTS_REGEX.regexStartCompiled);
  const endString = fileContent.match(CONSTANTS_REGEX.regexEndCompiled);
  let datetimeRegex = /(\d{4}-\d{2}-\d{2} \d{2}:\d{2})/;
  const startDateString = startString[0].match(datetimeRegex);
  const endDateString = endString[0].match(datetimeRegex);
  let currentTimeObj = new Date();
  let startTimeObj = new Date(startDateString[0]);
  let endTimeObj = new Date(endDateString[0]);
  const taskStartInServerTime = startTimeObj.getTime() + currentTimeObj.getTimezoneOffset() * 60 * 1e3;
  const timeStartFormattedDate = (0, import_obsidian3.moment)(taskStartInServerTime).format("YYYY-MM-DD");
  const timeStartFormattedTime = (0, import_obsidian3.moment)(taskStartInServerTime).format("HH:mm");
  const taskEndInServerTime = endTimeObj.getTime() + currentTimeObj.getTimezoneOffset() * 60 * 1e3;
  const timeEndFormattedDate = (0, import_obsidian3.moment)(taskEndInServerTime).format("YYYY-MM-DD");
  const timeEndFormattedTime = (0, import_obsidian3.moment)(taskEndInServerTime).format("HH:mm");
  if (timeStartFormattedDate === "Invalid date" || timeEndFormattedDate === "Invalid date") {
    return null;
  }
  return {
    timeStartFormattedDate,
    timeStartFormattedTime,
    timeEndFormattedDate,
    timeEndFormattedTime,
    startString,
    endString
  };
}
function settingsCheck(settings) {
  if (settings.keywordSegmentStart === "" || settings.keywordSegmentEnd === "") {
    new import_obsidian3.Notice("No keyword segment set. Please set one in the settings.", 1e4);
    return false;
  }
  if (settings.authToken === "") {
    new import_obsidian3.Notice("No auth token set. Please set one in the settings.", 1e4);
    return false;
  }
  return true;
}
function segmentsCheck(fileContent, settings, fetchStrategy) {
  if (fetchStrategy === FETCH_STRATEGIES.fromFile) {
    const startString = fileContent.match(CONSTANTS_REGEX.regexStartCompiled);
    const endString = fileContent.match(CONSTANTS_REGEX.regexEndCompiled);
    if (startString === null || endString === null) {
      new import_obsidian3.Notice(`Keyword segment not found in current file. You are using templated segments. 
Please follow this format: 
${CONSTANTS_SEGMENTS.templatedSegmentStart} 
${CONSTANTS_SEGMENTS.templatedSegmentEnd}`, 1e4);
      return false;
    }
  }
  if (fetchStrategy === FETCH_STRATEGIES.today || fetchStrategy === FETCH_STRATEGIES.lastNHours) {
    if (!fileContent.includes(settings.keywordSegmentStart) || !fileContent.includes(settings.keywordSegmentEnd)) {
      new import_obsidian3.Notice(`Keyword segment not found in current file. Please add: 
'${settings.keywordSegmentStart}' 
and 
'${settings.keywordSegmentEnd}' 
to the file.`, 1e4);
      return false;
    }
  }
  return true;
}

// src/updateFileContent.ts
async function updateFileFromServer(settings, app, time, fetchStrategy) {
  const editor = app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView).editor;
  const fileContent = editor.getValue();
  if (!settingsCheck(settings) || !segmentsCheck(fileContent, settings, fetchStrategy)) {
    return;
  }
  let timeFrames = null;
  if (fetchStrategy === FETCH_STRATEGIES.today) {
    timeFrames = getTimeframesForUsersToday();
  }
  if (fetchStrategy === FETCH_STRATEGIES.lastNHours) {
    timeFrames = getTimeframesForLastNHours(time);
  }
  if (fetchStrategy === FETCH_STRATEGIES.fromFile) {
    timeFrames = getTimeFromKeySegments(fileContent);
  }
  if (timeFrames === null) {
    new import_obsidian4.Notice("Invalid time frame.", 1e4);
    return;
  }
  const fetchResults = await fetchTasks(settings.authToken, timeFrames, settings.renderSubtasks);
  if (fetchResults.tasksResults.length === 0) {
    new import_obsidian4.Notice("No completed tasks found for the given timeframe");
    return;
  }
  let formattedTasks = prepareTasksForRendering(fetchResults.tasksResults);
  let renderedText = renderTasksAsText(formattedTasks, fetchResults.projectsResults, settings);
  let rangeStart = fileContent.indexOf(settings.keywordSegmentStart);
  let rangeEnd = fileContent.indexOf(settings.keywordSegmentEnd);
  if (fetchStrategy === FETCH_STRATEGIES.fromFile) {
    rangeStart = fileContent.indexOf(timeFrames.startString);
    rangeEnd = fileContent.indexOf(timeFrames.endString);
    renderedText = `${timeFrames.startString}${renderedText}`;
  } else {
    renderedText = `${settings.keywordSegmentStart}${renderedText}`;
  }
  editor.replaceRange(renderedText, editor.offsetToPos(rangeStart), editor.offsetToPos(rangeEnd));
  new import_obsidian4.Notice("Completed tasks loaded.");
}

// src/DefaultSettings.ts
var DEFAULT_SETTINGS = {
  settingsVersion: 4,
  keywordSegmentStart: "%% COMPLETED_TODOIST_TASKS_START %%",
  keywordSegmentEnd: "%% COMPLETED_TODOIST_TASKS_END %%",
  authToken: "",
  taskPrefix: "*",
  taskPostfix: "",
  renderSubtasks: true,
  renderProjectsHeaders: true
};

// src/settingsMigrations.ts
function migrateSettings(settings) {
  let newSettings = settings;
  if (getSettingsVersion(newSettings) == 0) {
    newSettings = migrateToV1(settings);
  }
  if (getSettingsVersion(newSettings) == 1) {
    newSettings = migrateToV2(newSettings);
  }
  if (getSettingsVersion(newSettings) == 2) {
    newSettings = migrateToV3(newSettings);
  }
  if (getSettingsVersion(newSettings) == 3) {
    newSettings = migrateToV4(newSettings);
  }
  if (getSettingsVersion(newSettings) == 4) {
    newSettings = migrateToLatest(newSettings);
  }
  return newSettings;
}
function getSettingsVersion(settings) {
  var _a;
  return (_a = settings.settingsVersion) != null ? _a : 0;
}
function migrateToV1(settings) {
  return {
    settingsVersion: 1,
    keywordSegmentStart: DEFAULT_SETTINGS.keywordSegmentStart,
    keywordSegmentEnd: DEFAULT_SETTINGS.keywordSegmentEnd,
    authToken: settings.authToken
  };
}
function migrateToV2(settings) {
  return {
    settingsVersion: 2,
    keywordSegmentStart: settings.keywordSegmentStart,
    keywordSegmentEnd: settings.keywordSegmentEnd,
    authToken: settings.authToken,
    taskPrefix: DEFAULT_SETTINGS.taskPrefix
  };
}
function migrateToV3(settings) {
  return {
    settingsVersion: 3,
    keywordSegmentStart: settings.keywordSegmentStart,
    keywordSegmentEnd: settings.keywordSegmentEnd,
    authToken: settings.authToken,
    taskPrefix: settings.taskPrefix,
    renderSubtasks: DEFAULT_SETTINGS.renderSubtasks
  };
}
function migrateToV4(settings) {
  return {
    settingsVersion: 4,
    keywordSegmentStart: settings.keywordSegmentStart,
    keywordSegmentEnd: settings.keywordSegmentEnd,
    authToken: settings.authToken,
    taskPrefix: settings.taskPrefix,
    taskPostfix: DEFAULT_SETTINGS.taskPostfix,
    renderSubtasks: settings.renderSubtasks
  };
}
function migrateToLatest(settings) {
  return {
    settingsVersion: 5,
    keywordSegmentStart: settings.keywordSegmentStart,
    keywordSegmentEnd: settings.keywordSegmentEnd,
    authToken: settings.authToken,
    taskPrefix: settings.taskPrefix,
    taskPostfix: settings.taskPostfix,
    renderSubtasks: settings.renderSubtasks,
    renderProjectsHeaders: DEFAULT_SETTINGS.renderProjectsHeaders
  };
}

// src/modal.ts
var import_obsidian5 = require("obsidian");
var ExampleModal = class extends import_obsidian5.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", {
      text: "Fetch completed tasks for last N hours"
    });
    new import_obsidian5.Setting(contentEl).setName("Hours").addText((text) => text.onChange((value) => {
      this.result = value;
    }));
    new import_obsidian5.Setting(contentEl).addButton((btn) => btn.setButtonText("Fetch").setCta().onClick(() => {
      this.close();
      this.onSubmit(this.result);
    }));
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};

// src/settingsTabs.ts
var import_obsidian6 = require("obsidian");
var TodoistPluginSettingTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Todoist Completed Tasks" });
    containerEl.createEl("a", {
      text: "Important - see usage instructions",
      href: "https://github.com/Ledaryy/obsidian-todoist-completed-tasks"
    });
    this.addApiKeySetting(containerEl);
    this.addStartLineDetector(containerEl);
    this.addEndLineDetector(containerEl);
    this.addTaskPrefix(containerEl);
    this.addTaskPostfix(containerEl);
    this.addProjectsRenderSwitch(containerEl);
    this.addSubtaskRenderSwitch(containerEl);
  }
  addApiKeySetting(containerEl) {
    const fieldDescription = document.createDocumentFragment();
    fieldDescription.createEl("span", null, (span) => {
      span.innerText = 'This is your personal authentication token for Todoist. Be aware that anyone with this token could access all of your Todoist data. This is stored in plain text in your .obsidian/plugins folder. Ensure that you are comfortable with the security implications before proceeding. \nYou can get your token from the "API token" section ';
      span.createEl("a", null, (link) => {
        link.href = "https://todoist.com/prefs/integrations";
        link.innerText = "here.";
      });
    });
    new import_obsidian6.Setting(containerEl).setName("API token").setDesc(fieldDescription).addText((text) => text.setValue(this.plugin.settings.authToken).onChange(async (value) => {
      this.plugin.settings.authToken = value;
      await this.plugin.saveSettings();
    }));
  }
  addStartLineDetector(containerEl) {
    const fieldDescription = document.createDocumentFragment();
    fieldDescription.createEl("span", null, (span) => {
      span.innerText = "Segment for the plugin to detect the start of tasks. \nSupports Obsidian's comments syntax.";
    });
    new import_obsidian6.Setting(containerEl).setName("Start segment").setDesc(fieldDescription).addText((text) => text.setValue(this.plugin.settings.keywordSegmentStart).onChange(async (value) => {
      this.plugin.settings.keywordSegmentStart = value;
      await this.plugin.saveSettings();
    }));
  }
  addEndLineDetector(containerEl) {
    const fieldDescription = document.createDocumentFragment();
    fieldDescription.createEl("span", null, (span) => {
      span.innerText = "Segment for the plugin to detect the end of tasks. \nSupports Obsidian's comments syntax.";
    });
    new import_obsidian6.Setting(containerEl).setName("End segment").setDesc(fieldDescription).addText((text) => text.setValue(this.plugin.settings.keywordSegmentEnd).onChange(async (value) => {
      this.plugin.settings.keywordSegmentEnd = value;
      await this.plugin.saveSettings();
    }));
  }
  addTaskPrefix(containerEl) {
    const fieldDescription = document.createDocumentFragment();
    fieldDescription.createEl("span", null, (span) => {
      span.innerText = 'Set prefix for tasks. Popular usecases:\n"*" - Bullet points\n"- [x]" - Completed checkboxes\n"{auto_increment}. " - Ideally works with obsidian markdown and marks tasks and subtasks as a lists\n\nThe special parameter "{auto_increment}" will be replaced with an auto-increment number.\nFor all other parameters, refer to the ';
      span.createEl("a", null, (link) => {
        link.href = "https://www.markdownguide.org/tools/obsidian/";
        link.innerText = "Obsidian Markdown";
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Prefix").setDesc(fieldDescription).addText((text) => text.setValue(this.plugin.settings.taskPrefix).onChange(async (value) => {
      this.plugin.settings.taskPrefix = value;
      await this.plugin.saveSettings();
    }));
  }
  addTaskPostfix(containerEl) {
    const fieldDescription = document.createDocumentFragment();
    fieldDescription.createEl("span", null, (span) => {
      span.innerText = 'Set postfix for tasks. Popular usecases:\n"\u{1F4AA}" - Keep it up!\n"\u2705{task_finish_date}" - to make it compatible with ';
      span.createEl("a", null, (link) => {
        link.href = "https://github.com/obsidian-tasks-group/obsidian-tasks";
        link.innerText = "Obsidian Tasks";
      });
      span.createEl("p", null, (textSpace) => {
        textSpace.innerText = `The special parameter "{current_date}" will be replaced with current date in "YYYY-MM-DD" format.
Another special parameter "{task_finish_date}" will be replaced with task finish date in "YYYY-MM-DD" format.
Also you can use {task_finish_datetime} and {current_datetime} to get date and time in "YYYY-MM-DD HH:MM:SS" format.
Note: Non-completed parent tasks can have completed subtasks, 'N/A' will be used for the parent in this case.`;
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Postfix").setDesc(fieldDescription).addText((text) => text.setValue(this.plugin.settings.taskPostfix).onChange(async (value) => {
      this.plugin.settings.taskPostfix = value;
      await this.plugin.saveSettings();
    }));
  }
  addProjectsRenderSwitch(containerEl) {
    const fieldDescription = document.createDocumentFragment();
    fieldDescription.createEl("span", null, (span) => {
      span.innerText = "Renders projects names as headers. \nIf disabled, projects names will not be rendered at all.";
    });
    new import_obsidian6.Setting(containerEl).setName("Render projects names").setDesc(fieldDescription).addToggle((toggle) => toggle.setValue(this.plugin.settings.renderProjectsHeaders).onChange(async (value) => {
      this.plugin.settings.renderProjectsHeaders = value;
      await this.plugin.saveSettings();
    }));
  }
  addSubtaskRenderSwitch(containerEl) {
    const fieldDescription = document.createDocumentFragment();
    fieldDescription.createEl("span", null, (span) => {
      span.innerText = "You should disable this if you want to load more than 30 (up to 200) tasks. This is due to a limitation of the Todoist API.\nIf enabled, subtasks will be rendered as subtasks. \nIf disabled, subtasks will be rendered as normal tasks.\nDramatically increases loading time if enabled.";
    });
    new import_obsidian6.Setting(containerEl).setName("Render subtasks").setDesc(fieldDescription).addToggle((toggle) => toggle.setValue(this.plugin.settings.renderSubtasks).onChange(async (value) => {
      this.plugin.settings.renderSubtasks = value;
      await this.plugin.saveSettings();
    }));
  }
};

// main.ts
var TodoistCompletedTasks = class extends import_obsidian7.Plugin {
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("sync", "Fetch today's completed tasks", (evt) => {
      new import_obsidian7.Notice("Fetching completed tasks..");
      updateFileFromServer(this.settings, this.app, 0, FETCH_STRATEGIES.today);
    });
    this.addCommand({
      id: "todoist-fetch-completed-tasks",
      name: "Fetch today's completed tasks",
      callback: async () => {
        new import_obsidian7.Notice("Fetching completed tasks..");
        updateFileFromServer(this.settings, this.app, 0, FETCH_STRATEGIES.today);
      }
    });
    this.addCommand({
      id: "todoist-fetch-completed-tasks",
      name: "Fetch completed tasks using dates in segments",
      callback: async () => {
        new import_obsidian7.Notice("Fetching completed tasks..");
        updateFileFromServer(this.settings, this.app, 0, FETCH_STRATEGIES.fromFile);
      }
    });
    this.addCommand({
      id: "todoist-fetch-completed-tasks-for-last-n-hours",
      name: "Fetch completed tasks for last N hours",
      callback: async () => {
        new ExampleModal(this.app, (result) => {
          if (result == null || result == "" || isNaN(Number(result)) || Number(result) < 0) {
            new import_obsidian7.Notice("Please enter a valid number of hours");
            return;
          }
          let times = getTimeframesForLastNHoursWithoutOffset(Number(result));
          const {
            timeStartFormattedDate,
            timeStartFormattedTime,
            timeEndFormattedDate,
            timeEndFormattedTime
          } = times;
          if (this.settings.renderSubtasks) {
            new import_obsidian7.Notice(`You are fetching completed tasks with "Render subtasks" enabled. 
This will limit the number of tasks fetched to 30.
Message will be removed after 30 sec.`, 3e4);
          }
          new import_obsidian7.Notice(`Fetching completed tasks for last ${result} hours.. 
Timerange, from: 
${timeStartFormattedDate} ${timeStartFormattedTime} 
to: 
${timeEndFormattedDate} ${timeEndFormattedTime}. 
Message will be removed after 30 sec.`, 3e4);
          updateFileFromServer(this.settings, this.app, Number(result), FETCH_STRATEGIES.lastNHours);
        }).open();
      }
    });
    this.addSettingTab(new TodoistPluginSettingTab(this.app, this));
  }
  async loadSettings() {
    var _a;
    let storedSettings = (_a = await this.loadData()) != null ? _a : DEFAULT_SETTINGS;
    this.settings = migrateSettings(storedSettings);
    await this.saveSettings();
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
