/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
var main_exports = {};
__export(main_exports, {
  AgileTaskNotesPluginSettingTab: () => AgileTaskNotesPluginSettingTab,
  default: () => AgileTaskNotesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/Clients/AzureDevopsClient.ts
var import_obsidian2 = require("obsidian");

// src/VaultHelper.ts
var import_obsidian = require("obsidian");
var _VaultHelper = class {
  static logError(error) {
    console.log(error);
    new import_obsidian.Notice("Error occured, see console logs for details. (ctrl+shift+i) to open");
  }
  static createFolders(path) {
    if (app.vault.getAbstractFileByPath(path) == null) {
      app.vault.createFolder(path).catch((err) => console.log(err));
    }
  }
  static createFoldersFromList(paths) {
    paths.forEach((path) => this.createFolders(path));
  }
  static getFileByTaskId(path, id) {
    const files = app.vault.getMarkdownFiles();
    const projectPath = path.slice(0, path.lastIndexOf("/"));
    for (let i = 0; i < files.length; i++) {
      let filePath = files[i].path;
      if (filePath.startsWith(projectPath) && filePath.contains(id)) {
        return files[i];
      }
    }
    return void 0;
  }
  static formatTaskFilename(type, id) {
    return `${type} - ${id}`;
  }
  static createTaskNotes(path, tasks, template) {
    let promisesToCreateNotes = [];
    tasks.forEach((task) => {
      if (this.getFileByTaskId(path, task.id) == void 0) {
        promisesToCreateNotes.push(this.createTaskNote(path, task, template));
      }
    });
    return promisesToCreateNotes;
  }
  static createKanbanBoard(path, tasks, columns, prefix, teamLeaderMode) {
    const filename = `${prefix}-Board`;
    const filepath = path + `/${filename}.md`;
    let boardMD = this.BOARD_TEMPLATE_START;
    columns.forEach((column) => {
      boardMD += "## ";
      boardMD += column;
      boardMD += "\n";
      tasks.forEach((task) => {
        if (task.state === column) {
          var file = this.getFileByTaskId(path, task.id);
          if (file != void 0) {
            if (teamLeaderMode) {
              boardMD += `- [ ] [[${file.basename}]] 
 ${task.assignedTo} 
 ${task.title}
`;
            } else {
              boardMD += `- [ ] [[${file.basename}]] 
 ${task.title}
`;
            }
          }
        }
      });
      boardMD += "\n";
    });
    boardMD += this.BOARD_TEMPLATE_END;
    return app.vault.adapter.write(filepath, boardMD);
  }
  static createTaskNote(path, task, template) {
    return __async(this, null, function* () {
      const filename = _VaultHelper.formatTaskFilename(task.type, task.id);
      const filepath = path + `/${filename}.md`;
      let content = template.replace(/{{TASK_ID}}/g, task.id).replace(/{{TASK_TITLE}}/g, task.title).replace(/{{TASK_STATE}}/g, task.state).replace(/{{TASK_TYPE}}/g, task.type.replace(/ /g, "")).replace(/{{TASK_ASSIGNEDTO}}/g, task.assignedTo).replace(/{{TASK_LINK}}/g, task.link);
      if (task.desc != null) {
        content = content.replace(/{{TASK_DESCRIPTION}}/g, task.desc);
      } else {
        content = content.replace(/{{TASK_DESCRIPTION}}/g, "");
      }
      return app.vault.create(filepath, content);
    });
  }
};
var VaultHelper = _VaultHelper;
VaultHelper.BOARD_TEMPLATE_START = "---\n\nkanban-plugin: basic\n\n---\n\n";
VaultHelper.BOARD_TEMPLATE_END = '\n%% kanban:settings\n```\n{"kanban-plugin":"basic"}\n```%%"';

// src/Task.ts
var Task = class {
  constructor(id, state, title, type, assignedTo, link, desc) {
    this.id = id;
    this.state = state;
    this.title = title;
    this.type = type;
    this.assignedTo = assignedTo;
    this.link = link;
    this.desc = desc;
  }
};

// src/Clients/AzureDevopsClient.ts
var AZURE_DEVOPS_DEFAULT_SETTINGS = {
  instance: "",
  collection: "",
  project: "",
  team: "",
  usernames: "",
  accessToken: "",
  columns: "Pending,In Progress,In Merge,In Verification,Closed"
};
var TASKS_QUERY = '{"query": "Select [System.Id], [System.Title], [System.State] From WorkItems Where [System.IterationPath] UNDER \\"{0}\\"{1}"}';
var USER_OPERAND = '[Assigned to] = \\"{0}\\"';
var AzureDevopsClient = class {
  constructor() {
    this.clientName = "AzureDevops";
  }
  update(settings) {
    return __async(this, null, function* () {
      const encoded64PAT = Buffer.from(`:${settings.azureDevopsSettings.accessToken}`).toString("base64");
      const headers = {
        "Authorization": `Basic ${encoded64PAT}`,
        "Content-Type": "application/json"
      };
      const BaseURL = `https://${settings.azureDevopsSettings.instance}/${settings.azureDevopsSettings.collection}/${settings.azureDevopsSettings.project}`;
      try {
        const iterationResponse = yield (0, import_obsidian2.requestUrl)({
          method: "GET",
          headers,
          url: `${BaseURL}/${settings.azureDevopsSettings.team}/_apis/work/teamsettings/iterations?$timeframe=current&api-version=6.0`
        });
        const currentSprint = iterationResponse.json.value[0];
        const normalizeIterationPath = currentSprint.path.normalize().replace(/\\/g, "\\\\");
        var taskIds;
        if (settings.teamLeaderMode) {
          console.log(TASKS_QUERY.format(normalizeIterationPath, ""));
          const tasksReponse = yield (0, import_obsidian2.requestUrl)({
            method: "POST",
            body: TASKS_QUERY.format(normalizeIterationPath, ""),
            headers,
            url: `${BaseURL}/${settings.azureDevopsSettings.team}/_apis/wit/wiql?api-version=6.0`
          });
          taskIds = tasksReponse.json.workItems;
        } else {
          const usernames = settings.azureDevopsSettings.usernames.split(",").map((username) => username.trim().replace("'", "\\'"));
          let multiUserOperands = " AND ";
          for (let i = 0; i < usernames.length; i++) {
            multiUserOperands += USER_OPERAND.format(usernames[i]);
            if (i < usernames.length - 1) {
              multiUserOperands += " OR ";
            }
          }
          console.log(TASKS_QUERY.format(normalizeIterationPath, multiUserOperands));
          const tasksReponse = yield (0, import_obsidian2.requestUrl)({
            method: "POST",
            body: TASKS_QUERY.format(normalizeIterationPath, multiUserOperands),
            headers,
            url: `${BaseURL}/${settings.azureDevopsSettings.team}/_apis/wit/wiql?api-version=6.0`
          });
          taskIds = tasksReponse.json.workItems;
        }
        const normalizedFolderPath = (0, import_obsidian2.normalizePath)(settings.targetFolder + "/" + currentSprint.path);
        VaultHelper.createFolders(normalizedFolderPath);
        const assignedTasks = yield Promise.all(taskIds.map((task) => (0, import_obsidian2.requestUrl)({
          method: "GET",
          headers,
          url: task.url
        }).then((r) => r.json)));
        let tasks = [];
        assignedTasks.forEach((task) => {
          var _a;
          let assigneeName = "Unassigned";
          const assignee = (_a = task.fields["System.AssignedTo"]) != null ? _a : null;
          if (assignee !== null) {
            assigneeName = assignee["displayName"];
          }
          tasks.push(new Task(task.id, task.fields["System.State"], task.fields["System.Title"], task.fields["System.WorkItemType"], assigneeName, `https://${settings.azureDevopsSettings.instance}/${settings.azureDevopsSettings.collection}/${settings.azureDevopsSettings.project}/_workitems/edit/${task.id}`, task.fields["System.Description"]));
        });
        yield Promise.all(VaultHelper.createTaskNotes(normalizedFolderPath, tasks, settings.noteTemplate)).catch((e) => VaultHelper.logError(e));
        if (settings.createKanban) {
          const columnIds = settings.azureDevopsSettings.columns.split(",").map((columnName) => columnName.trim());
          yield VaultHelper.createKanbanBoard(normalizedFolderPath, tasks, columnIds, currentSprint.name, settings.teamLeaderMode).catch((e) => VaultHelper.logError(e));
        }
      } catch (e) {
        VaultHelper.logError(e);
      }
    });
  }
  setupSettings(container, plugin, settingsTab) {
    container.createEl("h2", { text: "AzureDevops Remote Repo Settings" });
    new import_obsidian2.Setting(container).setName("Instance").setDesc("TFS server name (ex: dev.azure.com/OrgName)").addText((text) => text.setPlaceholder("Enter instance base url").setValue(plugin.settings.azureDevopsSettings.instance).onChange((value) => __async(this, null, function* () {
      plugin.settings.azureDevopsSettings.instance = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian2.Setting(container).setName("Collection").setDesc("The name of the Azure DevOps collection (leave empty if it does not apply)").addText((text) => text.setPlaceholder("Enter Collection Name").setValue(plugin.settings.azureDevopsSettings.collection).onChange((value) => __async(this, null, function* () {
      plugin.settings.azureDevopsSettings.collection = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian2.Setting(container).setName("Project").setDesc("AzureDevops Project ID or project name").addText((text) => text.setPlaceholder("Enter project name").setValue(plugin.settings.azureDevopsSettings.project).onChange((value) => __async(this, null, function* () {
      plugin.settings.azureDevopsSettings.project = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian2.Setting(container).setName("Team").setDesc("AzureDevops Team ID or team name").addText((text) => text.setPlaceholder("Enter team name").setValue(plugin.settings.azureDevopsSettings.team).onChange((value) => __async(this, null, function* () {
      plugin.settings.azureDevopsSettings.team = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian2.Setting(container).setName("Usernames").setDesc("A comma-separated list of usernames you want the tasks of. Simply put your username if you only need your own.").addText((text) => text.setPlaceholder("Enter usernames").setValue(plugin.settings.azureDevopsSettings.usernames).onChange((value) => __async(this, null, function* () {
      plugin.settings.azureDevopsSettings.usernames = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian2.Setting(container).setName("Personal Access Token").setDesc("Your AzureDevops PAT with full access").addText((text) => text.setPlaceholder("Enter your PAT").setValue(plugin.settings.azureDevopsSettings.accessToken).onChange((value) => __async(this, null, function* () {
      plugin.settings.azureDevopsSettings.accessToken = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian2.Setting(container).setName("Column Names").setDesc("Line-separated list of column key names from your team sprint board to be used in Kanban board").addText((text) => text.setPlaceholder("Enter comma-separated list").setValue(plugin.settings.azureDevopsSettings.columns).onChange((value) => __async(this, null, function* () {
      plugin.settings.azureDevopsSettings.columns = value;
      yield plugin.saveSettings();
    })));
  }
};

// src/Clients/JiraClient.ts
var import_obsidian3 = require("obsidian");
var JIRA_DEFAULT_SETTINGS = {
  baseUrl: "{yourserver}.atlassian.net",
  usernames: "",
  email: "",
  authmode: "basic",
  apiToken: "",
  boardId: "",
  useSprintName: true,
  mode: "sprints",
  excludeBacklog: false
};
var JiraClient = class {
  constructor() {
    this.clientName = "Jira";
  }
  update(settings) {
    return __async(this, null, function* () {
      var headers = {
        "Authorization": "",
        "Content-Type": "application/json"
      };
      if (settings.jiraSettings.authmode == "basic") {
        const encoded64Key = Buffer.from(`${settings.jiraSettings.email}:${settings.jiraSettings.apiToken}`).toString("base64");
        headers.Authorization = `Basic ${encoded64Key}`;
      } else if (settings.jiraSettings.authmode = "bearer") {
        headers.Authorization = `Bearer ${settings.jiraSettings.apiToken}`;
      }
      const BaseURL = `https://${settings.jiraSettings.baseUrl}/rest/agile/1.0`;
      try {
        if (settings.jiraSettings.mode == "sprints") {
          const sprintsResponse = yield (0, import_obsidian3.requestUrl)({ method: "GET", headers, url: `${BaseURL}/board/${settings.jiraSettings.boardId}/sprint?state=active` });
          const currentSprintId = sprintsResponse.json.values[0].id;
          const currentSprintName = sprintsResponse.json.values[0].name.replace(/Sprint/, "").replace(/Board/, "").replace(/^\s+|\s+$/g, "").replace(/[^a-zA-Z0-9 -]/g, "").replace(/\s+/g, "-").replace(/-+/g, "-");
          const sprintIdentifier = settings.jiraSettings.useSprintName ? currentSprintName : currentSprintId;
          const normalizedFolderPath = (0, import_obsidian3.normalizePath)(settings.targetFolder + "/sprint-" + sprintIdentifier);
          VaultHelper.createFolders(normalizedFolderPath);
          let tasks = [];
          let issueResponseList = [];
          if (settings.teamLeaderMode) {
            issueResponseList[0] = yield (0, import_obsidian3.requestUrl)({
              method: "GET",
              headers,
              url: `${BaseURL}/board/${settings.jiraSettings.boardId}/sprint/${currentSprintId}/issue?maxResults=1000`
            });
          } else {
            let usernames = settings.jiraSettings.usernames.split(",").map((username) => username.trim().replace("'", "\\'"));
            issueResponseList = yield Promise.all(usernames.map((username) => (0, import_obsidian3.requestUrl)({
              method: "GET",
              headers,
              url: `${BaseURL}/board/${settings.jiraSettings.boardId}/sprint/${currentSprintId}/issue?jql=assignee="${username}"&maxResults=1000`
            })));
          }
          issueResponseList.forEach((issueResponse) => {
            issueResponse.json.issues.forEach((issue) => {
              let assigneeName = "Unassigned";
              let assignee = issue.fields["assignee"];
              if (assignee !== null) {
                assigneeName = assignee["displayName"];
              }
              tasks.push(new Task(issue.key, issue.fields["status"]["name"], issue.fields["summary"], issue.fields["issuetype"]["name"], assigneeName, `https://${settings.jiraSettings.baseUrl}/browse/${issue.key}`, issue.fields["description"]));
            });
          });
          yield Promise.all(VaultHelper.createTaskNotes(normalizedFolderPath, tasks, settings.noteTemplate));
          if (settings.createKanban) {
            const boardConfigResponse = yield (0, import_obsidian3.requestUrl)({
              method: "GET",
              headers,
              url: `${BaseURL}/board/${settings.jiraSettings.boardId}/configuration`
            });
            const columnIds2 = boardConfigResponse.json.columnConfig.columns.map((column) => column.name);
            yield VaultHelper.createKanbanBoard(normalizedFolderPath, tasks, columnIds2, sprintIdentifier, settings.teamLeaderMode);
          }
        } else if (settings.jiraSettings.mode == "kanban") {
          const completedFolder = settings.targetFolder + "/Completed/";
          const normalizedBaseFolderPath = (0, import_obsidian3.normalizePath)(settings.targetFolder);
          const normalizedCompletedfolderPath = (0, import_obsidian3.normalizePath)(completedFolder);
          VaultHelper.createFoldersFromList([normalizedBaseFolderPath, normalizedCompletedfolderPath]);
          let activeTasks = [];
          let completedTasks = [];
          let issueResponseList = [];
          if (settings.teamLeaderMode) {
            issueResponseList[0] = yield (0, import_obsidian3.requestUrl)({
              method: "GET",
              headers,
              url: `${BaseURL}/board/${settings.jiraSettings.boardId}/issue?maxResults=1000`
            });
          } else {
            let usernames = settings.jiraSettings.usernames.split(",").map((username) => username.trim().replace("'", "\\'"));
            issueResponseList = yield Promise.all(usernames.map((username) => (0, import_obsidian3.requestUrl)({
              method: "GET",
              headers,
              url: `${BaseURL}/board/${settings.jiraSettings.boardId}/issue?jql=assignee="${username}"&maxResults=1000`
            })));
          }
          issueResponseList.forEach((issueResponse) => {
            issueResponse.json.issues.forEach((issue) => {
              if (!settings.jiraSettings.excludeBacklog || settings.jiraSettings.excludeBacklog && issue.fields["status"]["name"] !== "Backlog") {
                let assigneeName = "Unassigned";
                let assignee = issue.fields["assignee"];
                if (assignee !== null) {
                  assigneeName = assignee["displayName"];
                }
                let taskObj = new Task(issue.key, issue.fields["status"]["name"], issue.fields["summary"], issue.fields["issuetype"]["name"], assigneeName, `https://${settings.jiraSettings.baseUrl}/browse/${issue.key}`, issue.fields["description"]);
                if (issue.fields["resolution"] != null) {
                  completedTasks.push(taskObj);
                } else {
                  activeTasks.push(taskObj);
                }
              }
            });
          });
          yield Promise.all(VaultHelper.createTaskNotes(normalizedBaseFolderPath, activeTasks, settings.noteTemplate));
          yield Promise.all(VaultHelper.createTaskNotes(normalizedCompletedfolderPath, completedTasks, settings.noteTemplate));
          const completedTaskNoteFiles = completedTasks.map((task) => VaultHelper.getFileByTaskId(settings.targetFolder, task.id)).filter((file) => !!file);
          completedTaskNoteFiles.forEach((file) => app.vault.rename(file, (0, import_obsidian3.normalizePath)(completedFolder + file.name)));
          const activeTaskNoteFiles = activeTasks.map((task) => VaultHelper.getFileByTaskId(settings.targetFolder, task.id)).filter((file) => !!file);
          activeTaskNoteFiles.forEach((file) => app.vault.rename(file, (0, import_obsidian3.normalizePath)(settings.targetFolder + "/" + file.name)));
          if (settings.createKanban) {
            const boardConfigResponse = yield (0, import_obsidian3.requestUrl)({
              method: "GET",
              headers,
              url: `${BaseURL}/board/${settings.jiraSettings.boardId}/configuration`
            });
            var columnIds = boardConfigResponse.json.columnConfig.columns.map((column) => column.name);
            if (settings.jiraSettings.excludeBacklog) {
              columnIds = columnIds.filter((columnName) => columnName !== "Backlog");
            }
            yield VaultHelper.createKanbanBoard(normalizedBaseFolderPath, activeTasks.concat(completedTasks), columnIds, settings.jiraSettings.boardId, settings.teamLeaderMode);
          }
        }
      } catch (e) {
        VaultHelper.logError(e);
      }
    });
  }
  setupSettings(container, plugin, settingsTab) {
    container.createEl("h2", { text: "Jira Remote Repo Settings" });
    new import_obsidian3.Setting(container).setName("URL").setDesc("The base URL of your Jira server or {ip:port}").addText((text) => text.setPlaceholder("Enter Jira base URL").setValue(plugin.settings.jiraSettings.baseUrl).onChange((value) => __async(this, null, function* () {
      plugin.settings.jiraSettings.baseUrl = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian3.Setting(container).setName("Usernames").setDesc("A comma-separated list of usernames you want the tasks of. Simply put your username if you only need your own.").addText((text) => text.setPlaceholder("Enter usernames").setValue(plugin.settings.jiraSettings.usernames).onChange((value) => __async(this, null, function* () {
      plugin.settings.jiraSettings.usernames = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian3.Setting(container).setName("Email").setDesc("The email of your Atlassian account for Jira").addText((text) => text.setPlaceholder("Enter Atlassian email").setValue(plugin.settings.jiraSettings.email).onChange((value) => __async(this, null, function* () {
      plugin.settings.jiraSettings.email = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian3.Setting(container).setName("Authorization mode").setDesc("Set the mode of authorization to be used").addDropdown((dropdown) => {
      dropdown.addOption("basic", "Basic Auth");
      dropdown.addOption("bearer", "Personal Access Token");
      dropdown.setValue(plugin.settings.jiraSettings.authmode).onChange((value) => __async(this, null, function* () {
        plugin.settings.jiraSettings.authmode = value;
        yield plugin.saveSettings();
      }));
    });
    new import_obsidian3.Setting(container).setName("API Token").setDesc("The API token generated with your account").addText((text) => text.setPlaceholder("Enter API token").setValue(plugin.settings.jiraSettings.apiToken).onChange((value) => __async(this, null, function* () {
      plugin.settings.jiraSettings.apiToken = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian3.Setting(container).setName("Board ID").setDesc("The ID of your Scrum board (the number in the URL when viewing scrum board in browser) ").addText((text) => text.setPlaceholder("Enter Board ID").setValue(plugin.settings.jiraSettings.boardId).onChange((value) => __async(this, null, function* () {
      plugin.settings.jiraSettings.boardId = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian3.Setting(container).setName("Mode").setDesc("Set the mode corresponding to how you use Jira").addDropdown((dropdown) => {
      dropdown.addOption("sprints", "Sprints");
      dropdown.addOption("kanban", "Kanban");
      dropdown.setValue(plugin.settings.jiraSettings.mode).onChange((value) => __async(this, null, function* () {
        plugin.settings.jiraSettings.mode = value;
        yield plugin.saveSettings();
        settingsTab.display();
      }));
    });
    if (plugin.settings.jiraSettings.mode === "sprints") {
      new import_obsidian3.Setting(container).setName("Use Sprint Name (rather than id)").setDesc("Uses the Sprint's human assigned name").addToggle((text) => text.setValue(plugin.settings.jiraSettings.useSprintName).onChange((value) => __async(this, null, function* () {
        plugin.settings.jiraSettings.useSprintName = value;
        yield plugin.saveSettings();
      })));
    } else if (plugin.settings.jiraSettings.mode === "kanban") {
      new import_obsidian3.Setting(container).setName("Exclude Backlog").setDesc("Enable to prevent creation of issues from the backlog").addToggle((toggle) => toggle.setValue(plugin.settings.jiraSettings.excludeBacklog).onChange((value) => __async(this, null, function* () {
        plugin.settings.jiraSettings.excludeBacklog = value;
        yield plugin.saveSettings();
      })));
    }
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  selectedTfsClient: "AzureDevops",
  targetFolder: "",
  noteTemplate: "# {{TASK_TITLE}}\n#{{TASK_TYPE}}\n\nid: {{TASK_ID}}\nstate: {{TASK_STATE}}\nAssignedTo: {{TASK_ASSIGNEDTO}}\n\nLink: {{TASK_LINK}}\n\n{{TASK_DESCRIPTION}}\n\n#todo:\n- [ ] Create todo list\n- [ ] \n\n## Notes:\n",
  intervalMinutes: 0,
  createKanban: true,
  teamLeaderMode: false,
  azureDevopsSettings: AZURE_DEVOPS_DEFAULT_SETTINGS,
  jiraSettings: JIRA_DEFAULT_SETTINGS
};
var AgileTaskNotesPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.tfsClientImplementations = {};
  }
  onload() {
    return __async(this, null, function* () {
      const azureDevopsClient = new AzureDevopsClient();
      const jiraClient = new JiraClient();
      this.tfsClientImplementations[azureDevopsClient.clientName] = azureDevopsClient;
      this.tfsClientImplementations[jiraClient.clientName] = jiraClient;
      yield this.loadSettings();
      this.addRibbonIcon("dice", "Update TFS Tasks", () => {
        this.tfsClientImplementations[this.settings.selectedTfsClient].update(this.settings);
        new import_obsidian4.Notice("Updated current tasks successfully!");
      });
      this.addCommand({
        id: "update-tfs-tasks",
        name: "Update TFS Tasks",
        callback: () => {
          this.tfsClientImplementations[this.settings.selectedTfsClient].update(this.settings);
          new import_obsidian4.Notice("Updated current tasks successfully!");
        }
      });
      this.addSettingTab(new AgileTaskNotesPluginSettingTab(this.app, this));
      if (this.settings.intervalMinutes > 0) {
        this.registerInterval(window.setInterval(() => this.tfsClientImplementations[this.settings.selectedTfsClient].update(this.settings), this.settings.intervalMinutes * 6e4));
      }
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
var AgileTaskNotesPluginSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl, plugin } = this;
    containerEl.empty();
    new import_obsidian4.Setting(containerEl).setName("Backend TFS").setDesc("The type of TFS you use.").addDropdown((dropdown) => {
      for (const client in plugin.tfsClientImplementations) {
        dropdown.addOption(client, client);
      }
      dropdown.setValue(plugin.settings.selectedTfsClient).onChange((value) => __async(this, null, function* () {
        plugin.settings.selectedTfsClient = value;
        yield plugin.saveSettings();
        this.display();
      }));
    });
    new import_obsidian4.Setting(containerEl).setName("Team Leader Mode").setDesc("Pulls tasks of entire team and shows usernames in generated Kanban board. (ignores username list)").addToggle((toggle) => toggle.setValue(plugin.settings.teamLeaderMode).onChange((value) => __async(this, null, function* () {
      plugin.settings.teamLeaderMode = value;
      yield plugin.saveSettings();
    })));
    plugin.tfsClientImplementations[plugin.settings.selectedTfsClient].setupSettings(containerEl, plugin, this);
    containerEl.createEl("h2", { text: "Vault Settings" });
    new import_obsidian4.Setting(containerEl).setName("Target Folder (Optional)").setDesc("The relative path to the parent folder in which to create/update Kanban boards").addText((text) => text.setPlaceholder("Enter target folder").setValue(plugin.settings.targetFolder).onChange((value) => __async(this, null, function* () {
      plugin.settings.targetFolder = value;
      yield plugin.saveSettings();
    })));
    new import_obsidian4.Setting(containerEl).setName("Inital Task Content").setDesc("Set the inital content for each new task note. Available variables: {{TASK_ID}}, {{TASK_TITLE}}, {{TASK_TYPE}}, {{TASK_STATE}}, {{TASK_ASSIGNEDTO}}, {{TASK_LINK}}, {{TASK_DESCRIPTION}}").addTextArea((text) => {
      text.setPlaceholder("Initial content in raw markdown format").setValue(this.plugin.settings.noteTemplate).onChange((value) => __async(this, null, function* () {
        try {
          this.plugin.settings.noteTemplate = value;
          yield this.plugin.saveSettings();
        } catch (e) {
          return false;
        }
      }));
      text.inputEl.rows = 8;
      text.inputEl.cols = 50;
    });
    new import_obsidian4.Setting(containerEl).setName("Update interval").setDesc("Interval (in minutes) to periodically update the kanban board and notes. Set to 0 for only manual updating. You'll need to restart Obsidian for this to take effect. Note: when an update occurs it will close the kanban board if it is open thus a number over 10 mins is recommended.").addText((text) => text.setPlaceholder("Enter number in minutes").setValue(plugin.settings.intervalMinutes.toString()).onChange((value) => __async(this, null, function* () {
      plugin.settings.intervalMinutes = parseInt(value);
      yield plugin.saveSettings();
    })));
    new import_obsidian4.Setting(containerEl).setName("Create Kanban board?").setDesc("Should a Kanban board be generated for the current sprint (requires the Kanban board plugin in addition to this one)").addToggle((toggle) => toggle.setValue(plugin.settings.createKanban).onChange((value) => __async(this, null, function* () {
      plugin.settings.createKanban = value;
      yield plugin.saveSettings();
    })));
  }
};
