Hello everyone. Welcome back. This video, we're going to talk about a special kind of recursion called Tail Recursion. So, you want to be able to identify the expressions that are in what's called tail position, and explain this thing called the tail call optimization because it makes certain kinds of recursive calls very efficient. You'll also want to be able to convert something that's written in what we call direct style recursion into an equivalent tail recursive function. So, to start off, you have to understand what's called tail position. So, a tail position is a sub-expression where if somehow it gets evaluated, then that sub-expressions value gets taken as the value of the entire expression. So, if you look at this e or this if expression here, that if x greater than three, then x plus two else x minus four, notice I've underlined the x plus two and the x minus four. So, why I did that is that if we evaluate x plus two, then the whole if expression has a value of x plus two, similarly with x minus four. Now, the next expression f applied to x times three, there's no real proper tail position here. So, if we actually do the x times three, it's not going to use that as a value of the whole thing, it's going to pass that into f instead. Now, if the thing that's being in the tail position, if that thing is actually a function called and this is called a tail call, and in the third example here, we see one of the h applied to x is in tail position, but the rest are not part of the then branch, so the g of x is not in tail position because its result gets added to x, and the first h of x is not in tail position because we are going to use that to decide whether to take the then branch or the else branch. So, all right, why don't you see if you can figure out which ones are the tail calls? Take a look at this for a second, hit pause if you need to. I'll tell you there's only one tail call in here, see if you can find it. All right, so yes, it's on line six, that called the aux is in tail position, and the other one's on line two, we have a call to factorial or fact one, and that's return value is going to be used to multiply against n, so that's not in tail position. Similarly, for a line 10, we have 2 calls to Fibonacci, but those are added to each other afterwards, so those aren't tail calls either. Now, if we have functions calling each other and the function calls or in tail position, we get an interesting behavior, so watch what happens to these stack frames. So, I'm going to call foo on one, it kind of so lovely stack frame, foo calls bar, bar calls baz, baz computes its return value which is 30. Watch what happens now, it returns that to bar but since this was a tail call, that return value is not modified at all, in fact, it also gets passed to foo. So, we have this return value that started off in baz and it's passed all the way back down the chain. So, it turns out, we can take advantage of this behavior since we know at the very end what the final result is going to be. So, one thing we could do is cut out the middleman say have called foo, foo calls bar, bar calls baz, and when baz creates its return value instead of passing it back to bar and then bar passing it back to foo, we can pass it directly to foo and in fact, we can even do better than that since we know that bar is not going to be used after it makes its function call, we can actually recycle the stackframe altogether. So here we have foo, foo calls bar, bar calls baz, then the return value is created. So, this is called tail call elimination, and when you have a bunch of functions that are doing this internally and the machine code, this is been optimized into a loop, so, there are no function calls being made at all at this point. So, let's compare direct style recursion or what you might think of as normal recursion to tail call. So, we have this function here sum. So in recursion, when you make a recursive call, there's a first piece and the rest of the input that's kind of how an inductive proof works right. So, sum here on line two you see there's an x that's the first piece and there's xs which is the rest of it. So, I'm going to take x and add it to the sum of xs. So, we call the recursion on the rest of the input and when it comes back, we combine the results to get the final answer. In an accumulator recursion, you have to do all the computation upfront, and anything you're going to do you have to do before you make the recursive call because otherwise that recursive call won't be in tail position anymore, it's only in tail position if you don't touch its result. So typically, you will use an auxiliary function and usually, that auxiliary function will have an accumulator parameter in there to keep the accumulated result. So, look what's happening with this sum, if we call aux on the empty list, that means we've finished everything and then a is our accumulator which has the result of the summation, so we return a, otherwise online three, if we have a list. We call ox on the rest of the list and add x to the accumulator, so this keeps a running sum of everything that we're doing as we go. All right. So, here's three functions, why don't you try converting them to tail recursion see how you get? Remember you're probably going to want to build an auxiliary functions for them, and the other hint is that fun three, you're going to need two accumulators to the sufficiently. So, go ahead hit pause and when you're ready to check your work, hit on pause and see what happens. All right. So, here's a fun one, when we hit the empty list, we're just going to return the accumulator and the auxiliary function on line two. In line three, we check for evenness and oddness and we add one or subtract one from the accumulator as we go. Similarly for fun two, we're going to divide n by two and add one to a, so this is sort of a primitive logarithm function. Finally for the last one, the Fibonacci, we're going to have two accumulators that keep track of the first two base cases that are available for Fibonacci sequence. So, this is actually a very efficient way of computing Fibonacci, you should definitely try typing this in and play with it. You'll take the Fibonacci of 100 or something, it's really huge number and it's almost instantaneous, so kind of fun. All right. So, that's tail recursion, it's a very nice optimization that you should definitely be very familiar with it. We're certainly going to ask you to write functions both indirect style and Intel recursion in the future, there's some really interesting articles you may want to read. Recursive patterns are still being researched. So, here's a paper, it's not that recent anymore but it's called, "There and Back Again," where they have a recursion pattern where it actually combines tail recursion and direct style recursion, and you can do some really interesting things with that. The other paper is a very old one. It used to be thought that function calls were very expensive and so people tried to avoid that as much as possible and it turns out that's not the case, and so this researcher wrote this nice paper about that.