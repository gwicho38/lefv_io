Hello everyone, welcome to CS 421. Today we're going to talk about recursive functions. To get us started, I also wanted to go over proof by induction because it turns out that induction proofs and recursive functions are pretty much the same kind of thing. And we'll just talk about the different parts of it and show how they match up to each other. So, I assume that you've done induction before and that you are reasonably comfortable with it, but let's just go over it anyway. What we're going to do is, we're going to pick a property, we'll call it P. And we want to prove that this property P is true for all n. Typically in things like integers, but it can be any structure as long as there's a sense of ordering to it. There must be some kind of concept, that one thing being smaller than another. So link list is another good example are trees. But anyway, we have two cases. You have a base case, where whatever the smallest value of n should be, like maybe zero one, or if it's linked list it can be the empty list. That kind of thing. You prove that, and typically it's very straightforward to prove, but then you also want to do the inductive case. And here what we do is we assume that P of n minus one is true. In fact, you assume that P is true for all n smaller than the current one. And then you use that information to prove that the current property P event of n is also true. So it's really nice way of being lazy because we can do an infinite number of cases and we collapse it down into two. Let's do an example. Though this is actually a very old proof. The sum of the first n odd numbers is n squared, it's one of the earliest formally written out proof by induction actually. So your base case, let's let n equal to one. So you say n squared is equal to one, and the sum of the list one is one. So therefore our base case is proven. Very simple. So the induction case, you want to show that the property is true for sum n. So you prove that basically, we assume that P of n minus one is also true. In fact P of n minus two all of the ends. The way I have this presented here, I'm showing you P of n minus one, and that's called simple induction. But there's also a stronger one, a well-founded induction you show that all the P for anything smaller than n is true. So here's how the proof works. If we assume that P of n minus one is true, we have one plus three plus five to two and minus three, and we're going to assume that's equal to n minus one squared. So then what we're going to do, is we're going to add two n minus one, that's the nth odd number to both sides. There's a huge cloud of algebra when you do that, and then you turn out you get your n squared. So that proves our induction case. Now when you write something using recursion, you actually follow the same kind of structure. Instead of a property P, we have a function f and we want to compute f of n for all n that we're interested in. You have to have two cases. You have a base case so f of one, for instance, or f of empty list or whatever it is your structure is, the smallest value should be, and then you have a recursive case where you can call f of n minus one or something like that, and then use that value to compute f of n. So here's the nth square function that you see here. We have n square of one is one, that's our base case, n square of n is two n minus one plus n square of n minus one. The other thing that you should notice in Haskell is how we use pattern matching. So the first line says n squared applied to one is equal to one. n square applied to n is this other thing and so it checks the cases in order. So for one it will take the first class for anything else, it will just assign the variable n. So in recursion, there's a couple of things that you have to bear in mind to make sure that the recursive function works properly. Your base case has to stop the computation, otherwise it's not really a base case. And the other thing that you have to understand about recursion is when you make a recursive call, then the argument to that function should get you closer to the base case somehow. So here we have n square of n minus one, sets closer to the one case than what was there. Of course this particular function we don't handle negative numbers. If you put in a negative number here then it's going to loop forever because you're getting farther away from the base case rather than closer to it. So that's a quick overview of proof by induction and recursive functions written in Haskell. In the next video, we're going to talk about other kinds of recursion, particularly something called tail recursion, which is a very nice optimization that will turn out to be very useful.