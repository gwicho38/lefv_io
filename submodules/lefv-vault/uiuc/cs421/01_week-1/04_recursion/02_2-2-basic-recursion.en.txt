Hello everyone, welcome to CS 421. This video we're going to talk
about some basic recursion. I think you're already pretty familiar
with this from other classes you've taken and other experienced programming. But I did want to go over what's
happening in the stack frame and show you some things that are going on
because the next video after this one will show a very powerful optimization. So your objectives are to
diagram the stack frames that result from function calls. And we're going to use Haskell to write
recursive functions both on integers and on link lists. This way it'll help you become
more familiar with the syntax. So, here's a function definition, so
we define this function into foo and has one parameter a. And inside the body of the function,
here's some new syntax, it's called the let syntax. It's kind of where, but the definitions
of the locals come before the stuff. So here, aa = a * a, in aa + a. So when we call it, we're going to have
some memory allocated for the a and for the aa as well. So we have a parameter and a local. So we call foo on 1,
that's going to return, 1 + 1 is 2. And then we're going to make a second
call, which is going to return 2 + 4. And then we're going to
make this third call. So every time we make a function call,
some space is allocated in the computer to keep track of all the variables that
are necessary to compute the function. If one function calls another function, then both of these memory locations
are active at the same time. They're called activation records. So here I'm calling foo on 1, so
x is the parameter, has a 1 in it. Now we're going to call bar with 2 and
then bar is going to call bars. And bars is going to compute
its return result, 30 and that's going to pass it back
to the bar activation record. Similarly, we're going to
compute 30 + 2 to get 32 and return that back to foo's activation
record, final result will be 33. So this also works if
a function is recursive. So I'm not going to step
through all of it, but here's the famous factorial function. And if we call factorial on 4, you see it has to create all these
different activation records. So the fact itself will be
called four different times before returning its result
each to the previous caller. So this is a fairly standard
recursion on integers. Notice the syntax again, fact on 0 returns
1, fact applied to 1 returns 1 and fact applied to anything else
returns that times the fact to n- 1. Now you've seen link list a little
bit in the previous videos, now let's talk about
them a little bit more. So there is several different syntaxes
we can use, one is for the empty list. You just put open and
close square brackets and then you see the colon notation is
used if you want to create a new list. So here 1 : 2 : 3 : 4, blah, blah, blah. That gives you this link
list pattern in memory. And there's also the shorthand annotation
if you want to write it out all at once just with 1, 2, 3, 4. Now one thing to remember is colon in
Haskell does not modify an existing list, it creates a brand new one. So when I say 1: 2, 3, 4 list already
exists and then it make the 1: and it points to the 2, 3, 4 list. Now, here's example of a function
that's written for lists. So we have it, it's called my length. Length is already built in so
we can't reuse that name or I'll complain. But notice the type signature, it takes
a list of a and returns an integer. So basically it's saying that we don't
care what the list contains, because we're not actually going to look at anything,
we're just going to count the elements. So the length of the empty list is 0,
that's what you see on line 2. And on line 3, the length of a list with
some data in it is 1 plus the length of the rest of the list. So if we had s from
the previous slide over here. Well anyway, let's suppose we has
s has some three elements in it, we can call length on that and
it'll return 3. So and again, notice the pattern
of how the recursion works. The base case has to stop the computation,
so that's the empty list. And the recursive case we're calling
the recursion on something smaller than the original list. So xs has one fewer elements than x:xs. All right, I want you to do this activity. Here's three functions I
want you to try writing. So go ahead an hit Pause, and
then see if you can write these things and play with them. And then when you're done and you want
to check your work, just hit UnPause and I'll show you the solutions. All right, so here's the Fibonacci
function, fib of 1 is 1, fib of 2 is 1 and then fib of n is fib of n- 1 + n- 2. It's a fairly famous
occurrence relationship, and it's actually very inefficient. There are more efficient
ways of computing this. We can talk about that some other time. And also we have sumList,
which is like a built in sum function. But instead of counting the elements of
the list like the previous function we wrote, this actually adds up the elements. So for incList, notice that
we're creating a brand new list, we're not modifying the original data. And this is one of the features of
Haskell, as all data is immutable. We don't modify anything directly,
instead we create a copy and return that. That's one of the hallmarks
of functional programming. So that's it for basic recursion. Here's a little historical note. The first programming language to
actually use recursion was LISP in 1958. And you can read more about
that in this article here.