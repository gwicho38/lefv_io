1
00:00:00,142 --> 00:00:01,398
Hello, everyone, welcome back.

2
00:00:01,398 --> 00:00:02,090
In this video,

3
00:00:02,090 --> 00:00:05,674
we're going to talk about the other two
Euler problems that were on your handout.

4
00:00:05,674 --> 00:00:10,018
Euler problem 3 is basically find
a largest prime factor of a number.

5
00:00:10,018 --> 00:00:13,906
To do this, we're going to write something
that is kind of like the famous sieve.

6
00:00:13,906 --> 00:00:16,969
Really, not quite as sophisticated as
the real sieve, but it's easy to write.

7
00:00:16,969 --> 00:00:18,289
So we'll do it this way.

8
00:00:18,289 --> 00:00:19,085
In the meantime,

9
00:00:19,085 --> 00:00:21,909
I'm going to show you a few more
features of Haskell as we do this.

10
00:00:21,909 --> 00:00:24,781
Now one thing that we can do is
we can write a function plus.

11
00:00:24,781 --> 00:00:27,357
It just adds its two arguments together.

12
00:00:27,357 --> 00:00:32,186
And if you ask for the type, you'll see
that it gives you back a, arrow, a, arrow,

13
00:00:32,186 --> 00:00:35,331
a, with the constraint that
a must be a numeric thing.

14
00:00:35,331 --> 00:00:37,402
Now, there are two ways that
you can read this type.

15
00:00:37,402 --> 00:00:40,402
The first is you can think of it as
a function that takes two arguments and

16
00:00:40,402 --> 00:00:41,408
then returns a result.

17
00:00:41,408 --> 00:00:45,044
So you see I call plus on 10 and
20 and get 30 back.

18
00:00:45,044 --> 00:00:49,652
But the other way you can look at it is
if you only give plus 1 of its arguments.

19
00:00:49,652 --> 00:00:52,145
Then it's going to
return another function.

20
00:00:52,145 --> 00:00:58,610
So if I call plus 1 and look for the type,
that 1 goes into the first a in the type.

21
00:00:58,610 --> 00:00:59,990
And then you get an a or a back.

22
00:00:59,990 --> 00:01:01,557
So you get another function back.

23
00:01:01,557 --> 00:01:05,030
And when a function is written this
way it's called a curried function.

24
00:01:05,030 --> 00:01:08,735
And we'll have occasion to talk about
this a little bit more in a future video.

25
00:01:08,735 --> 00:01:12,351
But as you see what we can do
is I can call plus on 2, so

26
00:01:12,351 --> 00:01:14,422
that's partially applied.

27
00:01:14,422 --> 00:01:17,699
And then save that into
another function like addTwo.

28
00:01:17,699 --> 00:01:20,319
This is a very common
technique used in Haskell.

29
00:01:20,319 --> 00:01:24,050
The way we're going to make use of this
is we're going to have a function called

30
00:01:24,050 --> 00:01:27,958
notDivides that we can use to filter out
all the things that aren't divisible by

31
00:01:27,958 --> 00:01:28,911
a certain number.

32
00:01:28,911 --> 00:01:31,478
And this is how we're going to
be able to build up our primes.

33
00:01:31,478 --> 00:01:35,217
So you see if I call filter notDivides
3 on the list 1 through 10,

34
00:01:35,217 --> 00:01:38,250
then it's throwing out all
the multiples of 3 for us.

35
00:01:38,250 --> 00:01:41,894
So in order to build up a list,
we're going to need some more syntax.

36
00:01:41,894 --> 00:01:45,139
Now you saw on the previous video,
we could use the square brackets and

37
00:01:45,139 --> 00:01:46,632
just write in all the elements.

38
00:01:46,632 --> 00:01:49,845
But here we're going to have to build
it up a little bit more piece meal.

39
00:01:49,845 --> 00:01:52,250
So what we're going to do
is use this colon notation.

40
00:01:52,250 --> 00:01:56,351
Now if you use the language with linked
lists and singly linked lists, a lot of

41
00:01:56,351 --> 00:02:00,598
times an object joined to language,
you can say stuff like a new Node (a,b).

42
00:02:00,598 --> 00:02:02,505
And a is going to be the data element and

43
00:02:02,505 --> 00:02:04,991
b is going to be a pointer
to another linked list.

44
00:02:04,991 --> 00:02:07,469
And that way you can build
things up incrementally.

45
00:02:07,469 --> 00:02:11,341
So Haskell we have this colon which
does basically the same thing.

46
00:02:11,341 --> 00:02:15,741
So you can see here on line 1,
the 2 is going to be the data element.

47
00:02:15,741 --> 00:02:19,280
And then colon and then filter is
supposed to return another linked list.

48
00:02:19,280 --> 00:02:23,509
And so what this is going to do is create
a new linked list node where the 2 starts

49
00:02:23,509 --> 00:02:27,094
at the beginning and then the rest
of the list comes afterwards.

50
00:02:27,094 --> 00:02:30,416
So the way we're going to
build up our list of primes.

51
00:02:30,416 --> 00:02:31,623
So we'll start with a 2 and

52
00:02:31,623 --> 00:02:34,782
then we'll filter out all the multiples
of 2 from the rest of the list.

53
00:02:34,782 --> 00:02:39,278
And we can stack this up, we can
have a 3 and then filter out the 3s.

54
00:02:39,278 --> 00:02:42,365
Then 5 and filter out the multiples of 5,
so on and so forth.

55
00:02:42,365 --> 00:02:45,728
Of course we're going to want to write
a recursive function to do this for us.

56
00:02:45,728 --> 00:02:48,050
Here's what our sieve
function's going to look like.

57
00:02:48,050 --> 00:02:51,847
And this is going to also show you
two other features of Haskell.

58
00:02:51,847 --> 00:02:55,115
So feature number one, you'll see sieve,

59
00:02:55,115 --> 00:03:01,223
the parameter list is actually the same
syntax for building up a list, the x:xs.

60
00:03:01,223 --> 00:03:03,044
And this is called pattern matching.

61
00:03:03,044 --> 00:03:06,340
So what happens,
if I call sieve and pass it a list,

62
00:03:06,340 --> 00:03:09,958
the first element of the list
is going to get assigned to x.

63
00:03:09,958 --> 00:03:12,913
And the rest of the elements
are going to be assigned to xs.

64
00:03:12,913 --> 00:03:14,415
This is a very nice notation.

65
00:03:14,415 --> 00:03:16,113
It’s very concise.

66
00:03:16,113 --> 00:03:19,247
And you’ll see this used very,
very frequently in this language.

67
00:03:19,247 --> 00:03:23,693
Now the other thing you may notice is
that sieve, there is no base case.

68
00:03:23,693 --> 00:03:26,395
I haven’t written something for
the empty list.

69
00:03:26,395 --> 00:03:30,939
And so this looks like it’s actually
going to build an infinitely large list if

70
00:03:30,939 --> 00:03:32,579
you tried to type this out.

71
00:03:32,579 --> 00:03:35,732
So I say primes = sieve [2..].

72
00:03:35,732 --> 00:03:39,647
If you actually type out primes at
this point, then it won't stop,

73
00:03:39,647 --> 00:03:40,963
it'll keep looping.

74
00:03:40,963 --> 00:03:44,716
But Haskell has another feature,
it's called a lazy evaluation.

75
00:03:44,716 --> 00:03:50,136
So when you write down something, unless
it's actually used in another computation,

76
00:03:50,136 --> 00:03:53,372
Haskell won't actually do
anything with it at all.

77
00:03:53,372 --> 00:03:56,705
It won't perform the computation
until it is actually necessary.

78
00:03:56,705 --> 00:04:01,648
So the way we can make use of that is
we can write down our list of primes.

79
00:04:01,648 --> 00:04:05,949
And we don't have to know how many we
want up front, but we can decide later.

80
00:04:05,949 --> 00:04:09,165
There's a function called take
which will go through and

81
00:04:09,165 --> 00:04:13,734
take the first 20 elements of the list in
this case and return them in a new list.

82
00:04:13,734 --> 00:04:15,533
So these are our primes.

83
00:04:15,533 --> 00:04:16,743
Now that we have that,

84
00:04:16,743 --> 00:04:20,325
we just need to figure out how to
use that to get our largest factor.

85
00:04:20,325 --> 00:04:26,100
So here, to get all the factors,
we're going to take an auxiliary function.

86
00:04:26,100 --> 00:04:28,136
So I want the factors of n.

87
00:04:28,136 --> 00:04:31,352
I'm going to make
an auxiliary function aux.

88
00:04:31,352 --> 00:04:36,050
Then the first element of aux is going to
be the number we're trying to factor.

89
00:04:36,050 --> 00:04:38,242
And if we get down to 1 then we're done.

90
00:04:38,242 --> 00:04:40,062
So we'll return an empty list.

91
00:04:40,062 --> 00:04:42,798
That's what that brackets
with nothing in looks like.

92
00:04:42,798 --> 00:04:47,492
Otherwise, what we're going to do is we're
going to assume that the second argument

93
00:04:47,492 --> 00:04:49,159
to aux is our list of primes.

94
00:04:49,159 --> 00:04:51,746
And we're just going to
through them each one,

95
00:04:51,746 --> 00:04:54,277
we'll just check if p divides into n or
not.

96
00:04:54,277 --> 00:04:58,779
So if it does, then we're going to return
it, and then call aux recursively.

97
00:04:58,779 --> 00:05:03,628
Otherwise, the second case on line 5,
those two underscores mean that

98
00:05:03,628 --> 00:05:07,294
we don't actually want to
assign a variable name to it.

99
00:05:07,294 --> 00:05:10,138
We'll just keep checking
to see what divides out.

100
00:05:10,138 --> 00:05:15,015
And finally, there's a function foldr,
which we're going to take max and

101
00:05:15,015 --> 00:05:19,421
we're going to repeatedly call max
on the elements of this list and

102
00:05:19,421 --> 00:05:20,854
fold them together.

103
00:05:20,854 --> 00:05:22,270
There's an example here,

104
00:05:22,270 --> 00:05:25,848
you can see foldr plus basically
puts a plus in between each element.

105
00:05:25,848 --> 00:05:28,456
And that's how we're
going to get our factors.

106
00:05:28,456 --> 00:05:31,359
So we're just going to call
max on all of those elements.

107
00:05:31,359 --> 00:05:34,799
Problem 20 is actually very,
very easy in this language.

108
00:05:34,799 --> 00:05:38,475
One of the things that Haskell has,
it has two different kinds of integers.

109
00:05:38,475 --> 00:05:40,589
One is the machine integers.

110
00:05:40,589 --> 00:05:44,315
Which basically fit into 32 or 64 bits.

111
00:05:44,315 --> 00:05:46,447
But it also has something called a BigInt.

112
00:05:46,447 --> 00:05:49,870
So if you go ahead and
take the factorial of 100,

113
00:05:49,870 --> 00:05:52,741
then it will actually print it out for
you.

114
00:05:52,741 --> 00:05:55,436
So here you can see
an example of how that works.

115
00:05:55,436 --> 00:05:57,189
And so once we have that,

116
00:05:57,189 --> 00:06:01,870
then it's actually very easy just
to get the sum of all the digits.

117
00:06:01,870 --> 00:06:06,946
Because all you need to do is take
the modulo 10 and then add those up.

118
00:06:06,946 --> 00:06:10,440
In languages that don't have BigInts
this might actually have been a lot more

119
00:06:10,440 --> 00:06:11,040
difficult.

120
00:06:11,040 --> 00:06:15,330
Because you'd have to figure out our own
way of keeping track of the sizes of

121
00:06:15,330 --> 00:06:16,155
everything.

122
00:06:16,155 --> 00:06:18,823
But because of this,
it makes it very simple and

123
00:06:18,823 --> 00:06:22,371
straightforward just to go ahead and
use these giant numbers.

124
00:06:22,371 --> 00:06:24,308
So now that's these two.

125
00:06:24,308 --> 00:06:28,075
Hope this was a good introduction to
you to see what Haskell looks like.

126
00:06:28,075 --> 00:06:31,159
Again, we'll be seeing a lot more
Haskell in the days to come.