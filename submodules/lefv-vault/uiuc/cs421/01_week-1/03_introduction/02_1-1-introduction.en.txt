Hello everyone, welcome to CS 421. In this video, I want to talk about a few things. I want to talk a little bit about the logistics of this course. In particular, some of the assignments and exams. We do things a little bit differently. Also, I want to talk about the course objectives, the kinds of things we hope you learn. We want to talk about why we want to study languages in the first place and some of the major themes for the course. Hopefully, you will end up really excited about what comes next. So, a little bit about me. My name is Mattox Beckman, I think you probably read that by now. I got my PhD in 2003 from the University of Illinois at Urbana, and then spent more than a few years at the Illinois Institute of Technology in Chicago teaching there, before coming back to the University of Illinois in late 2015. My main research area, CS Education these days, but my training is in Programming Languages. My specialty was Partial Evaluation and Functional Programming. One of the things I'm known for is having an awful lot of hobbies. So, here's some of them that I have now. That's the list this year, if you come back next year the list may well be different, not enough about me. One of the features of this course is the thing called Machine Problems. There are these large programming assignments that you will do, they will collectively be worth about 15%. Now, one of the things that I believe strongly is that, it's actually useful for you if you can get help while you're programming. So, if you want to program with someone else and collaborate together, I allow that, because I myself learned to program by typing in other people's programs, and I thought that was just very efficient. So, I only have two requests for you. One is you must cite your sources, if we check and we saw you got something and didn't cite it, we will not be happy with you. The other thing that I request which obviously we cannot check is that, whatever help you did get, don't use copy paste, please let the code come out of your own fingertips, print it out, type it in, verbatim if he have to. But the fact that you type it yourself actually helps you learn it a lot better. So, you can see the syllabus for more details about the exact number and the topics of each of the machine problems. To keep you honest, we have a kind of exam called a Machine Lab. For each MP, there may be a separate quiz where we take either the solution to the machine problem, or perhaps a solution to a similar machine problem where we change things up just a little bit. The idea is if you actually did the machine problem and learned what you're supposed to learn from doing it, then this will actually be very straightforward and very simple. If you did not however, you're going to have a rough hour. Now, for the exams, we want to use those as a way of measuring your mastery of the material. So, what I do, is I divide the exams into proficiency units. So, there'll be two midterms 20% each, they'll all have these proficiency units. For example, there might be one on recursion, there might be one on high-order functions. On the final exam, some of these proficiency units will reappear, there'll be different questions but they'll be the same topic. What I do about that is, if your score on the final exam, when that proficiency unit improves, then I will back fill that score into the proficiency unit for the corresponding midterm. So, some classes have what they call second chance exam. So, this is kind of like that. So, on the final exam, if anything gets repeated and your score improves as a result, then that actually will improve your score on the whole thing. So, let's talk about why we want to study programming languages in the first place. I have three examples here. One is a word called Pai sei, another is an article from Paul Graham called Beating the Averages, and another is just an observation about human language is called Language Families. So, let's talk about Language Families first. One thing that you'll notice if you study a lot of foreign languages is that, they tend to come in groups. So, for example, there's a set of languages called the romance languages, not because they talk about love but because they're both from Rome, so the Latin based languages. What I mean by this is language like French, and Italian, and Spanish, and Portuguese. So, here's a thing. Because they were all derived in part from Latin, they all share a bunch of the same rules. If you learn French and Spanish, you actually know enough vocabulary, enough structure that you can read Italian and make good sense out of what you're reading. It's all because these are all part of the same language family. Now, if you want to learn a language that's not part of the language family, let's say Korean, it doesn't work, it doesn't help you very much at all. The vocabulary is based on a different system, the way verbs are handled are different, even the way the sentence is structured is very different than they are in the Romance languages. So, it's a lot more work to learn those sorts of languages. Programming languages have the same dynamic. If you know C, C++, you can learn Java very, very quickly. But if you go outside of that language family into languages like, Haskell or Prologue which are very different language families and the one that C++ is part of, it's a much more difficult task because the concepts, even what a programming language is, has changed. So, one of the things that we hope to do in this course, is to show you a wide variety of language families, so that you'll have more choices when you go to pick a programming language or learn a new language. So, let's talk about this word Pae Sei, it's a Taiwanese word. If you look it up in a dictionary or ask someone, they'll probably say it means embarrassed or shy, which isn't wrong, but it also doesn't quite capture the full nuance that this word has. If you happen to know Mandarin, the word is bu hao yi si. If you know Cantonese, it could be hak hei. Probably, the best translation I've seen was from a Jackie Chan movie, where the protagonist was staying over someone's house and the host said to him, mohak hei, which means don't be pae sei or don't be bashful. Literally, what they translated into subtitles was, make yourself at home. This is perfect translation in that context. So, to illustrate this, I'm going to tell a story about what will happen if you're at a restaurant and there's two Chinese families eating together, I mean there's not just one Chinese culture. But, let's say they're part of the culture where this word is something that is useful. So, what happens is they have a great time eating together and then at the end there's this glorious battle over who gets to pay the bill, and it's amazing to watch. So, everyone knows the I'm going to the bathroom tricks, so if you try to go to the bathroom, you will get an escort. I've literally seen it happen where one person is running for the cash register, and another person from the other family is blocking them with their body, while a third person is trying to run around the two of them and get their first. It's pretty amazing, there's this big back and forth no you paid last time, no it's my turn this kind of thing. Finally, somebody wins. Now, bear in mind, no one actually wants to pay for the meal, but in this particular system you don't split the bill, do you just don't do that. So, to be polite, you have to offer to pay. So, finally, everyone goes home, someone has won the battle. Then, the other family, the kid reaches their hand into their coat pocket and finds a lot of money, it's been stuffed in there by the other family. The point of this is, in this particular context, there is this culture where this happens, and so there's a word to describe it. So, the language and culture has grown together. Also, if you're trying to explain this dynamic to an American audience, it takes some time, you have to explain all the dynamics and you have left an awful lot of stuff out, and there's a lot of disclaimers and nuances. But in Chinese, we have a word for this because it's something that comes up. In American English we do not because it doesn't come up, it's just not part of how things are done. This dynamic also expresses itself in programming languages. Certain languages have, for example, classes for objects because it's something that comes up, but if you're in a language that doesn't have them but you want to use them, it's actually very difficult, you can still do it, I'll show you how, but it takes more time. A very important article written by George Orwell is called Politics in the English Language, and it's linked on the website, I urge you to read it, it's not that long. George Orwell talked a lot about how language and thought inform each other and influence each other. He thought you could actually control how people think by controlling the language that people used, and vice versa. So, this is a very important essay, you probably more familiar with this books like 1984 Animal Farm, but this one is a lot shorter and much more to the point, it's not fiction. Another article which is very interesting is called Beating the Averages by Paul Graham. One of the things he writes about is how, if you have a language that you're using, let's say it's C++, and then you come across another language which is less powerful than that like say Assembly or C, it's going to be very clear to you very quickly that the language you're using, C++, is much more powerful than one of these other languages, because you notice that features are missing. However, the opposite doesn't happen. If you look at a more powerful language and there are plenty out there, that have features that your language doesn't have, and it's actually very difficult for you to notice that up front. Because what happens is you notice all these funny language constructs, or maybe the language doesn't do things the way I'm used to doing them. So, you'll tend to dismiss the more powerful language because you're just not able to see the more powerful thing that it's able to offer you. So, this course, we're going to have four major parts to it, the first part is about Functional Programming. You will learn, there's Functional Programming language called Haskell, we're going to have another video about that after this one. You're going to learn how to build interpreters for different languages in this language. The next thing we'll talk about is Parsing. When you type in, your computer program, your interpreter has to read that in and turn it into a data structure that make sense of it all. So, you'll learn how to do that. We're going to talk about some Mathematical Foundations and that'll take two different shapes, there's some programming constructs in Haskell which are based on some category theory. We're not going to teach you category theory, we're just going to reference it, but we're going to teach you some of these constructs that will inspired them. Then, later on, we're also going to talk about how to mathematically to find the meaning of a language, and a series of lectures based on something called Semantics. Finally, we're going to talk about something called Pragmatics. So, when you go to write a language or choose a languages, different design decisions you may have available to you, we're going to talk about the consequences of each one and why you might want to choose one over another. So, what should you learn from this course? We want you to know about major classes of programming languages, we want you be able to pick any language appropriate for a task that you have in mind. So, let's say you decided that your software project needed a scripting language, I would like you to be able to pick the right scripting language for your project, be confident that it's the right choice, and then maybe that language isn't really available for you, so I'd like you to be able to implement it yourself, to say, "We don't have that on our system, no problem, give me a few days, I'll write it up." We also want you to be able to look at the formal specifications of languages, to be able to read it and implement a language as a result, or even to take a language and write a formal specification,so for example, maybe you had to make your own language, like you build a write out, what it means so that other people could implement it too. Some very powerful ideas are here, recursion, abstraction, transformation, be able to transform one computer programming in to another, that maybe does the same thing but has some nicer properties. There's something called Unification which is a backbone to a lot of the mathematics we'll talk about. So, we're going to do a lot of theory in this course but I hope that you see the theories being very practical, that the theory can be used to help you do the things you want to do with your languages. So, here are a few of the articles that I mentioned earlier, hope you'll look them up, they'll be linked also in the course website.