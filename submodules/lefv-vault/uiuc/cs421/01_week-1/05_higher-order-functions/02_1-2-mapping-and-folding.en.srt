1
00:00:00,000 --> 00:00:01,650
Hello everyone. Welcome back.

2
00:00:01,650 --> 00:00:06,835
In this video, I want to go over two very important higher-order functions.

3
00:00:06,835 --> 00:00:08,385
You'll see them a lot,

4
00:00:08,385 --> 00:00:09,580
you'll use them a lot,

5
00:00:09,580 --> 00:00:11,295
they'll be very useful to you,

6
00:00:11,295 --> 00:00:13,470
even outside of this course perhaps.

7
00:00:13,470 --> 00:00:15,460
So, they're called foldr and map,

8
00:00:15,460 --> 00:00:17,150
foldr for fold right.

9
00:00:17,150 --> 00:00:20,010
You'll want to know how to write them and how to use them

10
00:00:20,010 --> 00:00:22,815
to implement some very common recursion patterns.

11
00:00:22,815 --> 00:00:24,720
So, let's talk about mapping.

12
00:00:24,720 --> 00:00:28,500
You've seen this pattern before where I want to write

13
00:00:28,500 --> 00:00:32,540
a function that takes a list and does something that every element of a list.

14
00:00:32,540 --> 00:00:35,610
So, here I have function incL l or incL list,

15
00:00:35,610 --> 00:00:39,300
and it just returns the list with everything incremented.

16
00:00:39,300 --> 00:00:41,675
So, pretty straightforward.

17
00:00:41,675 --> 00:00:44,295
Now, look at these two functions.

18
00:00:44,295 --> 00:00:46,800
One of them increments every element to the list,

19
00:00:46,800 --> 00:00:49,550
the other one doubles every element of the list.

20
00:00:49,550 --> 00:00:52,000
What do they have in common?

21
00:00:52,000 --> 00:00:56,664
When in fact, it would be easier to say what they don't have in common.

22
00:00:56,664 --> 00:00:59,095
The only thing they have in common is the name,

23
00:00:59,095 --> 00:01:02,080
and that's an accident really,

24
00:01:02,080 --> 00:01:04,700
and the operation that they do.

25
00:01:04,700 --> 00:01:06,640
They both have the same base case,

26
00:01:06,640 --> 00:01:10,335
they both make the same recursive call.

27
00:01:10,335 --> 00:01:12,200
All that's different is,

28
00:01:12,200 --> 00:01:14,915
what it does to each individual element.

29
00:01:14,915 --> 00:01:20,030
So, we're actually rewriting an awful lot of code to do this.

30
00:01:20,030 --> 00:01:25,270
All that changes the operation and everything else is sort of boiler plate.

31
00:01:25,270 --> 00:01:29,210
So, this is what I call Mattox's law of computing.

32
00:01:29,210 --> 00:01:32,170
The computer really exists to work for us,

33
00:01:32,170 --> 00:01:33,890
and if you're working for the computer,

34
00:01:33,890 --> 00:01:35,300
you're doing something wrong.

35
00:01:35,300 --> 00:01:37,150
I remember one time my roommate,

36
00:01:37,150 --> 00:01:39,940
this is back in the day when there was floppy disks.

37
00:01:39,940 --> 00:01:41,330
He had two floppy disks,

38
00:01:41,330 --> 00:01:44,705
he was dragging one file at a time from one disk to the other,

39
00:01:44,705 --> 00:01:45,945
and there's was hundreds of files,

40
00:01:45,945 --> 00:01:49,255
he probably already spent about 10-15 minutes doing this.

41
00:01:49,255 --> 00:01:53,555
So, I showed him how to use Ctrl+A and drag all the files in one go.

42
00:01:53,555 --> 00:01:56,670
So, if you're doing something repetitive for the computer,

43
00:01:56,670 --> 00:01:58,610
you need to rethink what you're doing.

44
00:01:58,610 --> 00:02:01,105
Because it's the computer job to do repetitive stuff.

45
00:02:01,105 --> 00:02:03,945
That includes writing code.

46
00:02:03,945 --> 00:02:06,575
So, here's a way to do it right.

47
00:02:06,575 --> 00:02:08,200
Now, this function called Map,

48
00:02:08,200 --> 00:02:10,530
you've seen it a couple times before,

49
00:02:10,530 --> 00:02:12,340
here's its source code.

50
00:02:12,340 --> 00:02:15,560
So, map is a higher-order function it takes an operation f,

51
00:02:15,560 --> 00:02:17,740
and then if you give it an empty list,

52
00:02:17,740 --> 00:02:19,040
it returns the empty list.

53
00:02:19,040 --> 00:02:20,990
If you give it a list with stuff in it,

54
00:02:20,990 --> 00:02:23,330
it applies f to the first element of the list,

55
00:02:23,330 --> 00:02:26,060
and then maps f to the rest of that list.

56
00:02:26,060 --> 00:02:28,505
So now, we can just say map inc or map

57
00:02:28,505 --> 00:02:31,175
double to get the same functions that we had earlier.

58
00:02:31,175 --> 00:02:34,340
So, I like to talk the Java programming language,

59
00:02:34,340 --> 00:02:35,940
so try this in Java.

60
00:02:35,940 --> 00:02:40,150
Though actually, Java has some extension cease days, maybe that's easier.

61
00:02:40,150 --> 00:02:43,115
All right. So, let's talk about folding now.

62
00:02:43,115 --> 00:02:44,550
Take a look at these two,

63
00:02:44,550 --> 00:02:46,545
and see what they have in common.

64
00:02:46,545 --> 00:02:52,275
Well, slightly more, is different about them now than was true for the mapping stuff.

65
00:02:52,275 --> 00:02:56,410
So, what we have is we have a base case and an operation.

66
00:02:56,410 --> 00:03:01,760
In one case, the base case is zero for folding plus and for folding times,

67
00:03:01,760 --> 00:03:03,425
the base case should be one.

68
00:03:03,425 --> 00:03:05,170
So, here's the source code.

69
00:03:05,170 --> 00:03:06,840
So, you can see line two,

70
00:03:06,840 --> 00:03:08,375
we take the operation f,

71
00:03:08,375 --> 00:03:10,430
we take the base case z,

72
00:03:10,430 --> 00:03:12,835
think of z as being the zero element.

73
00:03:12,835 --> 00:03:14,660
So, if you get the empty list,

74
00:03:14,660 --> 00:03:16,260
you're going to return that zero element.

75
00:03:16,260 --> 00:03:20,360
Otherwise, you're going fold by calling f against x,

76
00:03:20,360 --> 00:03:23,045
and foldr of the rest of the list.

77
00:03:23,045 --> 00:03:26,710
So now, some list is just foldr plus 0,

78
00:03:26,710 --> 00:03:29,805
and prodlist is just foldr times 1.

79
00:03:29,805 --> 00:03:34,345
Now, if you don't like writing recursion very much,

80
00:03:34,345 --> 00:03:36,950
then map and foldr are your friends,

81
00:03:36,950 --> 00:03:40,430
because you can take pretty much any recursive function that works over

82
00:03:40,430 --> 00:03:44,615
lists and rewrite them as a call to a higher-order function.

83
00:03:44,615 --> 00:03:49,550
So, here we have this function sum which sums up every element of a list.

84
00:03:49,550 --> 00:03:52,820
Then, I can show you the equivalent version in foldr.

85
00:03:52,820 --> 00:03:55,795
So in foldr, the operation should take two arguments.

86
00:03:55,795 --> 00:03:58,660
The a element is going to be the first element of the list.

87
00:03:58,660 --> 00:04:01,460
The b argument is going to end up being

88
00:04:01,460 --> 00:04:05,150
the rest of the list already having been summed up.

89
00:04:05,150 --> 00:04:07,460
If you look at this source code you'll see that

90
00:04:07,460 --> 00:04:10,450
this was the result of a recursive call here.

91
00:04:10,450 --> 00:04:13,865
Then, you just need the base case for the last part of it.

92
00:04:13,865 --> 00:04:15,950
So, some things to think about,

93
00:04:15,950 --> 00:04:19,720
map and fold actually you may have heard of them.

94
00:04:19,720 --> 00:04:25,390
There's certain large computer clusters that have an operation called MapReduce.

95
00:04:25,390 --> 00:04:29,065
This is basically what you've got going here.

96
00:04:29,065 --> 00:04:34,295
One thing that you can do is you can use foldr to write map if you want to.

97
00:04:34,295 --> 00:04:36,025
You should actually try that.

98
00:04:36,025 --> 00:04:38,695
But the opposite way does not work.

99
00:04:38,695 --> 00:04:41,515
The reason why it doesn't work, set map,

100
00:04:41,515 --> 00:04:44,750
what it's doing is it's taking a list and it's doing something to

101
00:04:44,750 --> 00:04:48,930
each element of that list and it's treating them independently of each other.

102
00:04:48,930 --> 00:04:51,735
Whereas foldr, has to be able to combine elements,

103
00:04:51,735 --> 00:04:54,735
and map is unable to do that kind of combination.

104
00:04:54,735 --> 00:04:58,294
There are a lot of high-order functions that are built in the Haskell.

105
00:04:58,294 --> 00:04:59,660
Here's a few of them.

106
00:04:59,660 --> 00:05:04,205
I encourage you to play with a Haskell REPL and investigate these functions.

107
00:05:04,205 --> 00:05:06,390
You can use the :t operation remember,

108
00:05:06,390 --> 00:05:08,725
this finds out what the type of something is,

109
00:05:08,725 --> 00:05:12,330
and that will give you a very good hint about what these functions do.

110
00:05:12,330 --> 00:05:14,890
So, hope you enjoy them.