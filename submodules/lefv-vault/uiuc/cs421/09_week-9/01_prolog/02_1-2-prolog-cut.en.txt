Hello everyone and welcome back. In this video, we're going to talk about how to control prolog's backtracking by use of a cut operator. Now, sometimes during a search, you can tell that no matter what happens next, the search is doomed. But in such case, prolog will probably want to explore the entire search space anyway. So, we can use a cut operator to prevent that. When you're done, you'll be able to use prolog's cut operator to stop backtracking, cert that a pattern fails. We're also looking at some limitations of what cut can do. Now, to understand cut, you have to have a clear idea of how backtracking works. So, here's an example that should help make that clear. Now, suppose you go to a car dealership and want to buy a car, you have two colors red and blue, and there's three kinds, Honda, Ford, and Toyota. So, you enter a query color A car B, and you see that prolog starts by searching for a solution for color, picks red first and sets. It picks red first since red was listed as a color first. Next, it starts searching for a car, picks Honda first. So, the first output is A equal red, B equal Honda. Just for another solution, it drops the last match it found, the Honda and tries unifying car B with something else. The next match is Ford. So, we get A equal red, B equal Ford. A third match is A equal red B equal Toyota. We asked for a fourth solution, there are no more cars to match with. So, the car B subgoal fails. This causes prolog to backtrack to the previous subgoal color A, and it try to find a different match for it. Gets color blue this time, and then goes back to the car subgoal to try again. Of course, this repeats the same three cars for B, but this time, A equal blue for all the solutions. When you finally ask for goal number seven, both the car and the color subgoals fail. So, that's the pattern. Now, let's see the cut operator, which is an exclamation point. The way it works is this. Cut operator acts like a goal that always succeeds, but any choices that have been made by the previous subgoals are frozen. For a color and car query, we can put a cut in the middle like this. Then what happens, is when we use up all the patterns that match car B, it tries to backtrack to pick another color, but the cut operator blocks it and the whole query fails. Thinking of it as a one-way valve or something. One of the things you can do with cut is to represent commitment. The code above it says that if something unifies with a color green, then it can't pick another color. So, if we query color X, we'll unify first with color red, then we unify with color green, and the cut operator will freeze that choice, trying to get another solution will fail. However, if you query color blue directly, it will work since that query never touches the cut operator. Let's take a look at how we can use cut. Sometimes, you have a predicate with multiple clauses, and you happen to know that if the first clause is matched, then you never want to try the second clause with the same values. For example, here's that factorial again. If we ask what the factorial of five tells us that N equal 120 as you'd expect. But then if he asked for another result, the stack gets busted. So, what happened here? When we asked for another result, prolog throws out the last match at it made to look for another one. So, in this case, the last match would have been the base case fact zero women. Since we asked for another, tries the fact in X with zero for N and one for X, which then causes the call fact of minus 1Y, which of course doesn't terminate. Now, the real way to fix this is to add a constraint in the second rule that N must be greater than zero. But this is a lecture about the cut operators, so that's what we're going to use. We put a cut operator on the first clause, and now if we ask for the second result, prolog tells us there are no more. Of course the constraint version also handles the case of the user asking for the factorial of a negative number explicitly. But like I said, this is a lecture about the cut operator. Now, the main reason we use a cut operator is for efficiency. Now, here's an example inspired by the UIUC Astronomy Department. There's a large observatory on campus that you can actually get to use if you have the right training. So, let's say you have a job at the University, Astronomy Department, and one of your jobs is to let people check out the key to the telescope if they're qualified. Being a CS student of course, you're going to write a program to do this for you. The qualifications are, you must be a student, a faculty member or a member of the UIUC Astronomy Club, and you also must have gotten the training to use telescope. So, let's say we have students Anna, Beth, Cindy, and David. We have faculty members Ernest, Frank, and Gloria. Finally, we have club members, Anna, Frank, and Harry. But only Anna and Harry had been trained. The next day, Frank comes in and wants to use the telescope. He's a faculty member and a club member, but he was busy grading finals and never finished the training. So, you query, telescope Frank and what happens? Well, the first line of the telescope will check to see if Frank is a student, that fails, so it's said semicoloncy or operator next checks if Frank is faculty and he is. So, we check online too if he is trained. Well, no, not trained so prolog backtracks to line one. It checks if Frank is a club member, he is. But in the long nanoseconds it passed since the last time we checked for training, Frank didn't finish then either. So, we end up checking the training twice even though we could have told you that if you have failed the first time, he would not end up succeeding later. Now, suppose we want a list of everyone who can use the telescope. So, we run telescope X like this. Notice how Anna, who's a student and a club member gets listed twice. So, probably the best thing is to put a cut operator between two lines like this. That allows her queries for individuals to be fast. But if we want to use prologs and multiple solution feature, this cut operator breaks it. We gain some efficiency, but we lose flexibility as a result. If you really want a list of permitted users, there's another way to accomplish that. More of it, I'm going to talk about it in this lecture. Now, another use of the cut operator is to force a query to fail. Why on earth would you want to do that? Well, suppose one day, Anna gets cut point Corn Flakes down the telescope tube. Obviously, her telescope privileges are going to get revoked. Say other line saying that telescope Anna fails. The next day, you're out, your friend takes your shift and doesn't know what happened with Anna. Anna shows up smiling, holding a box of rice crispies and asks for the telescope key. Unfortunately, the program says she's allowed to have it. The problem here is that when telescope Anna failed for the first clause, prolog went to try the second clause. We can fix that by putting a cut operator before the fail. Now, we can ask about Anna and be told no, and we can ask about Harry and be told yes. Of course, we still lose the ability to ask for a whole list. Now, in case you're wondering the way to get a whole list is of another category, maybe call it people or candidates and magic and set first. So, to wrap up, cut can start prolog from searching further if you know that the search will be useless. It can make queries more efficient, but it can take a while to develop a good intuition for how couple affect queries, so you have to be careful with them. Here's a final fun thing you can write using cut. You can negate the result with this code, you run not X and prolog will try to solve X directly. If that works, it cuts and fails, turning success and a failure. But if call exhales, then line two will reverse the decision, making it succeed.