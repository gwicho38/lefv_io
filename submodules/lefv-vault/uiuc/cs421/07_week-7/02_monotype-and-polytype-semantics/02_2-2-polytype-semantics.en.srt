1
00:00:00,000 --> 00:00:02,325
Hello and welcome back.

2
00:00:02,325 --> 00:00:05,100
In the last video, we introduced typing semantics,

3
00:00:05,100 --> 00:00:06,945
and showed you how proof rules worked.

4
00:00:06,945 --> 00:00:09,190
The system we showed you has a limitation though,

5
00:00:09,190 --> 00:00:12,750
it can't handle polymorphic types like the ones you get in Haskell.

6
00:00:12,750 --> 00:00:16,200
A function return the length of a list is not typable in that system.

7
00:00:16,200 --> 00:00:20,260
So, in this video, we're going to add polymorphism to the system.

8
00:00:20,780 --> 00:00:22,890
When you're done with this lesson,

9
00:00:22,890 --> 00:00:27,825
you'll be able to use two new rules called Gen and Inst to introduce polymorphic types.

10
00:00:27,825 --> 00:00:31,020
You'll use the new syntax and type signatures called for all.

11
00:00:31,020 --> 00:00:36,090
You will also see a difference between function application and Let expression.

12
00:00:36,090 --> 00:00:41,160
Finally, you'll know how to write proof trees for polymorphic type programs.

13
00:00:41,160 --> 00:00:43,810
As a reminder, here's a language we're using:

14
00:00:43,810 --> 00:00:48,510
just lambda calculus with some nice things like if, let, and arithmetic.

15
00:00:49,120 --> 00:00:53,940
You probably understand intuitively at this point why we need polymorphic types,

16
00:00:53,940 --> 00:00:57,200
but here's a concise example that illustrates the problem.

17
00:00:57,200 --> 00:00:59,300
The original let rule looks like this.

18
00:00:59,300 --> 00:01:02,800
It assigns a type to some variable x based on the type of e_1,

19
00:01:02,800 --> 00:01:06,680
and then modifies Gamma to use that type when checking the type of e_2.

20
00:01:06,680 --> 00:01:08,480
But in this code example,

21
00:01:08,480 --> 00:01:11,180
we define f to be the identity function.

22
00:01:11,180 --> 00:01:12,320
Then apply it twice,

23
00:01:12,320 --> 00:01:14,525
once to a string and once to an integer.

24
00:01:14,525 --> 00:01:16,880
If we try to draw out the proof tree,

25
00:01:16,880 --> 00:01:19,820
we will give f the type alpha arrow Alpha,

26
00:01:19,820 --> 00:01:21,935
and then have to pick what Alpha should be.

27
00:01:21,935 --> 00:01:23,945
It could be a string or it could be an int,

28
00:01:23,945 --> 00:01:26,190
but it can't be both.

29
00:01:26,360 --> 00:01:28,715
So, let's fix that.

30
00:01:28,715 --> 00:01:31,475
We're going to have two kinds of type variables now.

31
00:01:31,475 --> 00:01:32,810
We'll start with monotypes,

32
00:01:32,810 --> 00:01:35,390
and we'll use the variable Tau to represent them.

33
00:01:35,390 --> 00:01:38,375
These can be our ground types like Ints, Bools, etc.

34
00:01:38,375 --> 00:01:39,829
They can also be instantiated

35
00:01:39,829 --> 00:01:43,370
type constructors like list of Int and functions from Int to Int.

36
00:01:43,370 --> 00:01:45,920
Finally, we can have a type variable Alpha to

37
00:01:45,920 --> 00:01:48,910
represent the type that we haven't decided on yet.

38
00:01:48,910 --> 00:01:51,070
Next, we have polytypes.

39
00:01:51,070 --> 00:01:53,915
We'll use lowercase sigma to represent them.

40
00:01:53,915 --> 00:01:55,730
A Polytype can be one of two things;

41
00:01:55,730 --> 00:02:01,390
it can be a monotypic Tau l or a qualified type for all Alpha dot sigma.

42
00:02:01,390 --> 00:02:03,190
The basic idea is this;

43
00:02:03,190 --> 00:02:06,650
in the monotype system we said that you cannot leave Alphas in

44
00:02:06,650 --> 00:02:11,285
the final proof tree anymore that you can leave in e_1 or e_2 in the proof tree.

45
00:02:11,285 --> 00:02:12,890
They have to be filled in.

46
00:02:12,890 --> 00:02:18,350
But the forall says that we choose to leave a specific Alpha unspecified.

47
00:02:18,350 --> 00:02:22,070
In Haskell, every polymorphic type as a forall in front,

48
00:02:22,070 --> 00:02:23,770
and it's usually hidden.

49
00:02:23,770 --> 00:02:29,135
The language extension scoped type variables allows you to be explicit about them.

50
00:02:29,135 --> 00:02:32,390
So, here's some Haskell functions that you already know about

51
00:02:32,390 --> 00:02:35,095
with the explicit forall parts given.

52
00:02:35,095 --> 00:02:39,090
Again, the forall is implicit at the top level by default.

53
00:02:39,090 --> 00:02:43,345
So, let's start fixing our type rules to allow polymorphism.

54
00:02:43,345 --> 00:02:45,130
We can start with the variable rule.

55
00:02:45,130 --> 00:02:48,745
The original one says that a lookup must produce a monotype.

56
00:02:48,745 --> 00:02:51,260
Now, we simply change the Tau to a Sigma to

57
00:02:51,260 --> 00:02:54,170
indicate that a lookup can produce a polytype.

58
00:02:54,170 --> 00:02:58,360
The function rule and the application rule don't need to change.

59
00:02:58,360 --> 00:03:00,960
Now we need to fix let.

60
00:03:00,960 --> 00:03:04,965
The old let extends Gamma with a variable x of type Tau.

61
00:03:04,965 --> 00:03:09,090
The new and improved let extends Gamma with an x of type Sigma.

62
00:03:09,090 --> 00:03:12,380
So far, what you've seen is that we're changing some rules to say

63
00:03:12,380 --> 00:03:15,635
that they can accommodate polytypes and leaving other rules alone.

64
00:03:15,635 --> 00:03:20,515
But now, we need a way of converting from polytype to monotype and back.

65
00:03:20,515 --> 00:03:22,560
To do this, we have two rules,

66
00:03:22,560 --> 00:03:25,410
Gen and Inst to allow us to deal with the polytypes.

67
00:03:25,410 --> 00:03:27,825
The Gen rule means generalize.

68
00:03:27,825 --> 00:03:30,260
The assumption in the rules says that we

69
00:03:30,260 --> 00:03:33,200
suppose that we have type check some expression e,

70
00:03:33,200 --> 00:03:35,795
and gotten a polytype Sigma for it.

71
00:03:35,795 --> 00:03:39,870
Then assuming also that Alpha does not occur free in Gamma,

72
00:03:39,870 --> 00:03:43,165
we can put a forall Alpha in front of the type.

73
00:03:43,165 --> 00:03:46,355
The example proof tree shows how this might be useful.

74
00:03:46,355 --> 00:03:49,880
Remember that identity function from the let example we had earlier.

75
00:03:49,880 --> 00:03:52,200
We type checked it as Alpha arrow Alpha,

76
00:03:52,200 --> 00:03:53,600
indicating that at some point,

77
00:03:53,600 --> 00:03:57,425
we were going to pick a specific type to substitute in for Alpha.

78
00:03:57,425 --> 00:04:00,115
By putting a forall Alpha in front,

79
00:04:00,115 --> 00:04:02,830
we say that we don't want to pick it right now,

80
00:04:02,830 --> 00:04:05,605
we will decide later what to do.

81
00:04:05,605 --> 00:04:08,610
The Inst rule says we can take a forall type

82
00:04:08,610 --> 00:04:11,300
and instantiate the Alpha with the specific type.

83
00:04:11,300 --> 00:04:13,370
The Haskell example shows rewriting

84
00:04:13,370 --> 00:04:17,255
the identity function's type from Alpha arrow Alpha to Int arrow Int.

85
00:04:17,255 --> 00:04:20,175
The point of the two rules is this: before,

86
00:04:20,175 --> 00:04:22,585
when we had an Alpha in our proof tree,

87
00:04:22,585 --> 00:04:25,565
we had to decide globally what that Alpha should be.

88
00:04:25,565 --> 00:04:28,040
But the forall and these Gen and Inst rules will

89
00:04:28,040 --> 00:04:30,490
allow to decide locally what Alpha should be.

90
00:04:30,490 --> 00:04:34,399
That gives us the possibility of making different decisions in different places,

91
00:04:34,399 --> 00:04:36,740
which is what polymorphism is all about.

92
00:04:36,740 --> 00:04:38,475
So, there's one other detail.

93
00:04:38,475 --> 00:04:40,910
You may have noticed the sign condition

94
00:04:40,910 --> 00:04:43,865
about Sigma prime being greater than or equal to Sigma,

95
00:04:43,865 --> 00:04:46,255
so let's talk about that now.

96
00:04:46,255 --> 00:04:48,780
We have this idea, the type hierarchy,

97
00:04:48,780 --> 00:04:50,385
but it's really very simple.

98
00:04:50,385 --> 00:04:53,600
A type with the forall Alpha in it is greater than a type whether

99
00:04:53,600 --> 00:04:57,700
the forall is removed and all the Alphas are replaced by the same monotype.

100
00:04:57,700 --> 00:05:01,775
This is just to say once you decide what Alpha is inside of a type,

101
00:05:01,775 --> 00:05:04,475
you have to replace all of them with the same thing.

102
00:05:04,475 --> 00:05:09,410
It's often useful to have greater than or equal instead of strict greater than,

103
00:05:09,410 --> 00:05:11,660
which lets us do something like in the third example,

104
00:05:11,660 --> 00:05:12,980
we don't take off the forall,

105
00:05:12,980 --> 00:05:15,360
but replace the Alphas with Betas.

106
00:05:15,360 --> 00:05:17,840
So, let's look at a couple of examples.

107
00:05:17,840 --> 00:05:22,045
Here, we want to apply id to Int, an integer.

108
00:05:22,045 --> 00:05:24,470
So, this is an App rule.

109
00:05:24,470 --> 00:05:28,620
The two assumptions we need are the Inst rule since id is a polymorphic type,

110
00:05:28,620 --> 00:05:31,925
and a function application needs a monomorphic type.

111
00:05:31,925 --> 00:05:35,550
The Inst rule will use the variable as an assumption,

112
00:05:35,550 --> 00:05:38,585
which is how we get the polymorphic type of id.

113
00:05:38,585 --> 00:05:42,140
The Inst variables often come together as a package deal,

114
00:05:42,140 --> 00:05:46,820
and it's possible to write our proof rules to conflate the var in Inst rules.

115
00:05:46,820 --> 00:05:51,080
Here's an example that uses Gen. We want to use

116
00:05:51,080 --> 00:05:55,795
Let to define a function f that's an identity function and then return it.

117
00:05:55,795 --> 00:06:00,800
So, we use the function rule to decide the type of identity is Alpha arrow Alpha,

118
00:06:00,800 --> 00:06:03,230
and then the Gen rule to make it polymorphic.

119
00:06:03,230 --> 00:06:08,070
So, I'll let you look at this proof tree for a minute before going on.

120
00:06:09,380 --> 00:06:13,340
An interesting consequence of our type rules is

121
00:06:13,340 --> 00:06:15,500
that function application and Let expression are

122
00:06:15,500 --> 00:06:18,080
not as closely related as they first appear.

123
00:06:18,080 --> 00:06:21,770
Sometimes when people write interpreters for non-typed languages,

124
00:06:21,770 --> 00:06:26,540
that will translate a let expression into a function definition in application.

125
00:06:26,540 --> 00:06:28,670
When we use this type system though,

126
00:06:28,670 --> 00:06:30,865
you'll get a different result between the two.

127
00:06:30,865 --> 00:06:33,560
Try out these two expressions and see if you

128
00:06:33,560 --> 00:06:36,035
can use a type rules to explain the difference.

129
00:06:36,035 --> 00:06:38,220
Resume when you're ready.

130
00:06:39,220 --> 00:06:43,475
So, the Let works but the function does not.

131
00:06:43,475 --> 00:06:46,880
Remember when we looked at the application rule and noted it did

132
00:06:46,880 --> 00:06:51,030
not change to handle the polymorphic types.

133
00:06:52,730 --> 00:06:55,460
Now, if you want to build a proper proof tree,

134
00:06:55,460 --> 00:06:59,545
you're going to need to add a rule for pairs and then type check these two expressions.

135
00:06:59,545 --> 00:07:03,009
The intuition behind the difference is that when we use a Let,

136
00:07:03,009 --> 00:07:06,190
we're creating something that we could use in multiple places.

137
00:07:06,190 --> 00:07:07,830
But when we're calling a function,

138
00:07:07,830 --> 00:07:12,380
we want to be specific at that time about what the type should be.

139
00:07:12,380 --> 00:07:15,780
So, that's it for polymorphic type systems for today,

140
00:07:15,780 --> 00:07:19,300
but there are other ways you can extend polymorphic types, for example,

141
00:07:19,300 --> 00:07:22,300
there are systems where the forall can come in the middle of a type,

142
00:07:22,300 --> 00:07:24,190
or we can declare that certain type variables are

143
00:07:24,190 --> 00:07:26,675
dependent on the value of other type variables.

144
00:07:26,675 --> 00:07:28,740
There's some Haskell extensions that allow you to

145
00:07:28,740 --> 00:07:31,840
look at these things if you're interested.