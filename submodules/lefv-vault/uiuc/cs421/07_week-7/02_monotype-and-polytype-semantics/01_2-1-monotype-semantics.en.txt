Hello and welcome to CS421. You've seen semantic systems that describe
the behavior of programs in a given programming language. But semantics can do more that. Semantics can also be used to describe
properties of expressions in a language. Today we're going to talk
about typing semantics. This will be in two parts. This first part will talk about monotype
expressions, that is expressions that don't have type variables in them, and the
next part will be polymorphic expressions. And when you're done with this video,
you'll be able to explain what a type judgment is, and
what the parts of one are for. You'll be able to build proof trees to
indicate the types of an expression, and you'll be able to use the type rules to
indicate when you can change the contents of a type environment. If you haven't seen typing semantics
before, you might not have understood a single word I've said just now,
but don't worry about that. It'll all make sense at
the end of this video. And for our sample language,
we're going to use lambda calculus, extended to include a few useful
things like integers, and Latin if. We use a circle plus to represent energy
operations like plus and minus and we use tilde to represent comparison operations
like less than, greater than and so on. So let's talk about type judgements. Type judgements look like this. The first symbol is the capital
Greek letter gamma, and is a traditional letter to used
to represent a type environment. My type environment is just like a normal
environment but instead of mapping variable names to their values they
map variable names to their types. The second symbol that looks
like a sideways T is sometimes called turnstile or
sometimes pronounced entails. It's just a marker to separate
the environment from everything else. The E is the expression
I'm going to talk about. The colon separates
the expression from the next part. And the alpha is where we put the type. Now here are two examples. Just reading them out, the first one would
say that gamma entails that if true, then 4else38 has type int. And the second one would say
that gamma entails that true and false have type Bool. And now that you have a type judgement,
you can build type rules. We use the same system for rules that
we used with big step semantics. We put assumptions on the top and
the conclusion on the bottom, and on the right side we put
the name of the rule. This rule, the BINOP rule,
says that if e1 and e2 are integers, then e1 + e2 is also an integer. A plus could also be minus or
times or some other binary operation. You decided you want to write out gamma, you use set notation, the elements
having the form variable colon type. Sometimes we leave out gamma if
it doesn't matter for our rule. If a rule doesn't have any assumptions,
it's called an axiom. So here some axioms for our system. The const rule says that
n is an integer and we have a side condition that
n must in fact be an integer. We also have the type variable rule
that says x has type alpha if that fact is included in gamma. Now some people will put the x: alpha and gamma as an assumption rather than a side
condition, kind of depends on the author. I like to leave it as a side condition
since it's not a type judgement. Now here are a few simple rules. Binary operations take ints and
combine them into a new int. Relational operators take ints and
create Booleans. Boolean operations take Booleans and
return more Booleans. Now I've chosen to make
these different rules for the different kinds of operations. But another way to have done it would've
been to make a list of operations and have their type signatures and
then have one rule that expresses that. Now I've chosen to make different rules
for the different kinds of operations, but it's also possible to have a list of
operations with their type signatures and then have one rule do something
like a lookup in that list. Now just like in big step semantics
you can combine these rules together to make proof trees. The way I do it is to write down what I'm
trying to prove and put a bar over it. A proof tree is going to get big so it's best to put this towards
the bottom of your paper. The most important thing to
decide is what rule applies. So which one do you
think that we need here? Since we have a Boolean operation
we use the BoolOp rule. Here it is below. Now we can take the sub expressions and
use them to build type judgements on top. Next we're going to continue
with x times 5 greater than 7. Now that expression is
a relation operation. So we split it into x times 5 and 7. Next we're going to look at the x times 5. The x part uses the variable rule,
and the 5 part uses the constant rule. I've added the rules labels
to the rest of the tree. And now this proof tree is done. Now so far so good. But sometimes we have rules where we
don't know what the type will be upfront. Consider this rule, the If rule. It says that e1 has to have type Bool and
e2 and e3 must have some type alpha. In other words we don't
care what the types e2 and e3 are as long as they are the same. The alpha here is a meta-variable
just like e1, e2, and e3. All them of them must be replaced by
valid expressions or types in order for the proof tree to be complete. We'll extend this system in the next
video to handle polymorphic things. Here's the rule for function application. If e1 has type alpha2 to alpha,
and e2 has type alpha2, and e1 applied to e2 has type alpha. If a function has an input type and
an output type, passing something in the input type, you should get
back something of the output type. If you're familiar with logic, this may
remind you of the rule of modus ponens. And, in fact, there is a correspondence
between types of programs and logical proofs. And it's called
the Curry-Howard isomorphism. Means that computer programs can be seen
as proof objects in a logical system. It shows that there's some deep
connections between programming languages and mathematics. Here's the rule for functions, this one's
special because it's the first rule we've shown you that allows you to
change the contents of gamma. It's important to understand this
one well, so let's work an example. We'll look at the type of lambda
x.x + 1 has type Int arrow Int. This is clearly going to be
the abstraction rule so we draw a line and label the rule we're going to use. Now we put x into gamma and try to
type check the body of the function. The body is a binary operation and
the x and one just need the variable and const rule and
now we have a complete proof tree. So let's introduce the last two rules for
this video. Here are two versions of let. The top one is for
let expressions that are not recursive. Languages like OCaml and
LISP use this kind by default, and have recursive versions if you need them. You'll notice that the e1 term is
typed checked in the original gamma. In the recursive version,
we use the updated gamma to type check e1. That's because the variable we're
defining can occur as a subterm in e1. So that's it for monotypes. Be sure to take a look at the handout for
a few more example proof trees.