Hello and welcome back. In the last video, we introduced typing semantics, and showed you how proof rules worked. The system we showed you has a limitation though, it can't handle polymorphic types like the ones you get in Haskell. A function return the length of a list is not typable in that system. So, in this video, we're going to add polymorphism to the system. When you're done with this lesson, you'll be able to use two new rules called Gen and Inst to introduce polymorphic types. You'll use the new syntax and type signatures called for all. You will also see a difference between function application and Let expression. Finally, you'll know how to write proof trees for polymorphic type programs. As a reminder, here's a language we're using: just lambda calculus with some nice things like if, let, and arithmetic. You probably understand intuitively at this point why we need polymorphic types, but here's a concise example that illustrates the problem. The original let rule looks like this. It assigns a type to some variable x based on the type of e_1, and then modifies Gamma to use that type when checking the type of e_2. But in this code example, we define f to be the identity function. Then apply it twice, once to a string and once to an integer. If we try to draw out the proof tree, we will give f the type alpha arrow Alpha, and then have to pick what Alpha should be. It could be a string or it could be an int, but it can't be both. So, let's fix that. We're going to have two kinds of type variables now. We'll start with monotypes, and we'll use the variable Tau to represent them. These can be our ground types like Ints, Bools, etc. They can also be instantiated type constructors like list of Int and functions from Int to Int. Finally, we can have a type variable Alpha to represent the type that we haven't decided on yet. Next, we have polytypes. We'll use lowercase sigma to represent them. A Polytype can be one of two things; it can be a monotypic Tau l or a qualified type for all Alpha dot sigma. The basic idea is this; in the monotype system we said that you cannot leave Alphas in the final proof tree anymore that you can leave in e_1 or e_2 in the proof tree. They have to be filled in. But the forall says that we choose to leave a specific Alpha unspecified. In Haskell, every polymorphic type as a forall in front, and it's usually hidden. The language extension scoped type variables allows you to be explicit about them. So, here's some Haskell functions that you already know about with the explicit forall parts given. Again, the forall is implicit at the top level by default. So, let's start fixing our type rules to allow polymorphism. We can start with the variable rule. The original one says that a lookup must produce a monotype. Now, we simply change the Tau to a Sigma to indicate that a lookup can produce a polytype. The function rule and the application rule don't need to change. Now we need to fix let. The old let extends Gamma with a variable x of type Tau. The new and improved let extends Gamma with an x of type Sigma. So far, what you've seen is that we're changing some rules to say that they can accommodate polytypes and leaving other rules alone. But now, we need a way of converting from polytype to monotype and back. To do this, we have two rules, Gen and Inst to allow us to deal with the polytypes. The Gen rule means generalize. The assumption in the rules says that we suppose that we have type check some expression e, and gotten a polytype Sigma for it. Then assuming also that Alpha does not occur free in Gamma, we can put a forall Alpha in front of the type. The example proof tree shows how this might be useful. Remember that identity function from the let example we had earlier. We type checked it as Alpha arrow Alpha, indicating that at some point, we were going to pick a specific type to substitute in for Alpha. By putting a forall Alpha in front, we say that we don't want to pick it right now, we will decide later what to do. The Inst rule says we can take a forall type and instantiate the Alpha with the specific type. The Haskell example shows rewriting the identity function's type from Alpha arrow Alpha to Int arrow Int. The point of the two rules is this: before, when we had an Alpha in our proof tree, we had to decide globally what that Alpha should be. But the forall and these Gen and Inst rules will allow to decide locally what Alpha should be. That gives us the possibility of making different decisions in different places, which is what polymorphism is all about. So, there's one other detail. You may have noticed the sign condition about Sigma prime being greater than or equal to Sigma, so let's talk about that now. We have this idea, the type hierarchy, but it's really very simple. A type with the forall Alpha in it is greater than a type whether the forall is removed and all the Alphas are replaced by the same monotype. This is just to say once you decide what Alpha is inside of a type, you have to replace all of them with the same thing. It's often useful to have greater than or equal instead of strict greater than, which lets us do something like in the third example, we don't take off the forall, but replace the Alphas with Betas. So, let's look at a couple of examples. Here, we want to apply id to Int, an integer. So, this is an App rule. The two assumptions we need are the Inst rule since id is a polymorphic type, and a function application needs a monomorphic type. The Inst rule will use the variable as an assumption, which is how we get the polymorphic type of id. The Inst variables often come together as a package deal, and it's possible to write our proof rules to conflate the var in Inst rules. Here's an example that uses Gen. We want to use Let to define a function f that's an identity function and then return it. So, we use the function rule to decide the type of identity is Alpha arrow Alpha, and then the Gen rule to make it polymorphic. So, I'll let you look at this proof tree for a minute before going on. An interesting consequence of our type rules is that function application and Let expression are not as closely related as they first appear. Sometimes when people write interpreters for non-typed languages, that will translate a let expression into a function definition in application. When we use this type system though, you'll get a different result between the two. Try out these two expressions and see if you can use a type rules to explain the difference. Resume when you're ready. So, the Let works but the function does not. Remember when we looked at the application rule and noted it did not change to handle the polymorphic types. Now, if you want to build a proper proof tree, you're going to need to add a rule for pairs and then type check these two expressions. The intuition behind the difference is that when we use a Let, we're creating something that we could use in multiple places. But when we're calling a function, we want to be specific at that time about what the type should be. So, that's it for polymorphic type systems for today, but there are other ways you can extend polymorphic types, for example, there are systems where the forall can come in the middle of a type, or we can declare that certain type variables are dependent on the value of other type variables. There's some Haskell extensions that allow you to look at these things if you're interested.