Hello and welcome to CS421. Now when we're parsing strings
in their programming language, it's common to first divide
the input stream into words or tokens instead of characters before
we try building trees with them. Now, this step is called flexing or
scanning and the most common way of doing that
involves the use of regular expressions. So by the time you're done with this
video, you'll know the syntax for specifying regular expressions and be able
to use them to model sets of strings. You will also be able to explain what the
limitations of regular expressions are. Regular expressions were actually
first proposed as a stepping stone for describing human languages. Natural language is often highly context
dependent though and cannot be described fully with grammars like the one's we've
been using, but it turns out these grammars are very good at describing
the grammars of computer languages. Now, regular expressions
are especially useful for categorizing the different kinds of
tokens that appear in a computer program. Now, we can describe what this
talking would look like in English. But if we are going to
specify them to a computer, we're going to need a lot more
formal way of specify them. Now specify regular language we
are going to use something cover regular expression, which is a pattern in that represent
the kind of words we want to describe. There are four kinds of patterns. There's single letters. There's repetition. There's grouping and there's choice. These patterns can be converted in NFAs or
non-deterministic. We use something called Thompson's
construction, which we will demonstrate on these slides and this will allow
the computer to recognize words with them. Now we will assume that you have
seen NFAs in another course, so we're not going to spend too much
time explaining how they work here. So let's look at the syntax for
regular expressions. A first pattern type was
was a single letter. A regular expression for the letter could
be simpler, it's the letter itself. So if we wanted a regular expression
that matched the letter a, we just write an a down. If we think of this as a state machine,
we only need two states. The first state is our start state and the transition to the second state,
given the letter a. This state machine tells us if the input
machine matches with the given regular expression. When this happens, we say that
the regular expression accepts or recognizes the input. It's boring to match only one letter, but we can combine patterns
simply by juxtaposing them. If you want to match an a followed
by an 8, just write down a8. Here's a state machine for a8. The two state machines can simply be
linked together to get the full state machine. We use star and
plus to represent repetition. The star operator is called
the clean star and says, we want zero or more copies of
the thing that came before it. A state machine is a bit more complicated
than you might have guessed at first. Notice how we have q0 and
q3 as endpoints for the machine and then epsilon transitions
separating those endpoints from the part of the machine that
actually does the work. These turn out to be necessary when we
combine state machines together for generating larger state machines. Now the formal definition of regular
expression only has star, but most implementations also use plus
to represent one or more copy. We can use parenthesis to
group things together. And if you really want to match
against a parenthesis character, you would put a back slash in front of it
as an escape character like if you were using a utility on a computer for this. Now for choice, we use the vertical bar. You can remember this since it's like
the or operator in most languages. The state machine uses two endpoint states
with epsilon to allow you to pick which pattern you want to use. Here is some examples
of regular expressions. So a star b matches strings up again and
in with a, and have any number of b's inside them. Zero or
one star matches any string one one's and zero's including the empty string. If we use a plus instead,
it will reject the empty string and we can use this top match binary numbers. If we put a zero at the end of that, this would represent binary
numbers with zero at the end. Or in other words, even binary numbers. The next two regular expressions
match an odd number of as. The groups in the parenthesis
match two as at a time. Finally, we have this long one here that
matches an even number of as and bs. You should try to check for
yourself whether that really works. Now, there are many wonderful
utilities that use regular expression. Command like programs like grep and
said use them extensively, and so do many programmers editors. They're also easy to use in scripting
languages, such as Python, Perl and Ruby. Almost all of these have
extra syntax to allow for easier specification of patterns. So here, we have the square
brackets representing ranges and dot represents a wildcard and
backslash makes a character literal. These are the most common ones. Some of them have others, as well. One of the downsides of regular
expressions and utility, different programs often implement
them in slightly different ways. So you'll have to spend a lot of time
checking the documentation when you're switching back and forth. So there's some things you need to
know about regular expressions. They're good at matching words,
but they're not good for more complex structures. So for one thing, they are greedy. They will match the largest
possible string in the input, which sometimes does not do what you want. So the example here, X.*Y will match this
entire word not just the first part. Whether that's a bug or a feature
will depend on what you had in mind. They also cannot do anything that
requires unbounded counting. You can write a regular expression that
matches a prime number of a's, but up to a limit. You can't write a regular expression
that matches any prime number of a's since that requires
an unbounded computation. So another example, you can write a regular expression that
can detect if a number is divisible by 4. You can do that in finite amount of time, because all you have to do is
look at the last two digits. Now, a classic limit is the whole
nested comment situation. If you try to write a regular expression
that ignores comments, you'll have trouble if someone comments out a region
with comments incited already. And it's no good trying to write
a more complicated regular expression, because someone can always put
another nesting layer of comments. So most systems have extensions to
work around these sorts of problems. So you'll just have to check the
documentation of your particular system if you want to know more details about that.