1
00:00:00,041 --> 00:00:03,769
Hello and welcome to CS421.

2
00:00:03,769 --> 00:00:07,141
Now when we're parsing strings
in their programming language,

3
00:00:07,141 --> 00:00:10,146
it's common to first divide
the input stream into words or

4
00:00:10,146 --> 00:00:13,779
tokens instead of characters before
we try building trees with them.

5
00:00:13,779 --> 00:00:16,403
Now, this step is called flexing or
scanning and

6
00:00:16,403 --> 00:00:20,436
the most common way of doing that
involves the use of regular expressions.

7
00:00:20,436 --> 00:00:23,961
So by the time you're done with this
video, you'll know the syntax for

8
00:00:23,961 --> 00:00:27,986
specifying regular expressions and be able
to use them to model sets of strings.

9
00:00:27,986 --> 00:00:32,261
You will also be able to explain what the
limitations of regular expressions are.

10
00:00:32,261 --> 00:00:36,544
Regular expressions were actually
first proposed as a stepping stone for

11
00:00:36,544 --> 00:00:38,347
describing human languages.

12
00:00:38,347 --> 00:00:43,004
Natural language is often highly context
dependent though and cannot be described

13
00:00:43,004 --> 00:00:47,327
fully with grammars like the one's we've
been using, but it turns out these

14
00:00:47,327 --> 00:00:51,535
grammars are very good at describing
the grammars of computer languages.

15
00:00:51,535 --> 00:00:54,370
Now, regular expressions
are especially useful for

16
00:00:54,370 --> 00:00:58,593
categorizing the different kinds of
tokens that appear in a computer program.

17
00:00:58,593 --> 00:01:01,339
Now, we can describe what this
talking would look like in English.

18
00:01:01,339 --> 00:01:04,621
But if we are going to
specify them to a computer,

19
00:01:04,621 --> 00:01:08,392
we're going to need a lot more
formal way of specify them.

20
00:01:08,392 --> 00:01:11,672
Now specify regular language we
are going to use something cover

21
00:01:11,672 --> 00:01:12,871
regular expression,

22
00:01:12,871 --> 00:01:16,797
which is a pattern in that represent
the kind of words we want to describe.

23
00:01:16,797 --> 00:01:18,508
There are four kinds of patterns.

24
00:01:18,508 --> 00:01:19,651
There's single letters.

25
00:01:19,651 --> 00:01:20,884
There's repetition.

26
00:01:20,884 --> 00:01:23,294
There's grouping and there's choice.

27
00:01:23,294 --> 00:01:28,003
These patterns can be converted in NFAs or
non-deterministic.

28
00:01:28,003 --> 00:01:32,212
We use something called Thompson's
construction, which we will demonstrate on

29
00:01:32,212 --> 00:01:36,119
these slides and this will allow
the computer to recognize words with them.

30
00:01:36,119 --> 00:01:39,812
Now we will assume that you have
seen NFAs in another course, so

31
00:01:39,812 --> 00:01:43,792
we're not going to spend too much
time explaining how they work here.

32
00:01:43,792 --> 00:01:47,605
So let's look at the syntax for
regular expressions.

33
00:01:47,605 --> 00:01:50,200
A first pattern type was
was a single letter.

34
00:01:50,200 --> 00:01:54,233
A regular expression for the letter could
be simpler, it's the letter itself.

35
00:01:54,233 --> 00:01:57,490
So if we wanted a regular expression
that matched the letter a,

36
00:01:57,490 --> 00:01:58,724
we just write an a down.

37
00:01:58,724 --> 00:02:02,396
If we think of this as a state machine,
we only need two states.

38
00:02:02,396 --> 00:02:04,914
The first state is our start state and

39
00:02:04,914 --> 00:02:08,824
the transition to the second state,
given the letter a.

40
00:02:08,824 --> 00:02:13,531
This state machine tells us if the input
machine matches with the given

41
00:02:13,531 --> 00:02:15,053
regular expression.

42
00:02:15,053 --> 00:02:18,793
When this happens, we say that
the regular expression accepts or

43
00:02:18,793 --> 00:02:20,160
recognizes the input.

44
00:02:20,160 --> 00:02:22,829
It's boring to match only one letter, but

45
00:02:22,829 --> 00:02:26,176
we can combine patterns
simply by juxtaposing them.

46
00:02:26,176 --> 00:02:31,212
If you want to match an a followed
by an 8, just write down a8.

47
00:02:31,212 --> 00:02:33,554
Here's a state machine for a8.

48
00:02:33,554 --> 00:02:38,443
The two state machines can simply be
linked together to get the full state

49
00:02:38,443 --> 00:02:39,176
machine.

50
00:02:39,176 --> 00:02:42,666
We use star and
plus to represent repetition.

51
00:02:42,666 --> 00:02:46,162
The star operator is called
the clean star and says,

52
00:02:46,162 --> 00:02:50,141
we want zero or more copies of
the thing that came before it.

53
00:02:50,141 --> 00:02:54,141
A state machine is a bit more complicated
than you might have guessed at first.

54
00:02:54,141 --> 00:02:57,632
Notice how we have q0 and
q3 as endpoints for the machine and

55
00:02:57,632 --> 00:03:01,060
then epsilon transitions
separating those endpoints from

56
00:03:01,060 --> 00:03:04,092
the part of the machine that
actually does the work.

57
00:03:04,092 --> 00:03:08,588
These turn out to be necessary when we
combine state machines together for

58
00:03:08,588 --> 00:03:10,844
generating larger state machines.

59
00:03:10,844 --> 00:03:15,296
Now the formal definition of regular
expression only has star, but

60
00:03:15,296 --> 00:03:19,681
most implementations also use plus
to represent one or more copy.

61
00:03:19,681 --> 00:03:22,636
We can use parenthesis to
group things together.

62
00:03:22,636 --> 00:03:26,101
And if you really want to match
against a parenthesis character,

63
00:03:26,101 --> 00:03:30,133
you would put a back slash in front of it
as an escape character like if you were

64
00:03:30,133 --> 00:03:32,213
using a utility on a computer for this.

65
00:03:32,213 --> 00:03:34,810
Now for choice, we use the vertical bar.

66
00:03:34,810 --> 00:03:39,227
You can remember this since it's like
the or operator in most languages.

67
00:03:39,227 --> 00:03:44,221
The state machine uses two endpoint states
with epsilon to allow you to pick which

68
00:03:44,221 --> 00:03:45,769
pattern you want to use.

69
00:03:45,769 --> 00:03:49,047
Here is some examples
of regular expressions.

70
00:03:49,047 --> 00:03:52,655
So a star b matches strings up again and
in with a, and

71
00:03:52,655 --> 00:03:55,197
have any number of b's inside them.

72
00:03:55,197 --> 00:03:58,366
Zero or
one star matches any string one one's and

73
00:03:58,366 --> 00:04:00,844
zero's including the empty string.

74
00:04:00,844 --> 00:04:04,657
If we use a plus instead,
it will reject the empty string and

75
00:04:04,657 --> 00:04:07,340
we can use this top match binary numbers.

76
00:04:07,340 --> 00:04:09,177
If we put a zero at the end of that,

77
00:04:09,177 --> 00:04:12,415
this would represent binary
numbers with zero at the end.

78
00:04:12,415 --> 00:04:15,278
Or in other words, even binary numbers.

79
00:04:15,278 --> 00:04:18,829
The next two regular expressions
match an odd number of as.

80
00:04:18,829 --> 00:04:23,187
The groups in the parenthesis
match two as at a time.

81
00:04:23,187 --> 00:04:27,606
Finally, we have this long one here that
matches an even number of as and bs.

82
00:04:27,606 --> 00:04:32,226
You should try to check for
yourself whether that really works.

83
00:04:32,226 --> 00:04:35,730
Now, there are many wonderful
utilities that use regular expression.

84
00:04:35,730 --> 00:04:39,966
Command like programs like grep and
said use them extensively, and

85
00:04:39,966 --> 00:04:42,057
so do many programmers editors.

86
00:04:42,057 --> 00:04:47,086
They're also easy to use in scripting
languages, such as Python, Perl and Ruby.

87
00:04:47,086 --> 00:04:50,268
Almost all of these have
extra syntax to allow for

88
00:04:50,268 --> 00:04:52,682
easier specification of patterns.

89
00:04:52,682 --> 00:04:56,244
So here, we have the square
brackets representing ranges and

90
00:04:56,244 --> 00:05:00,227
dot represents a wildcard and
backslash makes a character literal.

91
00:05:00,227 --> 00:05:01,992
These are the most common ones.

92
00:05:01,992 --> 00:05:04,484
Some of them have others, as well.

93
00:05:04,484 --> 00:05:07,855
One of the downsides of regular
expressions and utility,

94
00:05:07,855 --> 00:05:12,002
different programs often implement
them in slightly different ways.

95
00:05:12,002 --> 00:05:15,713
So you'll have to spend a lot of time
checking the documentation when you're

96
00:05:15,713 --> 00:05:17,037
switching back and forth.

97
00:05:17,037 --> 00:05:20,035
So there's some things you need to
know about regular expressions.

98
00:05:20,035 --> 00:05:23,562
They're good at matching words,
but they're not good for

99
00:05:23,562 --> 00:05:25,193
more complex structures.

100
00:05:25,193 --> 00:05:27,038
So for one thing, they are greedy.

101
00:05:27,038 --> 00:05:30,134
They will match the largest
possible string in the input,

102
00:05:30,134 --> 00:05:32,418
which sometimes does not do what you want.

103
00:05:32,418 --> 00:05:37,951
So the example here, X.*Y will match this
entire word not just the first part.

104
00:05:37,951 --> 00:05:41,751
Whether that's a bug or a feature
will depend on what you had in mind.

105
00:05:41,751 --> 00:05:46,005
They also cannot do anything that
requires unbounded counting.

106
00:05:46,005 --> 00:05:50,436
You can write a regular expression that
matches a prime number of a's, but

107
00:05:50,436 --> 00:05:51,292
up to a limit.

108
00:05:51,292 --> 00:05:55,670
You can't write a regular expression
that matches any prime number

109
00:05:55,670 --> 00:05:59,298
of a's since that requires
an unbounded computation.

110
00:05:59,298 --> 00:06:00,564
So another example,

111
00:06:00,564 --> 00:06:05,356
you can write a regular expression that
can detect if a number is divisible by 4.

112
00:06:05,356 --> 00:06:07,956
You can do that in finite amount of time,

113
00:06:07,956 --> 00:06:11,563
because all you have to do is
look at the last two digits.

114
00:06:11,563 --> 00:06:16,510
Now, a classic limit is the whole
nested comment situation.

115
00:06:16,510 --> 00:06:20,995
If you try to write a regular expression
that ignores comments, you'll have trouble

116
00:06:20,995 --> 00:06:24,436
if someone comments out a region
with comments incited already.

117
00:06:24,436 --> 00:06:28,388
And it's no good trying to write
a more complicated regular expression,

118
00:06:28,388 --> 00:06:32,034
because someone can always put
another nesting layer of comments.

119
00:06:32,034 --> 00:06:35,568
So most systems have extensions to
work around these sorts of problems.

120
00:06:35,568 --> 00:06:39,567
So you'll just have to check the
documentation of your particular system if

121
00:06:39,567 --> 00:06:41,761
you want to know more details about that.