1
00:00:02,060 --> 00:00:05,820
Hello everyone. Welcome to CS 421.

2
00:00:05,820 --> 00:00:08,715
Today, we're going to talk about continuation passing style.

3
00:00:08,715 --> 00:00:12,120
Continuations are a functional representation of what

4
00:00:12,120 --> 00:00:15,480
comes next in a computer program or computation.

5
00:00:15,480 --> 00:00:19,800
We can pass these continuations into functions just like any other high-order function,

6
00:00:19,800 --> 00:00:22,350
and can use them to do some really cool things.

7
00:00:22,350 --> 00:00:24,540
Here are our objectives for today.

8
00:00:24,540 --> 00:00:27,060
After you've walked through the content of this video,

9
00:00:27,060 --> 00:00:30,240
you'll be able to explain what continuation passing style is,

10
00:00:30,240 --> 00:00:33,810
and give some examples of programming techniques that CPS enables,

11
00:00:33,810 --> 00:00:36,545
write a recursive function using CPS.

12
00:00:36,545 --> 00:00:38,650
This'll be a warm-up for the following video,

13
00:00:38,650 --> 00:00:43,030
which will show you how to take an existing function and transform it into CPS.

14
00:00:43,030 --> 00:00:45,045
Here's some example code to consider.

15
00:00:45,045 --> 00:00:47,340
I've written three simple functions, inc,

16
00:00:47,340 --> 00:00:50,115
double, and half, that do the obvious things.

17
00:00:50,115 --> 00:00:52,670
Next, I compose them together as inc, double,

18
00:00:52,670 --> 00:00:55,820
half 10, and save the output in the variable result.

19
00:00:55,820 --> 00:00:58,760
Now, think about what is happening when we run this.

20
00:00:58,760 --> 00:01:00,770
Half will receive the value 10,

21
00:01:00,770 --> 00:01:03,350
process it, and then return it back.

22
00:01:03,350 --> 00:01:07,780
The function double will continue the computation by consuming half's output,

23
00:01:07,780 --> 00:01:10,305
processing it, and then returning it back.

24
00:01:10,305 --> 00:01:15,170
Finally, inc will continue the computation by consuming doubles output,

25
00:01:15,170 --> 00:01:18,730
processing it, and returning it back to be stored in the variable result.

26
00:01:18,730 --> 00:01:23,640
I'm sure you noticed that I talked about the function continuing the computation.

27
00:01:23,640 --> 00:01:26,150
We can make this idea very explicit.

28
00:01:26,150 --> 00:01:30,350
Imagine that we take an expression and punch out a sub-expression.

29
00:01:30,350 --> 00:01:34,225
In this case, let's punch half 10 out of its containing expression.

30
00:01:34,225 --> 00:01:36,280
That leaves an expression with a hole in it,

31
00:01:36,280 --> 00:01:39,140
which we can represent using these strange looking brackets.

32
00:01:39,140 --> 00:01:42,290
As an aside, these brackets are called semantic brackets.

33
00:01:42,290 --> 00:01:44,270
We make them by doubling up square brackets,

34
00:01:44,270 --> 00:01:48,325
and we use them frequently when talking about transformations that work on code.

35
00:01:48,325 --> 00:01:52,310
Anyway, we can call this expression with a hole in it, a context.

36
00:01:52,310 --> 00:01:53,795
After half 10 runs,

37
00:01:53,795 --> 00:01:56,630
its result is going to be placed into the context.

38
00:01:56,630 --> 00:01:59,000
If we turn in this context into a function,

39
00:01:59,000 --> 00:02:00,845
we can call it a continuation.

40
00:02:00,845 --> 00:02:02,545
Let's see how to do that now.

41
00:02:02,545 --> 00:02:05,660
Since a hole is just a spot where we can put a value later,

42
00:02:05,660 --> 00:02:08,570
we can represent that easily by wrapping it in a lambda,

43
00:02:08,570 --> 00:02:11,150
and letting the perimeter of the lambda represent the whole.

44
00:02:11,150 --> 00:02:16,970
In this case, let the continuation be lambda v arrow inc double v. For some reason,

45
00:02:16,970 --> 00:02:19,985
it's common to name the continuations argument v,

46
00:02:19,985 --> 00:02:21,500
Result began with the letter v,

47
00:02:21,500 --> 00:02:23,630
that would have worked for me but, oh well.

48
00:02:23,630 --> 00:02:26,770
Now the next thing we're going to do is augment half.

49
00:02:26,770 --> 00:02:30,515
You will take a second parameter which we call its continuation.

50
00:02:30,515 --> 00:02:34,190
By convention, the continuation argument is usually given a name

51
00:02:34,190 --> 00:02:38,255
beginning with the letter k. At least the word continuation starts with a k sound.

52
00:02:38,255 --> 00:02:39,500
When half is done,

53
00:02:39,500 --> 00:02:42,515
it's going to pass its result to the continuation argument.

54
00:02:42,515 --> 00:02:44,900
This has a very interesting effect.

55
00:02:44,900 --> 00:02:46,790
When we use continuation passing style,

56
00:02:46,790 --> 00:02:50,405
we can imagine that the half function never returns.

57
00:02:50,405 --> 00:02:52,940
Remember in the higher-order function lecture when we talked about

58
00:02:52,940 --> 00:02:55,720
using map to reduce the amount of code we needed to write,

59
00:02:55,720 --> 00:02:58,370
we could simply pass an operation into map,

60
00:02:58,370 --> 00:03:00,295
and it would recurse the list for us.

61
00:03:00,295 --> 00:03:02,250
A similar thing is happening here,

62
00:03:02,250 --> 00:03:04,580
but this time we are parameterizing how

63
00:03:04,580 --> 00:03:08,060
a function returns its value to the rest of the program.

64
00:03:08,060 --> 00:03:09,920
Now, Haskell doesn't have this,

65
00:03:09,920 --> 00:03:14,525
but many languages have an explicit return keyword that functions used to exit.

66
00:03:14,525 --> 00:03:18,755
You can imagine what we're doing here is parameterizing the return keyword.

67
00:03:18,755 --> 00:03:22,865
Now to summarize, we have seen two kinds of recursion so far.

68
00:03:22,865 --> 00:03:24,350
There is direct style,

69
00:03:24,350 --> 00:03:27,080
which is what most people would think of as normal recursion.

70
00:03:27,080 --> 00:03:29,790
There's also tail-recursion or accumulator recursion,

71
00:03:29,790 --> 00:03:33,140
whenever recursive calls happen in a function's tail position.

72
00:03:33,140 --> 00:03:35,075
Now we're going to go a step further.

73
00:03:35,075 --> 00:03:39,095
We're going to assume that when a function passes its result to a continuation,

74
00:03:39,095 --> 00:03:42,175
that the call to the continuation never returns.

75
00:03:42,175 --> 00:03:44,430
Once the call happens in tail position,

76
00:03:44,430 --> 00:03:47,660
it is likely that the bit about not returning is actually true,

77
00:03:47,660 --> 00:03:49,190
the compiler is going to optimize

78
00:03:49,190 --> 00:03:52,325
the underlying machine code to remove the intermediate stack frames.

79
00:03:52,325 --> 00:03:54,130
Now, let's look at some examples.

80
00:03:54,130 --> 00:03:56,390
In this slide, I've converted the rest of the functions

81
00:03:56,390 --> 00:03:59,045
from our initial example to use CPS.

82
00:03:59,045 --> 00:04:02,060
Inc and double are modified similarly to have,

83
00:04:02,060 --> 00:04:03,980
the interesting thing as result.

84
00:04:03,980 --> 00:04:08,220
The continuation fed into half 10 stores the output in v1,

85
00:04:08,220 --> 00:04:10,110
and passes v1 into double.

86
00:04:10,110 --> 00:04:12,180
But now double wants a continuation.

87
00:04:12,180 --> 00:04:15,500
So, we give it one that stores doubles output into v2.

88
00:04:15,500 --> 00:04:20,745
Finally, we can pass v2 in the inc. Inc wants a continuation, but we're done.

89
00:04:20,745 --> 00:04:24,080
So, we pass an ID to make it return the result back to the main program.

90
00:04:24,080 --> 00:04:29,435
So notice, we often we'll have occasion to nest one continuation inside of another one.

91
00:04:29,435 --> 00:04:31,610
One interesting thing people have noticed about

92
00:04:31,610 --> 00:04:35,030
CPS is how similar it is to imperative style.

93
00:04:35,030 --> 00:04:37,900
If you write the functions as colon equals style assignments,

94
00:04:37,900 --> 00:04:40,165
you get something that looks like an imperative program,

95
00:04:40,165 --> 00:04:41,990
so you can see that here.

96
00:04:41,990 --> 00:04:45,635
Let's look at an instance where CPS actually gets us something.

97
00:04:45,635 --> 00:04:49,325
This function here computes the greatest common divisor of a and b.

98
00:04:49,325 --> 00:04:50,780
It's not particularly slow,

99
00:04:50,780 --> 00:04:53,275
but it does have to do a bit of modular arithmetic.

100
00:04:53,275 --> 00:04:57,895
Now, imagine that we want to take the GCD of an entire list of numbers.

101
00:04:57,895 --> 00:05:00,205
We can call this function gcdstar,

102
00:05:00,205 --> 00:05:02,150
and its sources on the next slide.

103
00:05:02,150 --> 00:05:04,500
This is just a simple folding recursion.

104
00:05:04,500 --> 00:05:08,420
The function will traverse self down the list until it hits the empty list,

105
00:05:08,420 --> 00:05:11,090
and then compute the GCD of everything as it returns.

106
00:05:11,090 --> 00:05:16,060
Now, imagine that there's a one near the beginning of the sequence, what would happen?

107
00:05:16,060 --> 00:05:18,765
The GCD of one and anything is one,

108
00:05:18,765 --> 00:05:23,190
so all the GCD operations that happen on the rest of the list would be wasted.

109
00:05:23,190 --> 00:05:27,305
The same thing happens if we wanted to take the product of all the elements of a list,

110
00:05:27,305 --> 00:05:29,560
and somehow there was zero in that list,

111
00:05:29,560 --> 00:05:32,455
lot of multiplications would have occurred uselessly.

112
00:05:32,455 --> 00:05:34,670
There are several things we could do about this,

113
00:05:34,670 --> 00:05:37,190
like checking the list first to see if there's a one in it.

114
00:05:37,190 --> 00:05:39,380
But this is a lecture about continuations,

115
00:05:39,380 --> 00:05:42,425
so let's see how we can use continuations to fix this.

116
00:05:42,425 --> 00:05:44,395
I'm going to talk about this function,

117
00:05:44,395 --> 00:05:48,170
but you might want to pause the video and take a look at it first.

118
00:05:48,170 --> 00:05:51,815
All right. So, there are a few things to notice.

119
00:05:51,815 --> 00:05:54,725
First is that we have an auxiliary function aux,

120
00:05:54,725 --> 00:05:57,790
which uses its own continuation named newk.

121
00:05:57,790 --> 00:06:03,365
We initialize newk by calling aux with k. This has an interesting effect.

122
00:06:03,365 --> 00:06:05,015
Whenever aux is running,

123
00:06:05,015 --> 00:06:07,580
it has two separate continuations in its scope,

124
00:06:07,580 --> 00:06:13,050
its own current continuation newk and the gcdstar wide continuation k,

125
00:06:13,050 --> 00:06:16,280
there's nothing stopping aux from calling either one of these.

126
00:06:16,280 --> 00:06:17,495
In the base case,

127
00:06:17,495 --> 00:06:21,530
aux calls newk with the base case value zero.

128
00:06:21,530 --> 00:06:23,650
The usual recursive case,

129
00:06:23,650 --> 00:06:28,745
aux creates a new continuation by wrapping a lambda around the current continuation.

130
00:06:28,745 --> 00:06:33,140
The parameter res will get the result from their crystal called the aux,

131
00:06:33,140 --> 00:06:35,025
and call GCD on that and x,

132
00:06:35,025 --> 00:06:37,150
and then feed that result into newk.

133
00:06:37,150 --> 00:06:40,415
This is just an accumulator recursion like you've seen before,

134
00:06:40,415 --> 00:06:43,430
but we're accumulating now as a function or a computation.

135
00:06:43,430 --> 00:06:44,795
So far, so good.

136
00:06:44,795 --> 00:06:49,210
The magic happens on line three when we find a one in the list.

137
00:06:49,210 --> 00:06:52,225
Instead of calling aux recursively or using newk,

138
00:06:52,225 --> 00:06:55,055
we call the top-level continuation k instead.

139
00:06:55,055 --> 00:06:58,240
This bypasses all the computations that were in newk,

140
00:06:58,240 --> 00:07:01,810
so no calls to GCD will happen at all in this scenario,

141
00:07:01,810 --> 00:07:05,600
and the auxiliary function will abort as soon as it finds a one in the list.

142
00:07:05,600 --> 00:07:10,375
We basically implemented exceptions using only pure functions.

143
00:07:10,375 --> 00:07:12,890
Now, in addition to stimulating exceptions,

144
00:07:12,890 --> 00:07:15,140
continuations can simulate multitasking.

145
00:07:15,140 --> 00:07:17,960
When they are used like that, they're called co-routintes.

146
00:07:17,960 --> 00:07:21,770
There are also more advanced versions of continuations called the limited continuations.

147
00:07:21,770 --> 00:07:23,725
They have names like shift and reset.

148
00:07:23,725 --> 00:07:26,220
Finally, some languages notably scheme,

149
00:07:26,220 --> 00:07:30,725
allow you to capture the continuation of a running program with a command called call/cc.

150
00:07:30,725 --> 00:07:34,610
I hope this gives you a good introduction to continuations, and in the next video,

151
00:07:34,610 --> 00:07:36,920
we'll show you how to transform a program written in

152
00:07:36,920 --> 00:07:40,420
direct style into continuation passing style.