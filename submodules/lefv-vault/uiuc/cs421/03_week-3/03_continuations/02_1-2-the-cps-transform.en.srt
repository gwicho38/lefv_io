1
00:00:02,120 --> 00:00:04,230
Hello everyone.

2
00:00:04,230 --> 00:00:06,450
Welcome to CS 421.

3
00:00:06,450 --> 00:00:09,300
In our last video, we saw some examples of

4
00:00:09,300 --> 00:00:11,985
writing functions in continuation passing style.

5
00:00:11,985 --> 00:00:14,520
Now, we're going to treat this a little more formally,

6
00:00:14,520 --> 00:00:16,740
give you an algorithm to convert a function from

7
00:00:16,740 --> 00:00:19,095
direct style to continuation passing style.

8
00:00:19,095 --> 00:00:20,700
Once you're done with this video,

9
00:00:20,700 --> 00:00:23,040
you will be able to use the formal definition of

10
00:00:23,040 --> 00:00:25,590
a CPS transform to do the transformations.

11
00:00:25,590 --> 00:00:27,180
But before we get started,

12
00:00:27,180 --> 00:00:28,890
there's something I'd like to let you know.

13
00:00:28,890 --> 00:00:31,755
There are many different kinds of CPS transforms.

14
00:00:31,755 --> 00:00:35,209
If you check elsewhere, you're likely to find many different versions.

15
00:00:35,209 --> 00:00:37,520
Some CPS transforms convert

16
00:00:37,520 --> 00:00:41,405
every sub-expression even those that don't actually need to be converted,

17
00:00:41,405 --> 00:00:43,440
and this makes result cluttered.

18
00:00:43,440 --> 00:00:46,520
The version we're going to go over distinguishes between terms

19
00:00:46,520 --> 00:00:49,520
that need to be rewritten into CPS and those that don't,

20
00:00:49,520 --> 00:00:52,070
and I find this tends to produce results that look like

21
00:00:52,070 --> 00:00:55,360
the kind you would have gotten if you wrote the function in CPS directly.

22
00:00:55,360 --> 00:00:57,575
Now, to represent the CPS transform,

23
00:00:57,575 --> 00:00:59,510
we'll use this capital letter C,

24
00:00:59,510 --> 00:01:03,035
and put in the term we're transforming in this semantic brackets.

25
00:01:03,035 --> 00:01:05,515
Now, there are four situations we have to consider.

26
00:01:05,515 --> 00:01:08,900
The first thing we need to do to convert a function is to create

27
00:01:08,900 --> 00:01:12,805
a new variable k and add it to the function's parameter list.

28
00:01:12,805 --> 00:01:16,940
You can actually name it anything you want as long as the variable name is fresh,

29
00:01:16,940 --> 00:01:19,355
that is not already used in the function.

30
00:01:19,355 --> 00:01:20,570
Once we've done that,

31
00:01:20,570 --> 00:01:22,280
we transform the body of the function.

32
00:01:22,280 --> 00:01:24,710
Notice that the k is a subscript now.

33
00:01:24,710 --> 00:01:28,760
This indicates to your transformer function what the current continuation is.

34
00:01:28,760 --> 00:01:32,890
The second situation is transforming simple expressions.

35
00:01:32,890 --> 00:01:34,610
The expression is simple if there are no

36
00:01:34,610 --> 00:01:38,015
function calls that could be activated in the code.

37
00:01:38,015 --> 00:01:40,820
Main way of function becomes unavailable

38
00:01:40,820 --> 00:01:44,670
is if it's inside of a lambda expression that does not get called.

39
00:01:44,670 --> 00:01:46,020
If there are no function calls,

40
00:01:46,020 --> 00:01:47,200
at least none that matter,

41
00:01:47,200 --> 00:01:51,395
we can simply pass the expression to the current continuation and then we're done.

42
00:01:51,395 --> 00:01:53,135
Now, here are a few examples.

43
00:01:53,135 --> 00:01:56,770
Notice how each of these function bodies just return a constant.

44
00:01:56,770 --> 00:01:59,355
In direct style, we would return these,

45
00:01:59,355 --> 00:02:02,630
but in CPS, we pass them to a current continuation.

46
00:02:02,630 --> 00:02:06,110
So, hit pause and try converting these into CPS.

47
00:02:06,110 --> 00:02:08,485
The answer is on the next slide.

48
00:02:08,485 --> 00:02:11,130
Okay. Here are the results.

49
00:02:11,130 --> 00:02:15,130
All we had to do is add a continuation argument to each function's parameter list,

50
00:02:15,130 --> 00:02:19,130
and then pass the body of each function into its continuation argument.

51
00:02:19,130 --> 00:02:21,470
There are two other cases to look at,

52
00:02:21,470 --> 00:02:23,070
both involve function calls.

53
00:02:23,070 --> 00:02:24,320
In the first case,

54
00:02:24,320 --> 00:02:27,440
we have a function applied to a simple argument arg.

55
00:02:27,440 --> 00:02:29,870
We assume that f is also written in CPS.

56
00:02:29,870 --> 00:02:31,865
This means that f can't return its value,

57
00:02:31,865 --> 00:02:34,940
but instead needs to be given a continuation argument.

58
00:02:34,940 --> 00:02:37,565
So, we give it the one we have written as k here.

59
00:02:37,565 --> 00:02:40,205
If f happened not to be in CPS,

60
00:02:40,205 --> 00:02:42,650
then we will treat the whole thing as a simple expression

61
00:02:42,650 --> 00:02:45,290
and use the previous role to translate it.

62
00:02:45,290 --> 00:02:47,300
I should mention here,

63
00:02:47,300 --> 00:02:50,480
this rule is written as if f has already been processed.

64
00:02:50,480 --> 00:02:52,640
If f is a lambda expression,

65
00:02:52,640 --> 00:02:54,890
the rule would need to be a bit more complex and

66
00:02:54,890 --> 00:02:57,215
we're not going to cover that case in this lecture.

67
00:02:57,215 --> 00:02:59,485
Now, the last case is the tricky one.

68
00:02:59,485 --> 00:03:04,865
In this case, the argument arg is itself going to be transformed in the CPS,

69
00:03:04,865 --> 00:03:07,985
and will therefore need its own continuation argument.

70
00:03:07,985 --> 00:03:11,630
We can't simply pass its value into the function f so we

71
00:03:11,630 --> 00:03:15,530
will have to build a continuation to capture the result of evaluating.

72
00:03:15,530 --> 00:03:17,870
That continuation can then pass the result into

73
00:03:17,870 --> 00:03:20,720
f. The new continuation starts with the lambda v,

74
00:03:20,720 --> 00:03:23,210
where v is a variable we have not used before.

75
00:03:23,210 --> 00:03:28,265
We feed v to f and then pass the current continuation k to f as well.

76
00:03:28,265 --> 00:03:30,830
Here's a function free to try converting.

77
00:03:30,830 --> 00:03:37,500
Hit pause and resume when you're ready to see the answer. Here's the result.

78
00:03:37,500 --> 00:03:41,500
You can see all four of the rules and play here in the second listing.

79
00:03:41,500 --> 00:03:46,880
The first rule says to add a continuation argument to each of the function declarations.

80
00:03:46,880 --> 00:03:50,500
The second rule is for simple expressions and we use that on line one.

81
00:03:50,500 --> 00:03:55,270
The third rule is for function calls with simple arguments which we used on line two.

82
00:03:55,270 --> 00:03:58,855
The last rule is for expressions for the arguments not simple,

83
00:03:58,855 --> 00:04:00,785
that needs its own continuation.

84
00:04:00,785 --> 00:04:02,310
You can see it on line three.

85
00:04:02,310 --> 00:04:03,780
Now, if you have an operator,

86
00:04:03,780 --> 00:04:05,265
there are three cases.

87
00:04:05,265 --> 00:04:09,235
It could be that both arguments to the operator are simple.

88
00:04:09,235 --> 00:04:11,620
In that case, the whole thing is simple,

89
00:04:11,620 --> 00:04:14,635
and we just pass it to the current continuation.

90
00:04:14,635 --> 00:04:16,930
If one of the arguments is not simple,

91
00:04:16,930 --> 00:04:19,910
we transform it and then pass in a continuation

92
00:04:19,910 --> 00:04:23,075
that captures its results and uses that to perform the operation.

93
00:04:23,075 --> 00:04:25,100
This rule shows e1 here,

94
00:04:25,100 --> 00:04:28,730
the e2 case is symmetrical so I'm not going to list it.

95
00:04:28,730 --> 00:04:31,450
Now, if both arguments need continuations,

96
00:04:31,450 --> 00:04:35,075
we first call the transformed e1 and capture its result in v1.

97
00:04:35,075 --> 00:04:37,325
Next, we call the transformed e2,

98
00:04:37,325 --> 00:04:39,385
capture its result in v2,

99
00:04:39,385 --> 00:04:42,020
and then finally, we can apply the operation that v1 and

100
00:04:42,020 --> 00:04:45,620
v2 and pass that result into the current continuation.

101
00:04:45,620 --> 00:04:48,260
Notice how this makes a nested continuation.

102
00:04:48,260 --> 00:04:51,560
So, here are some examples for you to try converting.

103
00:04:51,560 --> 00:04:53,810
Pause the video and try converting them and

104
00:04:53,810 --> 00:04:56,910
then resume when you're ready to see the answers.

105
00:04:57,030 --> 00:04:59,455
Okay. So, for foo,

106
00:04:59,455 --> 00:05:01,075
we had a simple expression.

107
00:05:01,075 --> 00:05:04,715
So, we just needed to pass it into the current continuation.

108
00:05:04,715 --> 00:05:08,695
For bar, the first argument needed to be converted.

109
00:05:08,695 --> 00:05:12,290
For baz, we needed to convert the second argument.

110
00:05:12,290 --> 00:05:16,150
Finally, for quux, we have to convert both of them.

111
00:05:16,150 --> 00:05:18,410
There is a lot of research papers written about

112
00:05:18,410 --> 00:05:21,215
continuations and continuation passing style.

113
00:05:21,215 --> 00:05:23,250
These are some of my favorite ones.

114
00:05:23,250 --> 00:05:25,729
The first two are a bit technical I think,

115
00:05:25,729 --> 00:05:27,890
but the last one gives a really nice overview of

116
00:05:27,890 --> 00:05:31,680
all the times that someone discovered this way of programming.