Hello everyone. Welcome to CS 421. In our last video, we saw some examples of writing functions in continuation passing style. Now, we're going to treat this a little more formally, give you an algorithm to convert a function from direct style to continuation passing style. Once you're done with this video, you will be able to use the formal definition of a CPS transform to do the transformations. But before we get started, there's something I'd like to let you know. There are many different kinds of CPS transforms. If you check elsewhere, you're likely to find many different versions. Some CPS transforms convert every sub-expression even those that don't actually need to be converted, and this makes result cluttered. The version we're going to go over distinguishes between terms that need to be rewritten into CPS and those that don't, and I find this tends to produce results that look like the kind you would have gotten if you wrote the function in CPS directly. Now, to represent the CPS transform, we'll use this capital letter C, and put in the term we're transforming in this semantic brackets. Now, there are four situations we have to consider. The first thing we need to do to convert a function is to create a new variable k and add it to the function's parameter list. You can actually name it anything you want as long as the variable name is fresh, that is not already used in the function. Once we've done that, we transform the body of the function. Notice that the k is a subscript now. This indicates to your transformer function what the current continuation is. The second situation is transforming simple expressions. The expression is simple if there are no function calls that could be activated in the code. Main way of function becomes unavailable is if it's inside of a lambda expression that does not get called. If there are no function calls, at least none that matter, we can simply pass the expression to the current continuation and then we're done. Now, here are a few examples. Notice how each of these function bodies just return a constant. In direct style, we would return these, but in CPS, we pass them to a current continuation. So, hit pause and try converting these into CPS. The answer is on the next slide. Okay. Here are the results. All we had to do is add a continuation argument to each function's parameter list, and then pass the body of each function into its continuation argument. There are two other cases to look at, both involve function calls. In the first case, we have a function applied to a simple argument arg. We assume that f is also written in CPS. This means that f can't return its value, but instead needs to be given a continuation argument. So, we give it the one we have written as k here. If f happened not to be in CPS, then we will treat the whole thing as a simple expression and use the previous role to translate it. I should mention here, this rule is written as if f has already been processed. If f is a lambda expression, the rule would need to be a bit more complex and we're not going to cover that case in this lecture. Now, the last case is the tricky one. In this case, the argument arg is itself going to be transformed in the CPS, and will therefore need its own continuation argument. We can't simply pass its value into the function f so we will have to build a continuation to capture the result of evaluating. That continuation can then pass the result into f. The new continuation starts with the lambda v, where v is a variable we have not used before. We feed v to f and then pass the current continuation k to f as well. Here's a function free to try converting. Hit pause and resume when you're ready to see the answer. Here's the result. You can see all four of the rules and play here in the second listing. The first rule says to add a continuation argument to each of the function declarations. The second rule is for simple expressions and we use that on line one. The third rule is for function calls with simple arguments which we used on line two. The last rule is for expressions for the arguments not simple, that needs its own continuation. You can see it on line three. Now, if you have an operator, there are three cases. It could be that both arguments to the operator are simple. In that case, the whole thing is simple, and we just pass it to the current continuation. If one of the arguments is not simple, we transform it and then pass in a continuation that captures its results and uses that to perform the operation. This rule shows e1 here, the e2 case is symmetrical so I'm not going to list it. Now, if both arguments need continuations, we first call the transformed e1 and capture its result in v1. Next, we call the transformed e2, capture its result in v2, and then finally, we can apply the operation that v1 and v2 and pass that result into the current continuation. Notice how this makes a nested continuation. So, here are some examples for you to try converting. Pause the video and try converting them and then resume when you're ready to see the answers. Okay. So, for foo, we had a simple expression. So, we just needed to pass it into the current continuation. For bar, the first argument needed to be converted. For baz, we needed to convert the second argument. Finally, for quux, we have to convert both of them. There is a lot of research papers written about continuations and continuation passing style. These are some of my favorite ones. The first two are a bit technical I think, but the last one gives a really nice overview of all the times that someone discovered this way of programming.