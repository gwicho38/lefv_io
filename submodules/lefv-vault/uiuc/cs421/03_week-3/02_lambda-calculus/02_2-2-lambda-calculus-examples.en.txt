Hello everyone. Welcome back. In our last video, we talked about the syntax of Lambda Calculus. We had variables, we had abstractions also known as functions, and we had function applications. I didn't actually show you much how to do a function application, and that's what this video is for. So, your objectives are to learn how to perform a beta-reduction. Beta-reduction is just a fancy way of saying function application. I've noticed that computer scientists like to use Greek letters a lot. My theory is that maybe it helps us to look smart or something like that. So, I encourage you to learn a bunch of Greek letters, it may turn out to be helpful. Anyway speaking of Greek letters, we also have Alpha-capture. This is something you need to know about, and what Alpha-capture means is that you have a variable that is free, and somehow it becomes bound to another Lambda inside the term, usually as a result of a beta-reduction moving it from one part of the term to another. So, I'll show you how that happens, and how to avoid it, and how to fix it. It's a bad thing because it actually changes the meaning of a program when it happens. Finally, we'll talk about normalization. What that means is we do all of the beta-reductions that are possible until a Lambda-calculus term is in its simplest form. So, I want to show you these six examples just to get us started then we're going to go through a more involved example, which you'll get to try. So, the first example is just the identity function applied to a. A way you do Beta-reduction is you take off the Lambda x part or the Lambda whatever variable part, and what you're left with is the body. So, you'll see in the bottom, you have an application node and a Lambda node. Both of those get replaced by the body of the function. In this case, it's just an x. Except that all the x's get replaced by whatever the argument was. In this case, it's an a. So, the next example. We have Lambda x, in the body is x applied to x and we're going to replace all those x's with a's because that's the argument. So the lambda x goes away, the application no goods away and it's replaced by the application of x to x but the x is now or substituted by a's. Here is something slightly similar except one of the x's has been changed into a y and so because y is not x, we don't substitute it. So we just have y applied to a. This next example is interesting. So think about the a, you see the a here that has a argument to this function. This a is a global a it's not bound to anything but you see also there's a lambda a inside of the lambda x then the body of the lambda x part. If we do the substitution we're going to get lambda a with a as the body and that means this a is no longer referring to this global entity it's referring to this local variable now. That actually changes the meaning of the program. So what we need to do is rename something. We can't rename the argument a because that's referring to a global thing so we have to rename the parameter and the lambda a part. So we changed that to lambda a prime and then we go ahead and do our beta reduction and so we have lambda a prime, arrow a and now that is a function which takes anything ignores it and then just returns the global a which is what we wanted in the first place. If we didn't do that then what we would have had was identity function instead. This one is a little interesting, we have this outer lambda x and an inner lambda x. And so what that means is that we really have two variables named x, and the rule is that when you have a variable you walk up the tree, you bind it to the first lambda that mentions it. So it's the inner lambda x that wins. So that means this outer lambda x is referring to a different variable than what that inner x is talking about. So when we do our beta reduction we actually end up not substituting anything we just copy the whole function body over. Finally, here's one that requires two beta reductions to reduce. We will do the topmost one first. So the whole lambda x applied to a, we substitute in the body so we have the application of lambda y to x and that x gets replaced by an a by the first beta reduction and that gives us a second beta reduction that we can do. So we do that, and that's just the identity applied to a so we get our a back. So again with alpha capture the thing to do when you see that that's about to happen is first you rename the lambda term that's going to do the capturing. You never rename the thing that you're passing in, that's getting captured. Okay, so here's one for you to try. What I'd like you to do is hit pause, and while this thing is paused, I want you to do the following things; I want you to write down the equivalent lambda calculus expression, I want you to identify any free variables that are in here and then I want you to simplify it by performing as many beta reductions or alpha renaming as necessary to get this into its simplest form. So when you're ready hit pause and hit unpause and I'll go over the solution. Okay, so here's the equivalent of Lambda calculus expression. There is one free variable, you notice a lambda qf part. That f, if you look at it you see there it's not inside of a lambda f thing at all. So that means it's free. So you can get this by looking at the term, you just see lambda qf, it's in parentheses, there's nothing enclosing that, that has a lambda f. There is another lambda f in this expression but it doesn't enclose it. So it doesn't count. If you're looking at the syntax tree, the easiest way is to start with the f and just walk up the tree, just the opposite direction of the arrows and you'll see you never encounter a lambda f. Okay, so to do this I am going to put numbers on all the application nodes so that you will know which one I'm talking about. The first beta reduction we're going to do is we're going to take the second of the app nodes, the second application node and do a beta reduction on that. Now we've already talked that f is free, and so if I do this substitution you see the lambda x in that body has an x in it. If I put that f inside where that x is then the lambda f just above the app three node is going to end up capturing that. So what we have to do is rename this lambda f into lambda f prime and the corresponding f that was in that term also gets renamed to enough prime. So now that we've done that, we're able to do our beta reduction. So it will end up looking like this. So you see that the lambda f prime gets moved up to where the app two used to be, and you see that the x has been replaced by the lambda q. Our next beta reduction we're going to do is going to be the top node, the app one. So we're going to take the f primes and replace them by this lambda a. So ends up looking like this. Next, we're going to take the lambda a and beta reduce it, we're going to replace the a's by lambda qf. So that gives us this one. Our final reduction is we're going to take the first lambda qf and replace all the q's with the second lambda qf, but there are no q's to replace so we end up just returning the body of the first thing to qf as is and that's the end of it. So hopefully these helped out. Again there's some more writing about lambda calculus on the course website and plenty of online resources. So please keep looking at this and playing with it until it makes more sense. The next video we're going to talk about how you decide what order to do things and how you decide when you've done enough. There's more than one answer to that question. So I'll talk about that.