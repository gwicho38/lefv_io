Hello everyone and welcome back. This video we're going to talk about
something called Church numerals. Now, these are not numerals
that are religious, they are a representation of
numbers in lambda calculus. And in fact, we can represent any type you can think of
in lambda calculus using this technique. So we'll talk about how to do some
operations on Church numerals, how to define increment, plus, and times, and
we'll also talk about boolean operations. And then I'm going to show you how
to extend this to other types. Just kind of extra, I'm not going to
make you do that in class, but I just want you to see
what the technique is. Let's start off thinking about numbers. Now, I want to make the distinction here,
kind of a Plato type of thing to do, a number is an idea. It's not something you can touch,
it's something we can think about. And a numeral is
a representation of a number. So you see on this slide here, there's
plenty of numerals, there's 1, 2, 3, 4, and 0. Those are numerals, those aren't numbers. They represent numbers, though. So in the same way, we can use lambda
calculus to represent numbers, and these are called Church numerals. So how are we going to do this? The way is we have to think
of a number as a potential. The idea is if we have the number n,
I mean someday we're going to do n things to some victim, or some object. So here's how we can represent it. So zero, is we take f,
which is our action, we take x, which is our target, and
then we don't perform the action at all. The numeral one,
we perform the action one time. The numeral two,
we perform the action twice. The numeral three,
we do it three times, so on and so on. So you've noticed here that I've written
this in Haskell not in actual lambda calculus, you can really implement
this and play with it and see it work. So to print these out, Haskell won't
let you print out a function directly, but we can write a function show, which
takes in one of these Church numerals, and then for the action we put in +1,
for the target we put in 0. So this way you see if you call
show on this Church numeral for 2, then we get the number 2 back. So how are we going to do incrementation? So think about what a Church numeral is,
we have one, what do we want to do with it? Well first we can take in our Church
numeral that we want to increment. So that'll be the lambda m. So just to let you know what I'm doing
is I'm writing this function piecemeal. So the part that's undefined is
what we're going to talk about, and we're just going to keep
adding this incrementally. So next what we want to do
is return a Church numeral. And a Church numeral is something
that takes an action on a target. And so finally, what is the body of this? Well, so we have our Church numeral m, and
we've asked for an action on a target. So what we want to do then is apply
m to the action and the target, and that's going to perform
f onto the target m times. And then we want to have one
further call to f on that result. So that'll be m plus 1 times. Addition is very similar. You take two numerals, m and n,
and then you take your action and your target, f and x. So we apply the m to f, and that will apply f,
m times to the result of applying m to f. So that's n times, f is applied to x,
and then m more times. So see if you can figure
out multiplication. Subtraction is a lot more tricky,
actually. It's very easy to add a function call
to a chain of function calls, but it's hard to pull one off. Now, for booleans, we have a little
bit different representation. What we're going to do is we are going
to represent booleans as a choice. You have two possibilities. True means you go one way. False means you go the other. So this is kind of you have
a response to some question. So true we're going to
represent by lambda ab arrow a. False is going to to be lambda ab arrow b. And for our show function,
for showing booleans, we're just going to apply f to
the Haskell values true and false. So what I want you to try now is see
if you can figure out what the Church representations for and and or are. Remember, you're going to have to take and
to Church booleans and then do something to combine them. So go ahead, hit pause,
see if you can figure it out or guess what they may look like, and
then continue to see their answers. There's a couple of ways you could do it. Here's one of them. So and, you take x and
y as our Church booleans, and then you take x and you apply y to it. So if x is true, it's going to pick y. And then if y is true, it'll be true,
otherwise it'll be false. If x is false, then we just pass
in false to the second parameter. And similarly for or, we take x and
y, and apply x to true and y. And if is really, really simple. You just take the condition that
then branch to the else branch, and you feed the then branch and
the else branch to the condition. Now, we can use this technique for
any data type you want. So the idea is that a data type has
a certain number of constructors, let's say it's n constructors. And then what will happen is the Church
representation will be a function that has n different parameters. Now, each parameter is supposed
to take a function that says, what should I do if I happen
to be this kind of thing? So let's show a concrete example. Here's The Maybe type. There's two constructors since that
means that Church Maybe would take two arguments, a j and a n. So j is the Just part, and the j function needs to take one argument
itself because it encodes something. So lambda jn.ja would be just a. And nothing doesn't take any arguments. So lambda jn.n represents nothing. So think how you'd represent
the lambda calculus for just three. So it looks like this. So you have lambda jn.j,
because it's a just, and the argument to the j is this
whole lambda x f3 time thing. Now, linked list is similar. We have two constructors,
so we need two arguments. We'll call one cons and one nil, but the cons now takes two
parameters instead of just one. So if I have cons xy,
we'll have lambda cn.c applied to x and y. Now think of how you represent cons true,
cons false nil. So it looks like this thing. A little crazy to look at. Now, you can write length, that would
take the length of one of these. I haven't shown you how to do
recursion in lambda calculus yet, that's the next video. But if you were to do it,
it might look something like this. So cons says what to do, so x, so
length of x, the first argument is, what to do if it's a cons. So here if it's a cons we're going to
pass in this function which takes two parameters. The first is going to be the data,
the second is going to be tally list, and I'm just going to
increment the length of y. And then the second argument, if it's
a nil, which is going to return zero. Now, don't worry if this seems to be
going over your head at the moment. Like I said at the beginning, I'm not
going to ask you this part on any exams. So I just want you to
see this is possible. If you play with this with pen and
paper or whatever, then you'll see how this works,
you'll be able to follow the logic. Now, going even farther we can actually
represent lambda-calculus in lambda calculus. So for
lambda-calculus we have arbitrary term M. There's three different constructions
in lambda calculus, but we only need to represent two of them. Variables, we can just
let them be themselves. And then what we're going to is
we're going to have lambda fa. So f is what to do for abstractions,
and a is what to do for applications. So f standing for function here. So you will see the f and the a on this
side of the these weird looking brackets. These are called symmetric brackets. Again, I don't necessarily expect you to
understand this or get this completely on your first go, but I just want you to see
that it is actually possible to do this. So for abstractions, we use the f term,
and then pass in the abstraction and convert what's inside of that for
applications, we use the A term. And then pass in two parameters for that. So you can even write an interpreter for
this if you wanted to, here it is. It's very straight forward. On our next video I'm going to show
you something called the y combinator, which is a way of
implementing recursion and it's a kind of famous result
in lambda of calculus.