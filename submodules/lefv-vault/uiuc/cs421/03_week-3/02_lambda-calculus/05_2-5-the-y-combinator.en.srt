1
00:00:02,240 --> 00:00:05,355
Hello everyone. Welcome back.

2
00:00:05,355 --> 00:00:10,105
In this video, we're going to talk about something called the Y Combinator which

3
00:00:10,105 --> 00:00:14,840
is way of implementing recursion in pure lambda calculus.

4
00:00:14,840 --> 00:00:18,910
So, our objective is of course to know what the Y Combinator is,

5
00:00:18,910 --> 00:00:23,620
and to see how it uses self-application to allow functions to call themselves.

6
00:00:23,620 --> 00:00:27,060
Now, to get started, let's suppose we want to implement this function,

7
00:00:27,060 --> 00:00:29,270
f of n is equal to f at n plus one.

8
00:00:29,270 --> 00:00:33,295
Now, leave aside for the moment the minor detail that this doesn't terminate.

9
00:00:33,295 --> 00:00:36,440
What we want to do is find a way in pure lambda calculus,

10
00:00:36,440 --> 00:00:42,480
so we can't use this equal thing to define something that behaves like f. To get started,

11
00:00:42,480 --> 00:00:44,135
we might do something like this,

12
00:00:44,135 --> 00:00:48,970
so the definition of f is lambda n.f applied to inc applied to n,

13
00:00:48,970 --> 00:00:53,410
but the problem is we need to find a way of letting f know what is on code is,

14
00:00:53,410 --> 00:00:55,230
how does that get to know itself?

15
00:00:55,230 --> 00:00:59,795
There's a old saying that if the only tool you have is a hammer,

16
00:00:59,795 --> 00:01:02,225
then every problem begins to look like a nail.

17
00:01:02,225 --> 00:01:05,660
There's a related saying actually that if the only tool you have is C++,

18
00:01:05,660 --> 00:01:07,565
and every problem begins to look like a thumb,

19
00:01:07,565 --> 00:01:08,980
but that's a different thing.

20
00:01:08,980 --> 00:01:11,660
In our case, the only tool we have is a function.

21
00:01:11,660 --> 00:01:14,660
So, we're going to have to use function calls to do this.

22
00:01:14,660 --> 00:01:16,270
So, here's what we're going to do,

23
00:01:16,270 --> 00:01:19,960
we're going to make f take as its first argument,

24
00:01:19,960 --> 00:01:22,165
its own name as a parameter.

25
00:01:22,165 --> 00:01:25,095
So, we're going to add this lambda f to the beginning,

26
00:01:25,095 --> 00:01:26,600
and then to make use of this,

27
00:01:26,600 --> 00:01:28,750
we're going to have two copies of f,

28
00:01:28,750 --> 00:01:32,000
and we're going to pass the first copy into the second copy.

29
00:01:32,000 --> 00:01:38,305
That way, the first copy has its source code that I can call recursively.

30
00:01:38,305 --> 00:01:41,930
We need to make one other little change here because since f

31
00:01:41,930 --> 00:01:45,460
now is going to have to take itself as its first parameter,

32
00:01:45,460 --> 00:01:47,610
we can't just leave f by itself.

33
00:01:47,610 --> 00:01:49,960
So, you see in this code, we have f applied to inc again,

34
00:01:49,960 --> 00:01:53,955
still we're going to change that to f applied to f applied to inc n. So,

35
00:01:53,955 --> 00:01:58,440
once we have this, now we have a properly recursive function that can call itself,

36
00:01:58,440 --> 00:02:01,240
and expand itself out as much as it needs to.

37
00:02:01,240 --> 00:02:05,630
It's ugly though because whenever we want to use recursion,

38
00:02:05,630 --> 00:02:07,735
we have to have two copies of this thing.

39
00:02:07,735 --> 00:02:09,390
How are we going to fix this?

40
00:02:09,390 --> 00:02:11,540
So, there's another way of doing this,

41
00:02:11,540 --> 00:02:14,650
we could have a function build the two copies for us.

42
00:02:14,650 --> 00:02:15,930
So, to see how that works,

43
00:02:15,930 --> 00:02:18,380
I want you to consider these Church numerals.

44
00:02:18,380 --> 00:02:20,870
So, let's say that f with a subscript is

45
00:02:20,870 --> 00:02:24,325
a Church numeral represented in that particular number.

46
00:02:24,325 --> 00:02:29,180
So, we have f5, we can unfold it once to get f applied to f4.

47
00:02:29,180 --> 00:02:32,610
We can fold that again to get f applied to f applied to f3,

48
00:02:32,610 --> 00:02:34,210
so on and so forth.

49
00:02:34,210 --> 00:02:38,795
So, what we really want is something that behaves a lot like an f of infinity.

50
00:02:38,795 --> 00:02:41,755
So, here's what f of infinity looks like.

51
00:02:41,755 --> 00:02:45,200
We have f infinity applied to f applied to x is equal to

52
00:02:45,200 --> 00:02:48,725
f applied to f infinity f applied to x.

53
00:02:48,725 --> 00:02:50,330
So, f then takes a string as

54
00:02:50,330 --> 00:02:54,305
its first argument and then expands it out again if necessary.

55
00:02:54,305 --> 00:02:56,855
This thing is called the Y Combinator,

56
00:02:56,855 --> 00:02:58,110
this f of infinity.

57
00:02:58,110 --> 00:03:03,290
A Combinator is simply a function that doesn't use anything outside of itself,

58
00:03:03,290 --> 00:03:09,340
it just uses the things that's passed in and combines them in order to get its result.

59
00:03:09,340 --> 00:03:11,320
So, here's the Y Combinator,

60
00:03:11,320 --> 00:03:13,030
the source code to it.

61
00:03:13,030 --> 00:03:15,260
It takes f as its argument,

62
00:03:15,260 --> 00:03:17,265
the thing that you want to make repeated,

63
00:03:17,265 --> 00:03:21,920
and then you have that 2.5 thing going on inside where y is taking

64
00:03:21,920 --> 00:03:26,880
its own name as its argument then playing f applied to yy.

65
00:03:26,880 --> 00:03:28,785
Now, if you look at this,

66
00:03:28,785 --> 00:03:32,500
if you expand out this YF down here,

67
00:03:32,500 --> 00:03:34,650
you see first that it takes f as its argument.

68
00:03:34,650 --> 00:03:38,090
So you have lambda y and then you have the two halves,

69
00:03:38,090 --> 00:03:39,920
you have the f of yy.

70
00:03:39,920 --> 00:03:43,670
The first half takes the second half so you get f applied to this thing.

71
00:03:43,670 --> 00:03:45,830
If you look at that thing that F is applied to,

72
00:03:45,830 --> 00:03:49,460
that's just the original source code that we hadn't aligned before,

73
00:03:49,460 --> 00:03:51,580
so, that's equal to f applied to YF,

74
00:03:51,580 --> 00:03:53,095
and this is what we wanted.

75
00:03:53,095 --> 00:03:56,780
Now, this function is very famous in the programming language community,

76
00:03:56,780 --> 00:03:58,610
there's actually a startup company called

77
00:03:58,610 --> 00:04:02,965
Y Combinator or they're a company that fund startup companies.

78
00:04:02,965 --> 00:04:07,570
I actually knew a professor who had this source code,

79
00:04:07,570 --> 00:04:10,965
this Y Combinator tattooed on his arm.

80
00:04:10,965 --> 00:04:12,565
He's a better geek than I am,

81
00:04:12,565 --> 00:04:14,180
I'm ashamed to admit.

82
00:04:14,180 --> 00:04:17,600
So let's see an example of what this might look like.

83
00:04:17,600 --> 00:04:20,385
If we want this factorial function,

84
00:04:20,385 --> 00:04:23,060
that's in Haskell, we could rewrite it in lambda calculus,

85
00:04:23,060 --> 00:04:24,745
it might look like this.

86
00:04:24,745 --> 00:04:27,350
So, we'd have lambda f for factorial,

87
00:04:27,350 --> 00:04:33,545
and then what we would do is we just feed this factorial function to the Y Combinator.

88
00:04:33,545 --> 00:04:37,550
This way the factorial whenever it calls itself recursively can

89
00:04:37,550 --> 00:04:41,575
just re-expand one more level out. So, that's it.

90
00:04:41,575 --> 00:04:45,140
You have seen now that with lambda calculus,

91
00:04:45,140 --> 00:04:47,630
we can implement integers using Church numerals,

92
00:04:47,630 --> 00:04:51,520
we can implement Booleans using a similar technique,

93
00:04:51,520 --> 00:04:54,345
and even implement other data structures.

94
00:04:54,345 --> 00:04:58,120
We've seen that you can use this Y combinator to implement recursion,

95
00:04:58,120 --> 00:05:00,670
and hopefully all of this is enough to convince you that,

96
00:05:00,670 --> 00:05:03,529
yes, in fact, this is a train complete language.

97
00:05:03,529 --> 00:05:07,370
Here's a interesting paper you might want to read if this is

98
00:05:07,370 --> 00:05:11,280
interesting to you about using lambda calculus to represent itself,

99
00:05:11,280 --> 00:05:13,960
Efficient Self-Interpretation in Lambda Calculus

100
00:05:13,960 --> 00:05:15,970
in the Journal of Functional Programming.

101
00:05:15,970 --> 00:05:21,540
This author has written several other papers that are similar to that.