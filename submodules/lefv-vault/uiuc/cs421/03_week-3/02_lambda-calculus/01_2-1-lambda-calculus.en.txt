Hello everyone. Welcome to CS 421, and this series of lectures we're going to talk about a theoretical language called lambda calculus. So, in this first video, we're just going to introduce the constructs. There are only three constructs. It's a very simple language, and we'll talk about how to build syntax tree diagrams for them. We'll look at what different constructs look like. We'll also talk about something called beta-reduction, which is this fancy way of saying function application. Now, lambda calculus is important. It was designed to study how function application works and what functions can do, and in our context, it's important because it's used extensively in programming language search. You'll notice that functional languages like Haskell are actually built around lambda calculus. I'll show you that in a minute. Now, there's three things in lambda calculus: first is variables. We are typically going to assume that they are one-letter long, and the reason for that is that when we write down lambda calculus terms, we tend not to use spaces at all, and the only way that that makes any sense is if all variable names are exactly one letter. So, sometimes we'll use decorations like subscripts or prime marks. Function application, like in Haskell, is done by juxtaposing. So, the first example is f applied to y. The second example is a applied to b, and then that whole thing applied to c. So, you can think of that two ways. You can think of it as a being applied to two parameters, b and c, or you can think of it as a being applied to b first and then that whole thing being applied to c,and this is the same as it is in Haskell. The third example. We have x applied to two things: the first is f applied to y, the second is f applied to g. So, you'll notice that we use parentheses if we want to change the default groupings. You can't have function application unless you have a way of making functions. So, here's how to do that. You write down the character lambda, then you write down whatever parameters you want, and then a dot and then the body of the function. Now, the body of the function extends as far as syntactically possible. So, if you want to limit the scope of a function, then you have to use parentheses. So, the first one, we have a function of one variable x and just returning x. The second, we have a function ab. A function that takes two parameters ab and then applies this parameters to f. The third one, we have a function that takes two parameters x and y and then the body of it takes g and applies three things to it: the first one is itself a function and then y and x. So, the reason why lambda calculus is used so extensively in research is that if you want to be a programming language theorists, one of the things that you will tend to do is you'll come up with a new language construct, then you want to write proofs about what it does or explain what it does. These proofs will tend to be structured over the terms that you have in your language. So, if you have a large language, like C++, which has, I don't know, how many different kinds of language constructs it has, but each one of those need to be mentioned in your proof. In a language like lambda calculus, we only have three things, and then maybe have your language constructs and maybe you have a couple of things more. So, the proofs tend to be shorter. The other thing that's kind of interesting about lambda calculus is that it does become the foundation for the functional programming languages. So, in Haskell, you see this backslash. You've heard me call it lambda before and now you know why. So, lambda calculus, lambda x.x, in Haskell, we can put backslash x arrow x and it's the same thing. So, in a sense, you've already seen them to calculus. We just weren't calling it that. Now, here's a few examples to look at. The first two are rather famous. The first one's called the identity function. The second one is called delta, which is used in some proofs. If you've ever seen a proof of the halting problem, you know that taking a function and applying it to itself is one of the steps. Examples three and four, the first example is a function that takes two parameters a and b and just applies a bunch of things to f for different things, but example four the letters are the same, but I've used parentheses; and so now the function, lambda ab, only extends as far as fab, and then after that the x and y are applied to that whole thing and not to f anymore. Fifth example, it's the same as a fourth, only I've expanded out the lambdas instead of keeping it together, but those are actually the same term. So, one thing that's important to be able to do is build syntax trees. So, here's some examples of lambda calculus terms and their corresponding trees. So, the first one is just the identity again. So, you see that there's a lambda x on top, and then we have an arrow that goes to the body of the function x. We use the at symbol to represent function application. So, the thing on the left is a function. That thing on the right is the application. If we have a function with multiple things being applied, each of those is its own function applications. Seen in example three, the function is lambda y dot y and then it's applied to x, and then that whole thing is applied to z, and then the fourth example is something a little bit larger. So, if you want, hit pause and look at the parts and see how they line up with the tree. Now, one important concept that happens whenever you write down lambdas and then a term, so like lambda z here, then any occurrence of z that appears underneath that lambda in the body of the function is considered bound to that lambda. So, there's a little bit of a disclaimer which we'll talk about later, but for now let's just call it that. So, in the first example, you see a z at the bottom and that's bound to the lambda z at the very top. You see the x here, which is bound to the lambda x and you see a y. So, all of these different variables that are inside are bound to the various lambdas that occur. Now, it can happen, that you can write down a variable and that variable is not bound to anything. So, in the second example, you see this z here, and if you go up you look that it's inside of a lambda y function and that itself inside of a lambda x function. So, this z is not bound to anything. That's called a free variable. You can think of it as kind of a global variable in a normal language. It's just sort of out there, and the program that you're writing doesn't have anything to say about that. Sometimes in some systems, people will forbid you from using these, but knowing whether or not a variable is free inside of a certain function is going to turn out to be important. So, that was a quick introduction to the three different kinds of terms that you'll see in lambda calculus. And the next video, we will go for a bunch of examples of function applications actually being done and some of the complications that result.