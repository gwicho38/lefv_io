Hello everyone, and welcome back. In the last video, you saw how to implement a parser using recursive functions as long as a grammar was that the right kind, and you saw the two kinds of problems that can derail that parser, left recursion and common prefixes. Now the good news is that we can usually fix those. So, your objectives. By the time you're done with this lesson, you'll be able to eliminate left recursion from the grammar, you'll be able to eliminate common prefixes from a grammar, and as a bonus is a third problem that we haven't mentioned yet, you'll be able to eliminate conflicts that can arise due to epsilon productions. So let's start with left recursion. Consider these productions E goes to E plus and E goes to i. It's electric recursive, so it's not LL. But if you consider what this grammar is actually saying, you'll see that this is not the only grammar that can accomplish this. This grammar produces sentences where an i comes first and it's followed by zero or more pluses. So, pause and see if you can come up with an equivalent grammar that is not left recursive resume when you're ready. Now, before we show you the answer, here's a slightly more complicated grammar. This grammar says that B starts with the q or an r and ends with combinations of x y and z. So again, see if you can write an equivalent grammar that is not left recursive and resume when you're ready. Okay. So, here's the solution. We want to make it so that the production first emits the symbol at the start of the sentence, and then after that uses the recursion to emit the things that come after. We do this by introducing a new non terminal, a primed version of the original. So, if we have a production S goes to Beta, where Beta is the symbol that comes at the beginning of the sentence, then replace that with S goes to Beta S prime. Next, we replace the recursive rule S goes to S Alpha with S prime goes to Alpha S prime. Now, both the original and the replacement do the same thing make lots of copies of Alpha. Now, there's one thing we have to do next though. We have to provide a base case for the S prime version. So, we do that by adding a rule S prime goes to epsilon. Now, take a look at these grammars and verify for yourself that they do the same thing the originals did. There's something you should know about if he end up converting a lot of left recursive grammars to make them although. It's possible for there to be mutual left recursions, and here's an unreasonably complicated example to illustrate the technique. Basically, the combination of eliminating direct left recursion is normal, and also in lining certain symbols to make mutual recursion not possible anymore. So, let's look at this one. The first thing we have to do is eliminate left recursion on A as normal. You'll end up with the result at the bottom. Now, for the B rule, there are two ways it could cause left recursion. It could be left recursive directly but it could also be recursive by making a left call into a symbol we previously used. In this grammar, we have a direct left recursion via the B goes to By rule. But we could also get recursion by using the B goes to Ax rule. Then from A using the A goes to BbA prime rule. If you think of the dependency graph that results from using recursive descent parsing on this grammar, the B goes to Ax rule would represent the back edge, and its back edges that can cause mutual recursion. We can eliminate the back edges by in lining the A definitions into the B goes to Ax rule. So, this makes one rule into three, but it parses the same sentence. Once we've eliminated the back cause, we eliminate the regular left recursion. This makes the B look like the two productions on the bottom. Finally, let's consider the C rules. We have to inline both the A and the B left calls here. Once we've done that, we eliminate left recursion on C. Here's the result of eliminating left recursion. Don't worry about following this too closely at this point. It would be just busy work to do all this out by hand. But the point is just to know that this thing is possible. Here's the final result. It's not quite allow yet, but at least there's no left recursions. We need to note that this trick doesn't always work. There's a cycle from A to A. For instance, or if they're epsilon productions and this could still fail. So, now let's talk about common prefix elimination. Here's a grammar that suffers from this problem. We take the FIRST sets of all the A productions. You'll see that x occurs in two of them. This is a common prefix problem. We don't care if the FIRST sets overlap an unrelated non-terminals. So, for example, if there's a production B goes to x, that would not be a common prefix with the A goes to xyB. Now, the first two productions B goes to zC and B goes to zx are examples though. Now, to fix this, we'll use a technique called left factoring. To use left factoring, you take the productions that overlap and create a new production that encompasses both of them. So, if we had A goes to Alpha Beta one, and A goes to Alpha Beta two, we will write them as A goes to alpha A prime, and then A prime can go to Beta one and Beta two. You do have to be sure that Beta one and Beta two don't also have overlapping prefixes, but otherwise, it's a simple transformation. Both eliminating left recursion and eliminating common prefixes are simple to implement once you understand them, but they do have one huge downside. They can completely mess up the grammar. If an A note or a B note is supposed to mean something, then you may have to do some post-processing to restore those original meanings. Finally, there is one other thing that can break an LL production. We didn't cover it in the first video. But, if you have a rule that has epsilon productions, then what that function would do is return all the input in an empty tree, but only if the next input token belongs to the FOLLOW set of the symbol being parsed. This is because of how LL parsers work. They must look at the next token to decide what to do next, and if the production is an epsilon production, then we have to look for something in the FOLLOW set rather than a FIRST set. This can cause a problem similar to the common prefix one if there's an overlap with the FOLLOW set from an epsilon production, and the FIRST set from one of the other productions. The solution is to substitute one of the definitions like we had to do to eliminate mutual recursion, and there you have it. If you have a simple grammar and not a lot of time, you can use recursive descent to write a parser quickly. If the grammar is not LL, you may be able to use these techniques to repair a grammar and use recursive descent anyway. Sometimes though, you're going to have a grammar that's much more complex. In that case, you'll need a different parsing technique, and we'll show you some techniques in the following lessons.