1
00:00:00,000 --> 00:00:02,370
Hello everyone, and welcome back.

2
00:00:02,370 --> 00:00:04,365
In the last video,

3
00:00:04,365 --> 00:00:06,360
you saw how to implement a parser using

4
00:00:06,360 --> 00:00:10,020
recursive functions as long as a grammar was that the right kind,

5
00:00:10,020 --> 00:00:13,110
and you saw the two kinds of problems that can derail that parser,

6
00:00:13,110 --> 00:00:15,210
left recursion and common prefixes.

7
00:00:15,210 --> 00:00:19,125
Now the good news is that we can usually fix those.

8
00:00:19,125 --> 00:00:21,195
So, your objectives.

9
00:00:21,195 --> 00:00:22,650
By the time you're done with this lesson,

10
00:00:22,650 --> 00:00:25,425
you'll be able to eliminate left recursion from the grammar,

11
00:00:25,425 --> 00:00:28,190
you'll be able to eliminate common prefixes from a grammar,

12
00:00:28,190 --> 00:00:32,250
and as a bonus is a third problem that we haven't mentioned yet,

13
00:00:32,250 --> 00:00:36,420
you'll be able to eliminate conflicts that can arise due to epsilon productions.

14
00:00:36,420 --> 00:00:39,295
So let's start with left recursion.

15
00:00:39,295 --> 00:00:43,460
Consider these productions E goes to E plus and E goes to i.

16
00:00:43,460 --> 00:00:46,235
It's electric recursive, so it's not LL.

17
00:00:46,235 --> 00:00:49,280
But if you consider what this grammar is actually saying,

18
00:00:49,280 --> 00:00:53,890
you'll see that this is not the only grammar that can accomplish this.

19
00:00:53,890 --> 00:00:57,080
This grammar produces sentences where an i comes

20
00:00:57,080 --> 00:01:00,155
first and it's followed by zero or more pluses.

21
00:01:00,155 --> 00:01:03,170
So, pause and see if you can come up with an equivalent grammar

22
00:01:03,170 --> 00:01:07,230
that is not left recursive resume when you're ready.

23
00:01:08,090 --> 00:01:10,330
Now, before we show you the answer,

24
00:01:10,330 --> 00:01:12,510
here's a slightly more complicated grammar.

25
00:01:12,510 --> 00:01:15,530
This grammar says that B starts with the q or

26
00:01:15,530 --> 00:01:19,225
an r and ends with combinations of x y and z.

27
00:01:19,225 --> 00:01:21,770
So again, see if you can write an equivalent grammar

28
00:01:21,770 --> 00:01:25,380
that is not left recursive and resume when you're ready.

29
00:01:26,770 --> 00:01:29,845
Okay. So, here's the solution.

30
00:01:29,845 --> 00:01:32,480
We want to make it so that the production first

31
00:01:32,480 --> 00:01:35,075
emits the symbol at the start of the sentence,

32
00:01:35,075 --> 00:01:39,140
and then after that uses the recursion to emit the things that come after.

33
00:01:39,140 --> 00:01:41,825
We do this by introducing a new non terminal,

34
00:01:41,825 --> 00:01:43,885
a primed version of the original.

35
00:01:43,885 --> 00:01:46,955
So, if we have a production S goes to Beta,

36
00:01:46,955 --> 00:01:50,555
where Beta is the symbol that comes at the beginning of the sentence,

37
00:01:50,555 --> 00:01:54,220
then replace that with S goes to Beta S prime.

38
00:01:54,220 --> 00:02:00,950
Next, we replace the recursive rule S goes to S Alpha with S prime goes to Alpha S prime.

39
00:02:00,950 --> 00:02:02,720
Now, both the original and the replacement do

40
00:02:02,720 --> 00:02:05,465
the same thing make lots of copies of Alpha.

41
00:02:05,465 --> 00:02:07,780
Now, there's one thing we have to do next though.

42
00:02:07,780 --> 00:02:10,970
We have to provide a base case for the S prime version.

43
00:02:10,970 --> 00:02:14,720
So, we do that by adding a rule S prime goes to epsilon.

44
00:02:14,720 --> 00:02:17,060
Now, take a look at these grammars and verify for

45
00:02:17,060 --> 00:02:19,775
yourself that they do the same thing the originals did.

46
00:02:19,775 --> 00:02:22,040
There's something you should know about if he end up converting

47
00:02:22,040 --> 00:02:24,485
a lot of left recursive grammars to make them although.

48
00:02:24,485 --> 00:02:27,830
It's possible for there to be mutual left recursions,

49
00:02:27,830 --> 00:02:31,870
and here's an unreasonably complicated example to illustrate the technique.

50
00:02:31,870 --> 00:02:36,305
Basically, the combination of eliminating direct left recursion is normal,

51
00:02:36,305 --> 00:02:40,805
and also in lining certain symbols to make mutual recursion not possible anymore.

52
00:02:40,805 --> 00:02:42,440
So, let's look at this one.

53
00:02:42,440 --> 00:02:46,795
The first thing we have to do is eliminate left recursion on A as normal.

54
00:02:46,795 --> 00:02:49,790
You'll end up with the result at the bottom.

55
00:02:49,790 --> 00:02:51,080
Now, for the B rule,

56
00:02:51,080 --> 00:02:53,915
there are two ways it could cause left recursion.

57
00:02:53,915 --> 00:02:57,260
It could be left recursive directly but it could also be

58
00:02:57,260 --> 00:03:01,660
recursive by making a left call into a symbol we previously used.

59
00:03:01,660 --> 00:03:06,150
In this grammar, we have a direct left recursion via the B goes to By rule.

60
00:03:06,150 --> 00:03:10,245
But we could also get recursion by using the B goes to Ax rule.

61
00:03:10,245 --> 00:03:14,745
Then from A using the A goes to BbA prime rule.

62
00:03:14,745 --> 00:03:17,540
If you think of the dependency graph that results from

63
00:03:17,540 --> 00:03:20,180
using recursive descent parsing on this grammar,

64
00:03:20,180 --> 00:03:23,345
the B goes to Ax rule would represent the back edge,

65
00:03:23,345 --> 00:03:26,500
and its back edges that can cause mutual recursion.

66
00:03:26,500 --> 00:03:29,000
We can eliminate the back edges by in lining

67
00:03:29,000 --> 00:03:32,525
the A definitions into the B goes to Ax rule.

68
00:03:32,525 --> 00:03:34,850
So, this makes one rule into three,

69
00:03:34,850 --> 00:03:37,009
but it parses the same sentence.

70
00:03:37,009 --> 00:03:39,825
Once we've eliminated the back cause,

71
00:03:39,825 --> 00:03:42,410
we eliminate the regular left recursion.

72
00:03:42,410 --> 00:03:46,210
This makes the B look like the two productions on the bottom.

73
00:03:46,210 --> 00:03:48,585
Finally, let's consider the C rules.

74
00:03:48,585 --> 00:03:52,065
We have to inline both the A and the B left calls here.

75
00:03:52,065 --> 00:03:54,770
Once we've done that, we eliminate left recursion on

76
00:03:54,770 --> 00:03:58,520
C. Here's the result of eliminating left recursion.

77
00:03:58,520 --> 00:04:01,160
Don't worry about following this too closely at this point.

78
00:04:01,160 --> 00:04:04,295
It would be just busy work to do all this out by hand.

79
00:04:04,295 --> 00:04:07,969
But the point is just to know that this thing is possible.

80
00:04:07,969 --> 00:04:10,135
Here's the final result.

81
00:04:10,135 --> 00:04:12,135
It's not quite allow yet,

82
00:04:12,135 --> 00:04:14,265
but at least there's no left recursions.

83
00:04:14,265 --> 00:04:17,030
We need to note that this trick doesn't always work.

84
00:04:17,030 --> 00:04:18,680
There's a cycle from A to A.

85
00:04:18,680 --> 00:04:23,095
For instance, or if they're epsilon productions and this could still fail.

86
00:04:23,095 --> 00:04:26,840
So, now let's talk about common prefix elimination.

87
00:04:26,840 --> 00:04:29,420
Here's a grammar that suffers from this problem.

88
00:04:29,420 --> 00:04:32,165
We take the FIRST sets of all the A productions.

89
00:04:32,165 --> 00:04:35,005
You'll see that x occurs in two of them.

90
00:04:35,005 --> 00:04:36,900
This is a common prefix problem.

91
00:04:36,900 --> 00:04:40,300
We don't care if the FIRST sets overlap an unrelated non-terminals.

92
00:04:40,300 --> 00:04:43,730
So, for example, if there's a production B goes to x,

93
00:04:43,730 --> 00:04:48,325
that would not be a common prefix with the A goes to xyB.

94
00:04:48,325 --> 00:04:55,490
Now, the first two productions B goes to zC and B goes to zx are examples though.

95
00:04:55,490 --> 00:04:59,454
Now, to fix this, we'll use a technique called left factoring.

96
00:04:59,454 --> 00:05:01,040
To use left factoring,

97
00:05:01,040 --> 00:05:03,290
you take the productions that overlap and create

98
00:05:03,290 --> 00:05:05,975
a new production that encompasses both of them.

99
00:05:05,975 --> 00:05:08,735
So, if we had A goes to Alpha Beta one,

100
00:05:08,735 --> 00:05:10,640
and A goes to Alpha Beta two,

101
00:05:10,640 --> 00:05:13,629
we will write them as A goes to alpha A prime,

102
00:05:13,629 --> 00:05:16,425
and then A prime can go to Beta one and Beta two.

103
00:05:16,425 --> 00:05:21,525
You do have to be sure that Beta one and Beta two don't also have overlapping prefixes,

104
00:05:21,525 --> 00:05:24,365
but otherwise, it's a simple transformation.

105
00:05:24,365 --> 00:05:26,570
Both eliminating left recursion and eliminating

106
00:05:26,570 --> 00:05:29,590
common prefixes are simple to implement once you understand them,

107
00:05:29,590 --> 00:05:31,880
but they do have one huge downside.

108
00:05:31,880 --> 00:05:34,310
They can completely mess up the grammar.

109
00:05:34,310 --> 00:05:37,560
If an A note or a B note is supposed to mean something,

110
00:05:37,560 --> 00:05:41,889
then you may have to do some post-processing to restore those original meanings.

111
00:05:41,889 --> 00:05:45,755
Finally, there is one other thing that can break an LL production.

112
00:05:45,755 --> 00:05:47,510
We didn't cover it in the first video.

113
00:05:47,510 --> 00:05:51,155
But, if you have a rule that has epsilon productions,

114
00:05:51,155 --> 00:05:55,250
then what that function would do is return all the input in an empty tree,

115
00:05:55,250 --> 00:06:00,925
but only if the next input token belongs to the FOLLOW set of the symbol being parsed.

116
00:06:00,925 --> 00:06:03,330
This is because of how LL parsers work.

117
00:06:03,330 --> 00:06:06,425
They must look at the next token to decide what to do next,

118
00:06:06,425 --> 00:06:09,440
and if the production is an epsilon production,

119
00:06:09,440 --> 00:06:12,880
then we have to look for something in the FOLLOW set rather than a FIRST set.

120
00:06:12,880 --> 00:06:16,430
This can cause a problem similar to the common prefix one if there's

121
00:06:16,430 --> 00:06:19,850
an overlap with the FOLLOW set from an epsilon production,

122
00:06:19,850 --> 00:06:22,790
and the FIRST set from one of the other productions.

123
00:06:22,790 --> 00:06:26,390
The solution is to substitute one of the definitions like we had to

124
00:06:26,390 --> 00:06:30,860
do to eliminate mutual recursion, and there you have it.

125
00:06:30,860 --> 00:06:33,460
If you have a simple grammar and not a lot of time,

126
00:06:33,460 --> 00:06:36,550
you can use recursive descent to write a parser quickly.

127
00:06:36,550 --> 00:06:38,055
If the grammar is not LL,

128
00:06:38,055 --> 00:06:39,830
you may be able to use these techniques to

129
00:06:39,830 --> 00:06:42,590
repair a grammar and use recursive descent anyway.

130
00:06:42,590 --> 00:06:46,130
Sometimes though, you're going to have a grammar that's much more complex.

131
00:06:46,130 --> 00:06:48,670
In that case, you'll need a different parsing technique,

132
00:06:48,670 --> 00:06:52,230
and we'll show you some techniques in the following lessons.