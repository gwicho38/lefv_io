1
00:00:00,330 --> 00:00:02,387
Hello, everyone and welcome to CS 421.

2
00:00:02,387 --> 00:00:05,560
Today, we're going to
talk about LR parsing.

3
00:00:05,560 --> 00:00:09,599
If you're going to do any
parsing in the real world,

4
00:00:09,599 --> 00:00:13,648
you most likely are going to
come across LR parsers.

5
00:00:13,648 --> 00:00:17,332
In this video, we're going to discuss the
basics of LR parsers and how they work.

6
00:00:17,332 --> 00:00:20,400
So you could use one of the many
tools that support them.

7
00:00:20,400 --> 00:00:24,270
When you're done with this video, you will
be able to describe how LL and LR parsers

8
00:00:24,270 --> 00:00:29,120
differ and you will be able to produce
a finite state machine from an LR grammar.

9
00:00:29,120 --> 00:00:31,960
In a future video, you will also be
able to use the state machine to

10
00:00:31,960 --> 00:00:34,370
detect if the grammar is ambiguous.

11
00:00:34,370 --> 00:00:36,145
So what is LR parsing?

12
00:00:36,145 --> 00:00:39,721
An LR parser is a parser that does
a left-to-right scan of its input, but

13
00:00:39,721 --> 00:00:42,330
produces something called
a rightmost derivation.

14
00:00:42,330 --> 00:00:44,395
It's also called bottom up parsing.

15
00:00:44,395 --> 00:00:48,191
Instead of starting with a start symbol
and building the tree from the root to

16
00:00:48,191 --> 00:00:52,164
the leaves, it starts by collecting
leaves, building branches of the tree and

17
00:00:52,164 --> 00:00:55,097
then combining the branches
to create the final results.

18
00:00:55,097 --> 00:00:58,572
An LR parser uses a push down
automata to do its work.

19
00:00:58,572 --> 00:01:02,571
Now hopefully, you remember from your
previous course work that a push down

20
00:01:02,571 --> 00:01:05,256
automata is a state machine
that also has a stack and

21
00:01:05,256 --> 00:01:09,524
this allows a machine to remember the path
it took and return to a previous state.

22
00:01:09,524 --> 00:01:11,520
There are four operations.

23
00:01:11,520 --> 00:01:14,670
Shift consumes input from a token stream.

24
00:01:14,670 --> 00:01:17,717
Reduce builds a tree out
of collected components.

25
00:01:17,717 --> 00:01:23,200
Goto jumps to another state after a reduce
and accept signals that we're done.

26
00:01:23,200 --> 00:01:25,855
Let's look at a simple grammar
to introduce shifting.

27
00:01:25,855 --> 00:01:28,540
We'll use a grammar with one operation,
S goes to ab.

28
00:01:28,540 --> 00:01:32,229
There are three states that
can exist during the parse.

29
00:01:32,229 --> 00:01:36,522
In the initial state called i0 here, our
machine knows that it is collecting input

30
00:01:36,522 --> 00:01:40,370
for S goes to ab and
that we've not consumed any input yet.

31
00:01:40,370 --> 00:01:45,022
To indicate where we are during the parse,
we use a filled in circle as a cursor.

32
00:01:45,022 --> 00:01:50,056
Notice that the cursors in front of
the ab in the input and also in state i0.

33
00:01:50,056 --> 00:01:53,925
When we shift, we consume the input
in transition to state one.

34
00:01:53,925 --> 00:01:58,546
We push zero and a onto the stack to
remember that we came from state zero.

35
00:01:58,546 --> 00:02:01,180
And now, we consumed a when we left it.

36
00:02:01,180 --> 00:02:05,891
The cursor is now between the a and the b
indicating that we can expect the b next.

37
00:02:05,891 --> 00:02:08,490
Next, we consume a b and go to state two.

38
00:02:08,490 --> 00:02:12,750
The stack at 0, a, 1, b for
the two states into inputs.

39
00:02:12,750 --> 00:02:16,054
The next sample is dollar sign,
which represents c into the input.

40
00:02:16,054 --> 00:02:19,278
And now, we are ready to build
an else tree out of a and the b and

41
00:02:19,278 --> 00:02:21,640
this is called reducing.

42
00:02:21,640 --> 00:02:26,340
The next state machine state I2 has
an indication at the bottom that a dollar

43
00:02:26,340 --> 00:02:29,010
sign means we can reduce
according to rule one.

44
00:02:29,010 --> 00:02:30,932
That's what the r1 means here.

45
00:02:30,932 --> 00:02:32,440
We only have one rule.

46
00:02:32,440 --> 00:02:33,410
S goes to ab.

47
00:02:34,910 --> 00:02:37,100
So here's what happens in a reduce.

48
00:02:37,100 --> 00:02:40,620
We look at how many symbols are on the
right-hand side of the production we're

49
00:02:40,620 --> 00:02:44,940
reducing and we pop that many symbols,
and states from our stack, and

50
00:02:44,940 --> 00:02:47,580
that returns us to our previous state.

51
00:02:47,580 --> 00:02:52,360
In this case, we pop off two symbols, the
a and the b and we use them to build an S.

52
00:02:52,360 --> 00:02:56,670
We also return two states back,
putting us into state zero again.

53
00:02:56,670 --> 00:02:59,740
The next thing that would happen
is a Go To or an Accept action,

54
00:02:59,740 --> 00:03:01,560
but we've not put them here yet.

55
00:03:02,660 --> 00:03:06,338
Here's a more complicated example that
will show what happens after reduce is

56
00:03:06,338 --> 00:03:06,903
finished.

57
00:03:06,903 --> 00:03:10,900
We'll start in state zero and
we're looking at the a on the input.

58
00:03:10,900 --> 00:03:13,395
Consuming the a, we push a and
zero onto the stack.

59
00:03:13,395 --> 00:03:16,220
And now we are in state one,
looking at an x.

60
00:03:16,220 --> 00:03:19,580
State one tells us that two
things could be happening here.

61
00:03:19,580 --> 00:03:24,050
The top line says that we could have
just finished building an E subtree and

62
00:03:24,050 --> 00:03:27,430
the second line says that we
could see an x on the input, and

63
00:03:27,430 --> 00:03:30,350
use that to start building an E subtree.

64
00:03:30,350 --> 00:03:33,840
Since an x is next on the input,
we're going to take the bottom route and

65
00:03:33,840 --> 00:03:34,820
move to state three.

66
00:03:35,840 --> 00:03:39,895
In state three, we're at the end
of a production and state says,

67
00:03:39,895 --> 00:03:42,793
we can reduce now since
a b is next on the input.

68
00:03:42,793 --> 00:03:46,833
I'll explain later, but be thinking
about why there's a b to indicate we

69
00:03:46,833 --> 00:03:49,880
can reduce the E and
not some other symbol.

70
00:03:49,880 --> 00:03:52,417
E goes to x as one symbol
on the right-hand side, so

71
00:03:52,417 --> 00:03:54,778
we're going to pop back one symbol and
one state.

72
00:03:54,778 --> 00:03:58,452
Now, we're back in state one and
we've just generated an E subtree.

73
00:03:58,452 --> 00:04:02,400
So we are going to push that E subtree
onto the stack and go to state two.

74
00:04:02,400 --> 00:04:04,112
This is kind of like shifting, but

75
00:04:04,112 --> 00:04:06,836
we haven't consumed anything
on the input to do this.

76
00:04:06,836 --> 00:04:07,976
Here's the result.

77
00:04:07,976 --> 00:04:13,680
The stack has 0 and a from the initial
state, and 1 and E from state i1.

78
00:04:13,680 --> 00:04:20,907
State I2 says, we should see b next,
so we will shift and go to state four.

79
00:04:20,907 --> 00:04:21,908
In state four,

80
00:04:21,908 --> 00:04:26,075
we see that the end of input
indicates that we reduce by rule one.

81
00:04:26,075 --> 00:04:29,576
The S goes to aEb production.

82
00:04:29,576 --> 00:04:33,230
Since there are three symbols,
we must pop the three states.

83
00:04:33,230 --> 00:04:35,462
So here is the final result.

84
00:04:35,462 --> 00:04:37,978
Now that you've seen how
the state machine works,

85
00:04:37,978 --> 00:04:39,800
we need to talk about how to build it.

86
00:04:39,800 --> 00:04:41,517
We're going to present
this using two tables.

87
00:04:41,517 --> 00:04:45,400
One called as Action Table and
one called a Goto Table.

88
00:04:45,400 --> 00:04:47,260
The Action Table tells us what to do for

89
00:04:47,260 --> 00:04:52,080
a given input and the Goto table tells
us which state to transition to next.

90
00:04:52,080 --> 00:04:55,528
If you decide to watch other lectures
about LR parsing, you will sometimes

91
00:04:55,528 --> 00:04:59,045
see these tables combined into one,
because they take less space that way.

92
00:04:59,045 --> 00:05:01,429
But I find it's easier to explain,
if you use two tables.

93
00:05:01,429 --> 00:05:02,206
So that's what I did.

94
00:05:02,206 --> 00:05:08,600
The algorithm begins by creating the
initial state i0 from the start symbol.

95
00:05:08,600 --> 00:05:11,370
Let's assume the start
symbol is called S for now.

96
00:05:11,370 --> 00:05:13,390
We take the start symbol's productions and

97
00:05:13,390 --> 00:05:16,260
add the cursor at
the beginning of each of them.

98
00:05:16,260 --> 00:05:22,057
In example one, we see x goes to
cursor xSe and S goes to cursor Ex.

99
00:05:22,057 --> 00:05:26,861
In example two, you see S goes to
cursor xSe and S goes to cursor q.

100
00:05:26,861 --> 00:05:30,701
When we're building states,
we will take productions and

101
00:05:30,701 --> 00:05:34,490
add the cursor indicator
to it in various points.

102
00:05:34,490 --> 00:05:37,130
When the cursor comes before
a non-terminal symbol,

103
00:05:37,130 --> 00:05:39,150
it means we could be parsing that symbol.

104
00:05:39,150 --> 00:05:43,462
And so we'll need to add that symbol's
productions to the state, as well.

105
00:05:43,462 --> 00:05:46,789
Adding those new symbols could cause
another non-terminal symbol to have

106
00:05:46,789 --> 00:05:47,956
the cursor in front of it.

107
00:05:47,956 --> 00:05:50,180
In which case, we repeat the process.

108
00:05:50,180 --> 00:05:53,878
This is called taking the transitive
closure of the state.

109
00:05:53,878 --> 00:05:58,478
In example one, you see that the second
S production had a cursor in front of E.

110
00:05:58,478 --> 00:06:01,097
So we had to add the two E productions.

111
00:06:01,097 --> 00:06:05,827
This in turn put a cursor in front
of the F in the e goes to Fx rule.

112
00:06:05,827 --> 00:06:07,781
So we needed to add
the F productions also.

113
00:06:07,781 --> 00:06:12,930
An example two, the second S production
puts a cursor in front of the F.

114
00:06:12,930 --> 00:06:17,041
So we add the F production, but notice
that the E production is left out this

115
00:06:17,041 --> 00:06:19,925
time since the cursor never
appears in front of an E.

116
00:06:19,925 --> 00:06:23,803
If a cursor appears in front of a symbol
multiple times while creating a state,

117
00:06:23,803 --> 00:06:25,584
you only add this production once.

118
00:06:25,584 --> 00:06:27,583
Once you've created your first state,

119
00:06:27,583 --> 00:06:30,532
you follow these instructions
to create the other states.

120
00:06:30,532 --> 00:06:33,150
The uppercase letters are non-terminals.

121
00:06:33,150 --> 00:06:36,713
The lowercase letters are terminals and
the Greek letters are arbitrary

122
00:06:36,713 --> 00:06:39,766
combinations of symbols or
we don't care what kind they are.

123
00:06:39,766 --> 00:06:43,323
Now, the states we have been
referring to are called item sets.

124
00:06:43,323 --> 00:06:47,480
Now, what you will do is take a look
at the next item set in your machine.

125
00:06:47,480 --> 00:06:48,785
Let's say, it has number i.

126
00:06:48,785 --> 00:06:53,528
Now, there are three kind of productions
that we can find in state i now.

127
00:06:53,528 --> 00:06:57,116
The first kind will have
a cursor in front of a terminal

128
00:06:57,116 --> 00:06:59,925
symbol like E goes to alpha cursor x beta.

129
00:06:59,925 --> 00:07:02,850
This indicates a shift operation.

130
00:07:02,850 --> 00:07:04,475
So we create a new state j and

131
00:07:04,475 --> 00:07:08,947
add the transitive closure of the E
goes to alpha x cursor beta production.

132
00:07:08,947 --> 00:07:12,570
We have to move all of the productions
where our cursor is in front of the x to

133
00:07:12,570 --> 00:07:13,337
the new state.

134
00:07:13,337 --> 00:07:17,084
We will add shift column x in
row i of the action table and

135
00:07:17,084 --> 00:07:20,360
j to the corresponding
entry in the Goto table.

136
00:07:20,360 --> 00:07:22,602
If the cursor is in
front of a non-terminal,

137
00:07:22,602 --> 00:07:26,950
we create a new state j as before,
but we only add j to the Goto table.

138
00:07:26,950 --> 00:07:30,873
Finally, if the cursor is at the end of
production, we add a reduced action for

139
00:07:30,873 --> 00:07:34,677
that state now it may happen that this
would create a state that looks like one

140
00:07:34,677 --> 00:07:36,003
you had already created.

141
00:07:36,003 --> 00:07:40,770
In that case, you don't create
a new state, but reuse the old one.

142
00:07:40,770 --> 00:07:44,219
Maybe that was hard to follow, so
let's look at the tables from two example

143
00:07:44,219 --> 00:07:46,709
grammars and
analyze a third grammar in more detail.

144
00:07:46,709 --> 00:07:49,500
Here's an example from the first automata.

145
00:07:49,500 --> 00:07:53,577
The item states are listed
in the state diagram itself.

146
00:07:53,577 --> 00:07:55,387
State i0 has shift on a.

147
00:07:55,387 --> 00:08:00,067
State i1 has shift on b and
state i2 has reduce on dollar sign.

148
00:08:00,067 --> 00:08:02,359
Here's a state machine
from the second grammar.

149
00:08:02,359 --> 00:08:08,977
See how state i1 required a closure
since the cursor appeared in front of E.

150
00:08:08,977 --> 00:08:13,099
The Goto table also shows state
i1 going to state 2 on E.

151
00:08:13,099 --> 00:08:17,706
We need non-terminals in the Goto table
since that represents returning from

152
00:08:17,706 --> 00:08:18,971
a reduce operation.

153
00:08:18,971 --> 00:08:23,060
The Action table doesn't need them since
the Action table is completely drive by

154
00:08:23,060 --> 00:08:23,670
the input.

155
00:08:23,670 --> 00:08:27,827
Now in answer to the riddle,
where do we put all the reduce operations?

156
00:08:27,827 --> 00:08:29,935
It's all about the follow sets.

157
00:08:29,935 --> 00:08:33,982
State three has a reducing column b,
because b is in the follow set of E.

158
00:08:33,982 --> 00:08:39,350
State four has a reduce on the dollar
sign and that end of input.

159
00:08:39,350 --> 00:08:41,705
State four has reduced in dollar sign.

160
00:08:41,705 --> 00:08:47,507
That's the end of input column, because
the dollar sign is in the follow set of S.

161
00:08:47,507 --> 00:08:49,954
State four has reduce in the dollar sign.

162
00:08:49,954 --> 00:08:55,000
That is end of input column, because
dollar sign is in the follow set of S.

163
00:08:55,000 --> 00:08:57,359
Let's start with the fresh grammar and
build the statement.

164
00:08:58,430 --> 00:09:01,793
Now, let's start with a fresh grammar and
build the state machine from scratch.

165
00:09:01,793 --> 00:09:03,579
We'll use this grammar.

166
00:09:03,579 --> 00:09:07,307
To start, we'll put the cursor at
the beginning of the S productions,

167
00:09:07,307 --> 00:09:08,499
creating a state i0.

168
00:09:08,499 --> 00:09:11,690
There are non-terminals after the cursor,
so

169
00:09:11,690 --> 00:09:15,120
we don't have to add anything more to i0.

170
00:09:15,120 --> 00:09:18,370
Now, we take i0 and
decide what transitions can happen.

171
00:09:18,370 --> 00:09:20,643
Both of the productions would shift on a,
so

172
00:09:20,643 --> 00:09:22,860
we're going to create
a new state from them.

173
00:09:22,860 --> 00:09:27,087
You've created state i1, added S for
shift in the Action table and

174
00:09:27,087 --> 00:09:28,434
1 in the Goto table.

175
00:09:28,434 --> 00:09:31,624
A cursor appeared before E
in the first production,

176
00:09:31,624 --> 00:09:34,534
so we had to add the E
productions to i1 as well.

177
00:09:34,534 --> 00:09:36,381
Now, to look at transitions.

178
00:09:36,381 --> 00:09:40,070
The first rule has a cursor before
an e and the third does, as well.

179
00:09:40,070 --> 00:09:42,768
So we're going to create
a Goto transition from them.

180
00:09:42,768 --> 00:09:44,938
Here is the result state i2.

181
00:09:44,938 --> 00:09:48,515
Next, we're going to create a shift
from these two productions over b.

182
00:09:48,515 --> 00:09:49,698
In case you are wondering,

183
00:09:49,698 --> 00:09:53,206
it doesn't matter according to the
algorithm which productions you worked on.

184
00:09:53,206 --> 00:09:55,715
But everyone who does this will
do it in order of states and

185
00:09:55,715 --> 00:09:57,560
in the order the productions are listed.

186
00:09:57,560 --> 00:09:59,226
If you do it in a different order,

187
00:09:59,226 --> 00:10:03,154
you risk confusing anyone who reads your
machine later which is very bad luck if

188
00:10:03,154 --> 00:10:05,548
the reader happens to be
one grading your exam.

189
00:10:05,548 --> 00:10:07,997
Here, a state three created by that shift.

190
00:10:07,997 --> 00:10:10,323
We're done with state one now and
can look at state two.

191
00:10:10,323 --> 00:10:15,380
We will shift the b to create
state four and here is state four.

192
00:10:15,380 --> 00:10:19,663
There's one more production in state
two where we need to shift x to get

193
00:10:19,663 --> 00:10:20,469
state five.

194
00:10:20,469 --> 00:10:22,320
State five looks like this.

195
00:10:23,510 --> 00:10:28,717
Now, we can look at state three
that moves the cursor across S and

196
00:10:28,717 --> 00:10:30,750
that gives us state six.

197
00:10:30,750 --> 00:10:34,374
The next thing we need to do
is reduce this E goes to b.

198
00:10:34,374 --> 00:10:38,869
E follows set is b and x.

199
00:10:38,869 --> 00:10:43,483
So we add reduce four to b and
x columns of the action table.

200
00:10:43,483 --> 00:10:48,140
And to reduce four since E goes to b, it's
the fourth production and the grammar.

201
00:10:49,490 --> 00:10:51,621
Next, we can look at
these two S productions.

202
00:10:51,621 --> 00:10:53,927
What would the resulting state look like?

203
00:10:53,927 --> 00:10:58,419
Pause and
just try to work that out before resuming.

204
00:10:58,419 --> 00:11:02,459
It turns out that these two productions
would produce the state exactly like

205
00:11:02,459 --> 00:11:06,386
state i1, so we make our transition
to i1 instead of making a new state.

206
00:11:06,386 --> 00:11:10,015
This only works if the states
are identical, exactly identical.

207
00:11:10,015 --> 00:11:11,788
If there's anything at all added or

208
00:11:11,788 --> 00:11:15,770
missing, then you must make a new
state rather than recycling.

209
00:11:15,770 --> 00:11:20,390
To wrap things up, we do all three
of these remaining productions which

210
00:11:20,390 --> 00:11:25,089
all happen to be reduce operations and
here's the final state machine.

211
00:11:25,089 --> 00:11:27,871
In the next slide, I'm going to give
you another grammar to work on.

212
00:11:27,871 --> 00:11:31,030
But this time,
you get to build the machine yourself.

213
00:11:31,030 --> 00:11:34,107
You may want to copy down
the grammar from this example and

214
00:11:34,107 --> 00:11:37,588
see if you can reproduce the state
machine that's here first.

215
00:11:37,588 --> 00:11:40,306
So now, try building the automata for
this grammar.

216
00:11:40,306 --> 00:11:41,296
It's a bit of trick,

217
00:11:41,296 --> 00:11:45,280
because there's a situation that comes
up that I haven't mentioned yet.

218
00:11:45,280 --> 00:11:49,018
But the hint is it has something to
do with the fact that this grammar is

219
00:11:49,018 --> 00:11:49,734
ambiguous.

220
00:11:49,734 --> 00:11:53,220
In the next video, we will generate
the table and introduce that new concept.