Hello, everyone and welcome to CS 421. Today, we're going to
talk about LR parsing. If you're going to do any
parsing in the real world, you most likely are going to
come across LR parsers. In this video, we're going to discuss the
basics of LR parsers and how they work. So you could use one of the many
tools that support them. When you're done with this video, you will
be able to describe how LL and LR parsers differ and you will be able to produce
a finite state machine from an LR grammar. In a future video, you will also be
able to use the state machine to detect if the grammar is ambiguous. So what is LR parsing? An LR parser is a parser that does
a left-to-right scan of its input, but produces something called
a rightmost derivation. It's also called bottom up parsing. Instead of starting with a start symbol
and building the tree from the root to the leaves, it starts by collecting
leaves, building branches of the tree and then combining the branches
to create the final results. An LR parser uses a push down
automata to do its work. Now hopefully, you remember from your
previous course work that a push down automata is a state machine
that also has a stack and this allows a machine to remember the path
it took and return to a previous state. There are four operations. Shift consumes input from a token stream. Reduce builds a tree out
of collected components. Goto jumps to another state after a reduce
and accept signals that we're done. Let's look at a simple grammar
to introduce shifting. We'll use a grammar with one operation,
S goes to ab. There are three states that
can exist during the parse. In the initial state called i0 here, our
machine knows that it is collecting input for S goes to ab and
that we've not consumed any input yet. To indicate where we are during the parse,
we use a filled in circle as a cursor. Notice that the cursors in front of
the ab in the input and also in state i0. When we shift, we consume the input
in transition to state one. We push zero and a onto the stack to
remember that we came from state zero. And now, we consumed a when we left it. The cursor is now between the a and the b
indicating that we can expect the b next. Next, we consume a b and go to state two. The stack at 0, a, 1, b for
the two states into inputs. The next sample is dollar sign,
which represents c into the input. And now, we are ready to build
an else tree out of a and the b and this is called reducing. The next state machine state I2 has
an indication at the bottom that a dollar sign means we can reduce
according to rule one. That's what the r1 means here. We only have one rule. S goes to ab. So here's what happens in a reduce. We look at how many symbols are on the
right-hand side of the production we're reducing and we pop that many symbols,
and states from our stack, and that returns us to our previous state. In this case, we pop off two symbols, the
a and the b and we use them to build an S. We also return two states back,
putting us into state zero again. The next thing that would happen
is a Go To or an Accept action, but we've not put them here yet. Here's a more complicated example that
will show what happens after reduce is finished. We'll start in state zero and
we're looking at the a on the input. Consuming the a, we push a and
zero onto the stack. And now we are in state one,
looking at an x. State one tells us that two
things could be happening here. The top line says that we could have
just finished building an E subtree and the second line says that we
could see an x on the input, and use that to start building an E subtree. Since an x is next on the input,
we're going to take the bottom route and move to state three. In state three, we're at the end
of a production and state says, we can reduce now since
a b is next on the input. I'll explain later, but be thinking
about why there's a b to indicate we can reduce the E and
not some other symbol. E goes to x as one symbol
on the right-hand side, so we're going to pop back one symbol and
one state. Now, we're back in state one and
we've just generated an E subtree. So we are going to push that E subtree
onto the stack and go to state two. This is kind of like shifting, but we haven't consumed anything
on the input to do this. Here's the result. The stack has 0 and a from the initial
state, and 1 and E from state i1. State I2 says, we should see b next,
so we will shift and go to state four. In state four, we see that the end of input
indicates that we reduce by rule one. The S goes to aEb production. Since there are three symbols,
we must pop the three states. So here is the final result. Now that you've seen how
the state machine works, we need to talk about how to build it. We're going to present
this using two tables. One called as Action Table and
one called a Goto Table. The Action Table tells us what to do for a given input and the Goto table tells
us which state to transition to next. If you decide to watch other lectures
about LR parsing, you will sometimes see these tables combined into one,
because they take less space that way. But I find it's easier to explain,
if you use two tables. So that's what I did. The algorithm begins by creating the
initial state i0 from the start symbol. Let's assume the start
symbol is called S for now. We take the start symbol's productions and add the cursor at
the beginning of each of them. In example one, we see x goes to
cursor xSe and S goes to cursor Ex. In example two, you see S goes to
cursor xSe and S goes to cursor q. When we're building states,
we will take productions and add the cursor indicator
to it in various points. When the cursor comes before
a non-terminal symbol, it means we could be parsing that symbol. And so we'll need to add that symbol's
productions to the state, as well. Adding those new symbols could cause
another non-terminal symbol to have the cursor in front of it. In which case, we repeat the process. This is called taking the transitive
closure of the state. In example one, you see that the second
S production had a cursor in front of E. So we had to add the two E productions. This in turn put a cursor in front
of the F in the e goes to Fx rule. So we needed to add
the F productions also. An example two, the second S production
puts a cursor in front of the F. So we add the F production, but notice
that the E production is left out this time since the cursor never
appears in front of an E. If a cursor appears in front of a symbol
multiple times while creating a state, you only add this production once. Once you've created your first state, you follow these instructions
to create the other states. The uppercase letters are non-terminals. The lowercase letters are terminals and
the Greek letters are arbitrary combinations of symbols or
we don't care what kind they are. Now, the states we have been
referring to are called item sets. Now, what you will do is take a look
at the next item set in your machine. Let's say, it has number i. Now, there are three kind of productions
that we can find in state i now. The first kind will have
a cursor in front of a terminal symbol like E goes to alpha cursor x beta. This indicates a shift operation. So we create a new state j and add the transitive closure of the E
goes to alpha x cursor beta production. We have to move all of the productions
where our cursor is in front of the x to the new state. We will add shift column x in
row i of the action table and j to the corresponding
entry in the Goto table. If the cursor is in
front of a non-terminal, we create a new state j as before,
but we only add j to the Goto table. Finally, if the cursor is at the end of
production, we add a reduced action for that state now it may happen that this
would create a state that looks like one you had already created. In that case, you don't create
a new state, but reuse the old one. Maybe that was hard to follow, so
let's look at the tables from two example grammars and
analyze a third grammar in more detail. Here's an example from the first automata. The item states are listed
in the state diagram itself. State i0 has shift on a. State i1 has shift on b and
state i2 has reduce on dollar sign. Here's a state machine
from the second grammar. See how state i1 required a closure
since the cursor appeared in front of E. The Goto table also shows state
i1 going to state 2 on E. We need non-terminals in the Goto table
since that represents returning from a reduce operation. The Action table doesn't need them since
the Action table is completely drive by the input. Now in answer to the riddle,
where do we put all the reduce operations? It's all about the follow sets. State three has a reducing column b,
because b is in the follow set of E. State four has a reduce on the dollar
sign and that end of input. State four has reduced in dollar sign. That's the end of input column, because
the dollar sign is in the follow set of S. State four has reduce in the dollar sign. That is end of input column, because
dollar sign is in the follow set of S. Let's start with the fresh grammar and
build the statement. Now, let's start with a fresh grammar and
build the state machine from scratch. We'll use this grammar. To start, we'll put the cursor at
the beginning of the S productions, creating a state i0. There are non-terminals after the cursor,
so we don't have to add anything more to i0. Now, we take i0 and
decide what transitions can happen. Both of the productions would shift on a,
so we're going to create
a new state from them. You've created state i1, added S for
shift in the Action table and 1 in the Goto table. A cursor appeared before E
in the first production, so we had to add the E
productions to i1 as well. Now, to look at transitions. The first rule has a cursor before
an e and the third does, as well. So we're going to create
a Goto transition from them. Here is the result state i2. Next, we're going to create a shift
from these two productions over b. In case you are wondering, it doesn't matter according to the
algorithm which productions you worked on. But everyone who does this will
do it in order of states and in the order the productions are listed. If you do it in a different order, you risk confusing anyone who reads your
machine later which is very bad luck if the reader happens to be
one grading your exam. Here, a state three created by that shift. We're done with state one now and
can look at state two. We will shift the b to create
state four and here is state four. There's one more production in state
two where we need to shift x to get state five. State five looks like this. Now, we can look at state three
that moves the cursor across S and that gives us state six. The next thing we need to do
is reduce this E goes to b. E follows set is b and x. So we add reduce four to b and
x columns of the action table. And to reduce four since E goes to b, it's
the fourth production and the grammar. Next, we can look at
these two S productions. What would the resulting state look like? Pause and
just try to work that out before resuming. It turns out that these two productions
would produce the state exactly like state i1, so we make our transition
to i1 instead of making a new state. This only works if the states
are identical, exactly identical. If there's anything at all added or missing, then you must make a new
state rather than recycling. To wrap things up, we do all three
of these remaining productions which all happen to be reduce operations and
here's the final state machine. In the next slide, I'm going to give
you another grammar to work on. But this time,
you get to build the machine yourself. You may want to copy down
the grammar from this example and see if you can reproduce the state
machine that's here first. So now, try building the automata for
this grammar. It's a bit of trick, because there's a situation that comes
up that I haven't mentioned yet. But the hint is it has something to
do with the fact that this grammar is ambiguous. In the next video, we will generate
the table and introduce that new concept.