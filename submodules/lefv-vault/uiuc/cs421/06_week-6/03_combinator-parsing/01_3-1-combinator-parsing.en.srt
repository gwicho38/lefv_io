1
00:00:00,170 --> 00:00:03,795
Hello everyone. Welcome to CS 421.

2
00:00:03,795 --> 00:00:06,825
So, far you've seen LO parsers which used

3
00:00:06,825 --> 00:00:11,055
recursive descent and LR parsers which use push-down automata.

4
00:00:11,055 --> 00:00:15,930
This time we're going to use monads to build parsers which are completely composable and

5
00:00:15,930 --> 00:00:18,180
their resulting Haskell code looks very much like

6
00:00:18,180 --> 00:00:21,525
the grammar we're trying to write a parser for in the first place.

7
00:00:21,525 --> 00:00:23,055
When you're done with this video,

8
00:00:23,055 --> 00:00:25,380
you'll be able to use monadic parser combinators

9
00:00:25,380 --> 00:00:27,975
to build parses for context-free grammars.

10
00:00:27,975 --> 00:00:31,890
You'll be able to build your own parser combinator library from scratch.

11
00:00:31,890 --> 00:00:34,860
Now, the problem we're trying to solve is this.

12
00:00:34,860 --> 00:00:37,320
Recursive descent parsers are easy to write,

13
00:00:37,320 --> 00:00:39,600
but the grammar has to be LR.

14
00:00:39,600 --> 00:00:42,270
Also, we have to deal with the plumbing issue,

15
00:00:42,270 --> 00:00:43,460
parsing input stream in,

16
00:00:43,460 --> 00:00:45,125
and returning it back every time.

17
00:00:45,125 --> 00:00:47,560
So, today we're going to fix that.

18
00:00:47,560 --> 00:00:51,635
To start off, let's define a type that represents our parser.

19
00:00:51,635 --> 00:00:55,700
This is going to look like the state type we defined for the state monad.

20
00:00:55,700 --> 00:00:58,290
We want to say that we have a parser of type T,

21
00:00:58,290 --> 00:01:01,430
if we have a function that inputs a list of strings and

22
00:01:01,430 --> 00:01:05,540
returns a list of pairs of a T and the remaining strings.

23
00:01:05,540 --> 00:01:08,300
The output being a list of pairs may be unexpected,

24
00:01:08,300 --> 00:01:10,400
but it gives us some nice flexibility.

25
00:01:10,400 --> 00:01:13,940
It allows us to use an empty list indicate that a parse failed and

26
00:01:13,940 --> 00:01:17,434
we could potentially return multiple parses if the grammar were ambiguous,

27
00:01:17,434 --> 00:01:20,390
though in practice, we're not actually going to do that.

28
00:01:20,390 --> 00:01:25,460
We can find the run function to extract the function part of the parser type.

29
00:01:25,460 --> 00:01:29,350
Notice, we're not using records in fields like we did with the state monad.

30
00:01:29,350 --> 00:01:30,730
Now, that we have our type,

31
00:01:30,730 --> 00:01:32,510
let's try writing a parser with it,

32
00:01:32,510 --> 00:01:34,670
something simple just to get started.

33
00:01:34,670 --> 00:01:36,485
We will write a parser generator,

34
00:01:36,485 --> 00:01:39,735
char s that takes a character s as an input,

35
00:01:39,735 --> 00:01:42,410
and returns a parser that succeeds if the next input

36
00:01:42,410 --> 00:01:45,655
is the same character as s, and fails otherwise.

37
00:01:45,655 --> 00:01:47,810
For success, we just return a list with

38
00:01:47,810 --> 00:01:50,479
the first character and the remaining characters is in a pair,

39
00:01:50,479 --> 00:01:52,805
for failure we just return the empty list.

40
00:01:52,805 --> 00:01:54,980
Now, remember that the default representation of

41
00:01:54,980 --> 00:01:57,670
strings and Haskell is a list of characters.

42
00:01:57,670 --> 00:02:02,510
We can make the parser more general by allowing a match of multiple characters.

43
00:02:02,510 --> 00:02:04,720
Here's a common parser generator called oneOf,

44
00:02:04,720 --> 00:02:07,250
that takes a list of characters and returns a parser that

45
00:02:07,250 --> 00:02:10,645
succeeds if the next input character is one of them.

46
00:02:10,645 --> 00:02:13,160
We can use this to define parsers like digit,

47
00:02:13,160 --> 00:02:15,440
though in reality we would use something more efficient

48
00:02:15,440 --> 00:02:18,550
since the whole list of digits would need to be traversed.

49
00:02:18,550 --> 00:02:21,710
Notice, our writing parsers that do some kind of test on

50
00:02:21,710 --> 00:02:25,910
the first character and succeed if the test succeeds and fails otherwise.

51
00:02:25,910 --> 00:02:31,400
We can abstract this by making a parser generator "sat" which is short for satisfy,

52
00:02:31,400 --> 00:02:33,850
that takes a predicate as a function.

53
00:02:33,850 --> 00:02:39,560
We can call this function "pred" on the first input rather than hard coding the action.

54
00:02:39,560 --> 00:02:42,575
Compare oneOf and sat to see the differences.

55
00:02:42,575 --> 00:02:47,455
For digit, sat lets us write more efficient version of the original oneOf.

56
00:02:47,455 --> 00:02:50,259
This next parser is very interesting,

57
00:02:50,259 --> 00:02:53,825
and it shows why we use a list of pairs as a parser's output.

58
00:02:53,825 --> 00:02:57,650
We'll create an operator with this pipe symbol in angle brackets.

59
00:02:57,650 --> 00:03:00,905
It takes two parsers and runs some both on the input.

60
00:03:00,905 --> 00:03:03,260
Since the output will both be lists,

61
00:03:03,260 --> 00:03:05,765
we append them together and then take the first element.

62
00:03:05,765 --> 00:03:08,915
If P1 succeeds, we'll return P1's result.

63
00:03:08,915 --> 00:03:10,340
Since Haskell is lazy,

64
00:03:10,340 --> 00:03:12,515
P2 will never even be run.

65
00:03:12,515 --> 00:03:15,370
If p1 runs and we will get P2's result.

66
00:03:15,370 --> 00:03:18,150
If p1 fails, we will get P2's result.

67
00:03:18,150 --> 00:03:21,560
If it succeeded, if both fail we just get an empty list.

68
00:03:21,560 --> 00:03:25,100
Here are a few examples using a parser that succeeds at

69
00:03:25,100 --> 00:03:28,735
the first letter of the input as a digit or the letter a.

70
00:03:28,735 --> 00:03:32,120
Now, parsers can be recursive as well.

71
00:03:32,120 --> 00:03:34,910
Here's a recursive string matching parser.

72
00:03:34,910 --> 00:03:39,410
You give it a string and it calls itself recursively character by character on the input.

73
00:03:39,410 --> 00:03:43,700
You'll notice that we have to spend some effort to keep track of all the inputs.

74
00:03:43,700 --> 00:03:47,900
You'll notice that we have to expend some effort to keep track of the inputs and outputs

75
00:03:47,900 --> 00:03:52,310
and recombine everything together properly after the recursive call returns.

76
00:03:52,310 --> 00:03:55,880
If the recursion succeeds we want to propagate the success,

77
00:03:55,880 --> 00:03:58,700
and if the recursion fails we want to propagate to failure.

78
00:03:58,700 --> 00:04:00,920
This is another example of plumbing,

79
00:04:00,920 --> 00:04:03,575
and it makes our programs messy and error-prone.

80
00:04:03,575 --> 00:04:07,430
But we've already seen a structure that handles the propagation and failure,

81
00:04:07,430 --> 00:04:10,045
and the unpacking of an incoming data structure.

82
00:04:10,045 --> 00:04:11,990
Of course, it's not going to be surprised now,

83
00:04:11,990 --> 00:04:13,940
because already mentioned that we're going to use monads.

84
00:04:13,940 --> 00:04:16,895
So, let's make a monad for our parser type.

85
00:04:16,895 --> 00:04:20,870
First thing we have to do is define the Functor type for parsers.

86
00:04:20,870 --> 00:04:26,240
This gives us fmap that takes a function f and applies it to the result for our parser.

87
00:04:26,240 --> 00:04:28,000
You can see what will happen here.

88
00:04:28,000 --> 00:04:31,555
The incoming parser contains a parsing function P1,

89
00:04:31,555 --> 00:04:35,190
we feed input to p1 to get out a list of pairs.

90
00:04:35,190 --> 00:04:38,885
The first element of each pair is the result of the parse,

91
00:04:38,885 --> 00:04:41,135
and that's the part we want to apply f to.

92
00:04:41,135 --> 00:04:44,000
The second part of the pair is the remaining input,

93
00:04:44,000 --> 00:04:46,895
and that's what we want to return as is.

94
00:04:46,895 --> 00:04:52,520
As an example, we can create a parser SDI for single digit integer,

95
00:04:52,520 --> 00:04:55,280
and returns an actual integer instead of a character.

96
00:04:55,280 --> 00:04:57,560
We can fmap plus one over that parser,

97
00:04:57,560 --> 00:05:01,070
and once it's run integer returned has been incremented.

98
00:05:01,070 --> 00:05:05,815
Even this by itself gives us a lot more power over our parsers.

99
00:05:05,815 --> 00:05:07,919
The next level up is applicatives,

100
00:05:07,919 --> 00:05:10,655
which allow multi-parameter functions to be applied.

101
00:05:10,655 --> 00:05:13,340
Given two parser functions p1 and p2,

102
00:05:13,340 --> 00:05:16,220
we run P1 to extract a function result V1,

103
00:05:16,220 --> 00:05:20,395
and then we run P2 over the rest of the input to get a perimeter of V2.

104
00:05:20,395 --> 00:05:23,540
Finally, we apply V1 to V2 to get our final result.

105
00:05:23,540 --> 00:05:27,590
In our example, we have plus applied to two SDI parsers.

106
00:05:27,590 --> 00:05:29,990
It then reads the first two digits four and five,

107
00:05:29,990 --> 00:05:32,570
and adds them together for the final parse.

108
00:05:32,570 --> 00:05:34,585
Next step is the monad.

109
00:05:34,585 --> 00:05:37,090
But I'm going to give you the usual advice now,

110
00:05:37,090 --> 00:05:39,260
pause the video and try typing all this in,

111
00:05:39,260 --> 00:05:41,420
so you can be sure you understand it,

112
00:05:41,420 --> 00:05:44,570
and resume when you're ready to see the monad definition.

113
00:05:44,570 --> 00:05:46,765
Here's a monad definition.

114
00:05:46,765 --> 00:05:50,870
We have some parser p that we want to bind to a function f. So,

115
00:05:50,870 --> 00:05:53,870
we take P and apply it to the input to get the result V,

116
00:05:53,870 --> 00:05:57,315
and the rest of the input I and P prime.

117
00:05:57,315 --> 00:06:00,785
Now, we apply V to F which should return a new parser,

118
00:06:00,785 --> 00:06:03,710
and run that against IMP prime.

119
00:06:03,710 --> 00:06:05,120
This will return a list of lists,

120
00:06:05,120 --> 00:06:08,030
so we can cat them together to get a single list.

121
00:06:08,030 --> 00:06:11,230
Now, we can write the plus parser monadically,

122
00:06:11,230 --> 00:06:14,910
we call SDI twice binding ones to X and ones to y,

123
00:06:14,910 --> 00:06:17,510
and then returning the result x plus y.

124
00:06:17,510 --> 00:06:19,080
Here's that example twice,

125
00:06:19,080 --> 00:06:23,975
when using regular bind notation and when using the special do notation.

126
00:06:23,975 --> 00:06:27,020
Here, was our stream parser with all the plumbing,

127
00:06:27,020 --> 00:06:28,955
either you can write it monadically.

128
00:06:28,955 --> 00:06:33,085
Pause and hit resume when you're ready to see the solution.

129
00:06:33,085 --> 00:06:35,400
Here's a monadic version,

130
00:06:35,400 --> 00:06:38,265
line two reads a character and line three does the recursion,

131
00:06:38,265 --> 00:06:40,035
line four combines the result.

132
00:06:40,035 --> 00:06:45,575
The best part is, the monad takes care of all the plumbing for us, never have to see it.

133
00:06:45,575 --> 00:06:47,690
Using a recursive pattern,

134
00:06:47,690 --> 00:06:50,480
we can write parser generates take a predicate and keep

135
00:06:50,480 --> 00:06:54,215
consuming input while the predicate's true many is zero or more,

136
00:06:54,215 --> 00:06:56,510
many one needs at least one match.

137
00:06:56,510 --> 00:06:59,305
A very common parser combinators spaces,

138
00:06:59,305 --> 00:07:01,635
that consumes spaces or whitespace.

139
00:07:01,635 --> 00:07:05,320
Here's a simplified version using many in oneOf.

140
00:07:05,320 --> 00:07:08,710
In real life, you would also add tab a new line.

141
00:07:08,710 --> 00:07:11,070
We can also be very flexible about the output type,

142
00:07:11,070 --> 00:07:13,445
as you saw with the single digit integer parser.

143
00:07:13,445 --> 00:07:16,355
This parser can return an integer expression.

144
00:07:16,355 --> 00:07:21,625
The int parser just collects digits with many one digit and packages it into an index.

145
00:07:21,625 --> 00:07:25,755
To parse operators, we often have this chaining operator.

146
00:07:25,755 --> 00:07:30,320
Oper just takes an operator and consumes the spaces that come after it.

147
00:07:30,320 --> 00:07:34,760
Chainl1 and takes a parser p and the operator parser0.

148
00:07:34,760 --> 00:07:38,375
Line four runs p via the bind operation,

149
00:07:38,375 --> 00:07:41,905
and then line five checks to see if an operator is next.

150
00:07:41,905 --> 00:07:45,345
If so, it reads another p it repeats the process.

151
00:07:45,345 --> 00:07:49,520
If not, line eight returns the result from P by itself,

152
00:07:49,520 --> 00:07:53,180
this will recreate a left associative operation.

153
00:07:53,180 --> 00:07:57,605
We can now write an expression parser for plus and integers very simply.

154
00:07:57,605 --> 00:08:02,690
If you remember when we showed you how to create unambiguous grammars by stratification,

155
00:08:02,690 --> 00:08:04,040
this will look familiar.

156
00:08:04,040 --> 00:08:07,190
We can create expressions that are disjunctions, conjunctions,

157
00:08:07,190 --> 00:08:10,550
comparisons, additions, multiplications or atomic things.

158
00:08:10,550 --> 00:08:14,285
The stratification make sure these operators have the correct precedence.

159
00:08:14,285 --> 00:08:17,395
Here's our final example a let expression.

160
00:08:17,395 --> 00:08:20,990
Parser combinator libraries all have try combinator,

161
00:08:20,990 --> 00:08:23,570
that will allow for backtracking if a parse fails.

162
00:08:23,570 --> 00:08:25,660
You'll get to see more of this in your assignments,

163
00:08:25,660 --> 00:08:27,785
so we want to explain it carefully here.

164
00:08:27,785 --> 00:08:30,530
There are many parser combinator libraries for Haskell.

165
00:08:30,530 --> 00:08:34,140
Parsec is the most famous one mainly because it was the first,

166
00:08:34,140 --> 00:08:36,970
attoparsec is more industrial version of it,

167
00:08:36,970 --> 00:08:40,655
and currently megaparsec is the best-performing parser library.

168
00:08:40,655 --> 00:08:42,320
If you're starting from zero,

169
00:08:42,320 --> 00:08:44,970
I'd recommend learning megaparsec.