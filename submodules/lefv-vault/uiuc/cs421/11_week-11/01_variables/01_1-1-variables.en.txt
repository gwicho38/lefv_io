You think you know what a variable is, don't you? They're actually somewhat complicated. Turns out all variables have four properties and you can pick when those properties are conferred to the variable. When we're done with this video, you'll be able to explain the difference between static and dynamic binding, and you'll be able to explain the four properties of variables in half. That is value, type, location, and even scope. We'll also talk a little bit about declaration and aliasing as we go. What is a variable anyway? In Mathematics, a variable represents quantity or values possibly unknown. In programming, a variable is an implementation of this mathematical construct. Now, this has implications that we often forget about. So, for example, variables and math don't have memory locations. The variables in the computer do. Integers and math never overflow, but integers in the computer may. So, if a property is conferred to variable at compiled time, we call it static binding. Property can be hard coded this way and the compiler can take advantage of this knowledge to make more efficient executables. If the property is bound at runtime, we call it dynamic binding. Now, dynamic binding is more flexible, but sometimes it causes our program to be less efficient. So, the first property we will talk about is value. Values are the easy seem to choose between static and dynamic binding. Usually is statically bound variables called a constant most languages. But usually, we want dynamic binding. Because if we don't want variables to vary, then we probably shouldn't be calling them variables. Now, static binding of value is not the same thing as immutability. Haskell's variables for instance are immutable. Once you assign a value to them, you cannot change them. The assignment happens at runtime though, so the value is still considered to be dynamic. Next property we're going to talk about is a type of variable. Now, the programming language world can easily be divided into two camps. Static typing camp which gives rise to C++, OCaml, and Haskell, point to the safety that static types give you. You've probably noticed that if your program gets passed Haskell's type-checker then you are close to being done. Now, the dynamic typing people like languages such as Perl, Lisp, and Closure. The Lisp and Clojure community have a saying, "Variables don't have types. Only values have types. A trade-off you get is between safety and expressability." Now, related idea is polymorphism. We're not content just to choose between completely static and completely dynamic with their types. So, polymorphism could be a principled way to provide the advantage of dynamic typing, but still has static types. So, for example, most languages overload plus to work with both integers and floats. We can use parameterized types to allow containers contain many different kinds of types. Haskell's type classes are also an effort to provide much of the advantages of dynamic typing while still preserving the advantages of a strong type system. The third property is location. Now, location of a variable is either completely dynamic, if it's allocated on the heap or partially static, if it's allocated on the stack. So, what I mean by that is that a function will no relative to a frame pointer where a local variable is. Frame pointer will change every call, but the offset will be known at compile time. So, there's one very strange language. So, where all the variables were statically allocated even function parameters. This language is called Fortran. Fortran is the oldest language still unused followed by one-year by Lisp. The modern versions are completely different. The modern versions look different than the originals of course. But they're still recognizable. The earliest machines had very little RAM and CPUs were not that fast. So, scientists tended to code in machine code to get the most performance from the machine, especially since CPU time is often built by the hour. Now, to be sure that Fortran was a good option, all variables were statically allocated. So, that Fortran compiled code could be competitive with handwritten assembly. As a result, you could not use recursion on functions without implementing recursion by hand. Now of course, modern Fortran fixes that. Now, if you use C++, you're probably familiar with the idea that two variables can share a memory location. Is called aliasing. They have arrays allocated next to each other in memory and go past the end of an array. You can actually access the memory of the secondary without meaning to. One of the strangest bugs ever encountered was a result of that. Now, on C++ aliasing happens when you call the reference or even return by reference. Haskell's variables also use aliasing. So, if you use let to assign one variable to be the value of another variable, then they'll both use the same memory location. Now, since the memory cannot change, this is completely safe. The final property we'll talk about is lifetime and scope. You might not think about that initially as a property of a variable. But in fact, the variables only valid in certain places and at certain times. Now, most languages use what's called static scoping. So, in other words, simply by looking at the code, you can tell whether variable exists. So, consider the variable in the function foo and know that it can only be used on line two and three and that the variable J in the function bar on line six and nine is a different variable. It just happens to have the same name. Here's an example in C. What will this function bar return, if I run this program? Well, of course, it should return four since the variable i in function foo on line three refers to the global variable i not the local variable i. Now, let's look at the equivalent code in Emacs Lisp. Now, set Q i2 creates a new global variable i and initializes it to two. Lines two and three creating a function foo that returns i squared. Line six to eight create a new function bar that creates a local variable called i initialize it to be 10 and then calls bar. Now, by the mere fact that I even bring this up, you can probably guess that the result is going to be 100 and you would be right. Emacs Lisp use something called dynamic scope. Free variables and functions access the scope of the code. That call them at runtime, not the scope that exist at compiled time. Now, for Emacs which is an editor, if he didn't happen to know about that, this is the feature since a function can override a configuration variables simply by creating local copy of it. Then that variable will appear to its original value and the function is done. But for most applications there's only serves to make the program more difficult to reason about. It's considered a pretty bad thing. So, imagine you had a function and you change the name of one of your local variables, and suddenly another function in your system started changing its behavior as a result. It's exactly what dynamic binding is scope causes to happen. Now, the first dialect of lisp use this style. By the time people decided it was a bad thing, the user base was dependent on the bug as a feature. So, other than Emacs Lisp which is actually a very old language, is languages go, most of the other Lisp use static binding of scope. Now, there you can usually declare a variable to have dynamic scope if you wanted to in a Lisp language. So, those are the four properties of variables and what happens when the properties conferred to the variable either at compile time or runtime. In our next lesson, we will talk about parameter passing styles.