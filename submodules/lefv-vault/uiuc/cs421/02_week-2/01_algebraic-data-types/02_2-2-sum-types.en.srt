1
00:00:00,000 --> 00:00:01,545
Hello, everyone. Welcome back.

2
00:00:01,545 --> 00:00:03,500
In this video we are going to talk about Sum Types,

3
00:00:03,500 --> 00:00:05,800
the second of the algebraic data types.

4
00:00:05,800 --> 00:00:07,620
So, your objectives are, of course,

5
00:00:07,620 --> 00:00:09,675
knowing the syntax and being able to declare

6
00:00:09,675 --> 00:00:12,330
these disjoint data types and using

7
00:00:12,330 --> 00:00:15,630
them to represent lists and expressions and exceptions.

8
00:00:15,630 --> 00:00:21,275
There are a couple of these disjoint data types that are used very commonly in Haskell.

9
00:00:21,275 --> 00:00:24,260
The Maybe, the List and the Either data types.

10
00:00:24,260 --> 00:00:26,000
So, you want to be able to understand those,

11
00:00:26,000 --> 00:00:27,975
be able use them in a program,

12
00:00:27,975 --> 00:00:31,175
because they are going to come up in class quite a bit.

13
00:00:31,175 --> 00:00:33,470
Also, we are going to show you an example of using

14
00:00:33,470 --> 00:00:36,365
disjoint data type to represent arithmetic.

15
00:00:36,365 --> 00:00:41,770
So, you can actually build a tree that represents some kind of arithmetic operation,

16
00:00:41,770 --> 00:00:46,440
with the pluses and times and whatnot and then write a function to evaluate them.

17
00:00:46,440 --> 00:00:48,825
So, here's a syntax.

18
00:00:48,825 --> 00:00:52,100
We use a data keyword as before and then after that,

19
00:00:52,100 --> 00:00:55,475
you have the name of the type that you want to declare.

20
00:00:55,475 --> 00:01:00,170
Then there's an equal sign and then there is, more than one usually,

21
00:01:00,170 --> 00:01:04,330
constructor and the constructors could take arguments,

22
00:01:04,330 --> 00:01:10,060
sometimes they don't, and sometimes also these constructors can have type parameters.

23
00:01:10,060 --> 00:01:12,485
So, let's look at these examples.

24
00:01:12,485 --> 00:01:14,740
So, the first one we have data Contest.

25
00:01:14,740 --> 00:01:17,625
So, Contest is the name of the type and there's three constructors,

26
00:01:17,625 --> 00:01:19,690
none of them which take any arguments,

27
00:01:19,690 --> 00:01:21,470
so we have Rock, Scissors and Paper.

28
00:01:21,470 --> 00:01:23,810
So, if you call these without arguments,

29
00:01:23,810 --> 00:01:25,690
they create something of this type.

30
00:01:25,690 --> 00:01:26,995
So, think of it like an integer.

31
00:01:26,995 --> 00:01:30,440
Like integer 27 is a constructor for an integer.

32
00:01:30,440 --> 00:01:31,994
So, you just write down 27,

33
00:01:31,994 --> 00:01:34,265
doesn't take any arguments, it just is.

34
00:01:34,265 --> 00:01:36,165
Same with Rock, Scissors, Paper here.

35
00:01:36,165 --> 00:01:41,310
You just write them down, then they just are and they will all have type Contest.

36
00:01:41,310 --> 00:01:46,395
Next, we have Velocity where we have MetersPerSecond

37
00:01:46,395 --> 00:01:51,730
as a constructor that accepts a Float and FeetPerSecond that also accepts a Float.

38
00:01:51,730 --> 00:01:56,920
Now, we can interpret this as being a unit attached to this floating point number.

39
00:01:56,920 --> 00:01:58,750
So, we have two kinds of velocities.

40
00:01:58,750 --> 00:02:00,819
If I ask you to give me a velocity,

41
00:02:00,819 --> 00:02:04,280
you might say 27 but then I usually

42
00:02:04,280 --> 00:02:08,590
expect you will say 27 feet per second or 27 meters per second.

43
00:02:08,590 --> 00:02:10,850
If you wanted to make it more complicated,

44
00:02:10,850 --> 00:02:13,615
you could add miles per hour to this or something.

45
00:02:13,615 --> 00:02:15,850
The next one is a little more complicated.

46
00:02:15,850 --> 00:02:20,250
We are declaring a data type called List and you see this a after it,

47
00:02:20,250 --> 00:02:23,610
this lower case a, that's a type parameter.

48
00:02:23,610 --> 00:02:27,120
So, we say we have a list of something called a.

49
00:02:27,120 --> 00:02:28,180
We don't know what a is,

50
00:02:28,180 --> 00:02:33,365
but we are going to insist that a be the same for everything in the structure.

51
00:02:33,365 --> 00:02:36,630
So, the first constructor is called Cons.

52
00:02:36,630 --> 00:02:40,310
It's a historical name from Lisp from over 60 years ago now.

53
00:02:40,310 --> 00:02:44,340
It stands for construct and basically builds a linked list node.

54
00:02:44,340 --> 00:02:46,340
So Cons takes two arguments.

55
00:02:46,340 --> 00:02:48,395
The first is the a.

56
00:02:48,395 --> 00:02:51,215
So, it could be an integer, could be a float.

57
00:02:51,215 --> 00:02:56,155
Second argument is another list of the same with the same type of parameter.

58
00:02:56,155 --> 00:03:00,405
Now, maybe you have seen generics in Java or templates in C++.

59
00:03:00,405 --> 00:03:02,000
This is the same kind of thing here.

60
00:03:02,000 --> 00:03:04,480
It's called Parametric Polymorphism.

61
00:03:04,480 --> 00:03:07,345
You are going to see this quite a bit in the course.

62
00:03:07,345 --> 00:03:10,250
Now, in order to provide a base case for this type.

63
00:03:10,250 --> 00:03:12,620
You notice this type is recursive.

64
00:03:12,620 --> 00:03:14,055
We need another constructor.

65
00:03:14,055 --> 00:03:17,415
So, we have Nil and that represents the empty list.

66
00:03:17,415 --> 00:03:19,280
Next on line six and seven,

67
00:03:19,280 --> 00:03:21,080
we have a data type called Tree,

68
00:03:21,080 --> 00:03:24,190
also taking a type parameter and there's two kinds of trees.

69
00:03:24,190 --> 00:03:27,770
There's nodes which have a piece of data and then two sub-trees.

70
00:03:27,770 --> 00:03:30,535
You can think of that as a left sub-tree and a right sub-tree,

71
00:03:30,535 --> 00:03:33,770
or it could be an empty tree with no data at all.

72
00:03:33,770 --> 00:03:37,345
So, let's look at how we can write programs that use this.

73
00:03:37,345 --> 00:03:40,070
So, I think you have probably heard of the rock, scissors,

74
00:03:40,070 --> 00:03:42,180
paper game where rock beats scissors,

75
00:03:42,180 --> 00:03:44,330
scissors beats paper, and paper beats rock.

76
00:03:44,330 --> 00:03:46,930
Two players say shake their fists and then they,

77
00:03:46,930 --> 00:03:48,110
on the count of three,

78
00:03:48,110 --> 00:03:50,015
they each pick one or the other.

79
00:03:50,015 --> 00:03:52,360
Well, so maybe that's too hard for us to figure out.

80
00:03:52,360 --> 00:03:54,360
So, let's write a Haskell program to do it for us.

81
00:03:54,360 --> 00:03:58,180
So, here we are going to have the winner for the first three of them.

82
00:03:58,180 --> 00:04:00,470
The first parameter beats a second parameter,

83
00:04:00,470 --> 00:04:02,820
so we are just going to return player one.

84
00:04:02,820 --> 00:04:04,630
Then four through six,

85
00:04:04,630 --> 00:04:07,440
the second parameter beats the first parameter,

86
00:04:07,440 --> 00:04:09,545
so we will return player two.

87
00:04:09,545 --> 00:04:11,625
And then line seven,

88
00:04:11,625 --> 00:04:13,020
you see we have these underscores.

89
00:04:13,020 --> 00:04:16,280
There are three more cases and all of them return Tie and we

90
00:04:16,280 --> 00:04:19,580
don't really care what the elements are at that point.

91
00:04:19,580 --> 00:04:22,870
The ones that we have already looked at had been the interesting cases,

92
00:04:22,870 --> 00:04:24,555
everything else is going to be a tie.

93
00:04:24,555 --> 00:04:25,930
So, we are not going to bother

94
00:04:25,930 --> 00:04:28,500
pattern matching against that or storing that in a variable.

95
00:04:28,500 --> 00:04:30,305
We are just going to throw away

96
00:04:30,305 --> 00:04:33,985
the parameters because you already know what's going to happen at this point.

97
00:04:33,985 --> 00:04:39,935
Lines 9 and 10, let's write a function that computes thrust for one kilogram.

98
00:04:39,935 --> 00:04:42,800
You want it to reach a certain speed.

99
00:04:42,800 --> 00:04:44,595
Here, we are using pattern matching,

100
00:04:44,595 --> 00:04:48,890
so feet per second to meters per second, both have parameters.

101
00:04:48,890 --> 00:04:50,280
They have that float parameter.

102
00:04:50,280 --> 00:04:51,370
So, you see here,

103
00:04:51,370 --> 00:04:54,240
we put parentheses around FeetPerSecond and an x.

104
00:04:54,240 --> 00:04:58,095
So, when you pass in a velocity to thrust,

105
00:04:58,095 --> 00:05:02,180
it's going to check which one of these two kinds of velocities you have and

106
00:05:02,180 --> 00:05:07,225
then extract out the floating point information and put that into the variable x.

107
00:05:07,225 --> 00:05:08,610
If you had a feet per second,

108
00:05:08,610 --> 00:05:09,975
it's going to take the clause,

109
00:05:09,975 --> 00:05:13,380
the first one on line nine and then divide that by 3.28.

110
00:05:13,380 --> 00:05:16,080
The proper number in Newton's and then in 10,

111
00:05:16,080 --> 00:05:17,360
we already have it in Newtons,

112
00:05:17,360 --> 00:05:18,670
so we just return it.

113
00:05:18,670 --> 00:05:25,310
So, being able to have a number and tag it with the proper unit is a very nice thing.

114
00:05:25,310 --> 00:05:29,240
We have actually lost spacecraft because the computers they had

115
00:05:29,240 --> 00:05:33,580
didn't have this and the number was communicated and units were confused.

116
00:05:33,580 --> 00:05:35,695
Haskell can save your space program.

117
00:05:35,695 --> 00:05:37,335
That's the motto here.

118
00:05:37,335 --> 00:05:40,010
So, a lot of these data types we are going to

119
00:05:40,010 --> 00:05:42,320
define in this course are going to be recursive

120
00:05:42,320 --> 00:05:47,405
because they are going to represent programming languages, programs in them.

121
00:05:47,405 --> 00:05:50,230
So, it's important that you be comfortable with this.

122
00:05:50,230 --> 00:05:51,650
So, here we are going to define

123
00:05:51,650 --> 00:05:55,430
our very own linked list and we are not going to bother with a type parameter this time.

124
00:05:55,430 --> 00:05:57,915
We are just going to say it's a list of ints.

125
00:05:57,915 --> 00:06:01,170
So, we have data List, we have Cons.

126
00:06:01,170 --> 00:06:02,495
The first parameter is a Int,

127
00:06:02,495 --> 00:06:03,995
the next one is another List,

128
00:06:03,995 --> 00:06:05,950
the other constructor is Nil.

129
00:06:05,950 --> 00:06:08,810
Again, we have this deriving shows so that we can print

130
00:06:08,810 --> 00:06:11,600
it out when we are interacting with this in the REPL.

131
00:06:11,600 --> 00:06:15,415
And I am going to write this insertSorted function.

132
00:06:15,415 --> 00:06:21,700
So, insertSorted takes a variable a and if we insert that into a Nil,

133
00:06:21,700 --> 00:06:23,215
that's on line four,

134
00:06:23,215 --> 00:06:25,630
then what I want to do is return Cons a Nil.

135
00:06:25,630 --> 00:06:28,190
So, I just write down the constructor and I write

136
00:06:28,190 --> 00:06:31,470
down the parameters I want to place into it.

137
00:06:31,470 --> 00:06:34,080
Next on five through seven,

138
00:06:34,080 --> 00:06:38,075
I am inserting a into a list that has two parts.

139
00:06:38,075 --> 00:06:41,080
b is the first element and bs is another list.

140
00:06:41,080 --> 00:06:44,990
You think it's following a pointer to the next elements of the list.

141
00:06:44,990 --> 00:06:49,350
If a is smaller than b then we have found the correct spot in the list.

142
00:06:49,350 --> 00:06:53,135
So, we return Cons a and then Cons b bs.

143
00:06:53,135 --> 00:06:59,060
Otherwise, what we are going to do is the b comes before the a in this list.

144
00:06:59,060 --> 00:07:01,500
So, we are going to say Cons b and then we are going to call

145
00:07:01,500 --> 00:07:06,040
insertSorted on a and bs to keep it going down the line.

146
00:07:06,040 --> 00:07:08,390
So, here you see an example of it running.

147
00:07:08,390 --> 00:07:12,080
So, I say let l1 equal insertSorted 3,

148
00:07:12,080 --> 00:07:13,420
Cons 2, Cons 4,

149
00:07:13,420 --> 00:07:20,410
Nil and then if I print out l1 then you see that the 2 then comes before the 3.

150
00:07:20,410 --> 00:07:22,594
It's put the 3 in the correct location.

151
00:07:22,594 --> 00:07:26,590
So, I encourage you to pause this and type this in and try it out.

152
00:07:26,590 --> 00:07:29,205
Make sure that you understand how it works.

153
00:07:29,205 --> 00:07:33,100
Now, one thing you really need to understand about how Haskell

154
00:07:33,100 --> 00:07:37,480
works is how memory is allocated when we do these things.

155
00:07:37,480 --> 00:07:42,785
Now, we have mentioned before that data types in Haskell are persistent, are immutable.

156
00:07:42,785 --> 00:07:45,320
Once something has been allocated in memory,

157
00:07:45,320 --> 00:07:47,355
that memory does not change.

158
00:07:47,355 --> 00:07:48,690
You cannot update it.

159
00:07:48,690 --> 00:07:51,485
It can go out of scope and be collected and reused,

160
00:07:51,485 --> 00:07:54,530
but as long as something has access to that data,

161
00:07:54,530 --> 00:07:59,660
it persists and this may seem very strange to you if you are not used to this paradigm

162
00:07:59,660 --> 00:08:01,984
but it has a lot of major advantages

163
00:08:01,984 --> 00:08:05,380
which you will see more of as we go through the course.

164
00:08:05,380 --> 00:08:06,960
So, here are the rules.

165
00:08:06,960 --> 00:08:11,810
If I write down a constructor like an integer or an empty list or

166
00:08:11,810 --> 00:08:18,025
a constructor like one we have defined, that allocates memory.

167
00:08:18,025 --> 00:08:20,725
So, line one I say x equal 4,

168
00:08:20,725 --> 00:08:23,040
you can see on the bottom there's a memory diagram.

169
00:08:23,040 --> 00:08:24,660
There's an x.

170
00:08:24,660 --> 00:08:27,380
So I put a little box with a 4 in it to represent

171
00:08:27,380 --> 00:08:30,440
that there's some memory that x is attached to.

172
00:08:30,440 --> 00:08:33,445
Line two, I say n is equal to the empty list.

173
00:08:33,445 --> 00:08:35,995
And so we put a box there.

174
00:08:35,995 --> 00:08:39,860
Line three though, if I say n2 equal n. So,

175
00:08:39,860 --> 00:08:41,685
all I have done is reference another variable,

176
00:08:41,685 --> 00:08:43,530
that does not allocate memory.

177
00:08:43,530 --> 00:08:46,600
What that does is make n2 and n point to the same thing.

178
00:08:46,600 --> 00:08:50,645
Now, this is safe because we know that n can never be changed.

179
00:08:50,645 --> 00:08:52,960
So, it's perfectly okay to say

180
00:08:52,960 --> 00:08:56,740
the n2 and n are actually aliases for the same memory address.

181
00:08:56,740 --> 00:08:59,945
Now, if I say l is equal to x:n,

182
00:08:59,945 --> 00:09:02,690
that's a built-in list notation, remember.

183
00:09:02,690 --> 00:09:05,495
Then l is going to point to this list node.

184
00:09:05,495 --> 00:09:07,770
The first part is going to point to x.

185
00:09:07,770 --> 00:09:10,625
The second part is going to point to this empty thing.

186
00:09:10,625 --> 00:09:14,630
Now, I should give you a disclaimer that Haskell has a lot of

187
00:09:14,630 --> 00:09:18,990
optimizations going on underneath the hood that are beyond the scope of this course.

188
00:09:18,990 --> 00:09:21,350
So, it might actually put the x,

189
00:09:21,350 --> 00:09:22,910
it's something called Unboxing,

190
00:09:22,910 --> 00:09:27,005
it could stick that into the list node itself instead of using a pointer.

191
00:09:27,005 --> 00:09:29,220
We are not really going to talk about that too much.

192
00:09:29,220 --> 00:09:32,695
So, this memory model is perfect for what we are doing.

193
00:09:32,695 --> 00:09:36,565
Now, I want you to see this was using the built-in types.

194
00:09:36,565 --> 00:09:40,300
If we use our own types like the Nil and the Cons that

195
00:09:40,300 --> 00:09:43,790
we defined and write the same code but using that,

196
00:09:43,790 --> 00:09:45,610
then the memory diagram looks identical.

197
00:09:45,610 --> 00:09:48,110
So, again whenever you write down a constructor,

198
00:09:48,110 --> 00:09:51,255
like on lines two and one and four,

199
00:09:51,255 --> 00:09:54,890
memory is allocated to store the thing that you wrote down.

200
00:09:54,890 --> 00:09:58,220
But if you just write down the name of a variable,

201
00:09:58,220 --> 00:10:02,575
all you get is a pointer that goes to that variable.

202
00:10:02,575 --> 00:10:07,205
So, again, we have this concept of parametric polymorphism.

203
00:10:07,205 --> 00:10:09,115
We have seen it with templates and C++,

204
00:10:09,115 --> 00:10:10,610
or generics in Java.

205
00:10:10,610 --> 00:10:12,140
What that allows us to do is say,

206
00:10:12,140 --> 00:10:14,700
we want to have a list of integers.

207
00:10:14,700 --> 00:10:17,350
So, x1 we say Cons 1,

208
00:10:17,350 --> 00:10:19,100
Cons 2, Cons 4 Nil.

209
00:10:19,100 --> 00:10:22,330
If you take the type, it will tell you it's List Int,

210
00:10:22,330 --> 00:10:24,430
just the way it will display that,

211
00:10:24,430 --> 00:10:27,380
to a list of integers is usually how we read that.

212
00:10:27,380 --> 00:10:28,680
If we put in strings,

213
00:10:28,680 --> 00:10:30,610
it will say List String or maybe list,

214
00:10:30,610 --> 00:10:34,290
list of character and we can have even lists of list, right?

215
00:10:34,290 --> 00:10:35,820
So, here in x3,

216
00:10:35,820 --> 00:10:38,250
this is a List of List Int.

217
00:10:38,250 --> 00:10:42,865
It's kind of complicated but you can nest these as much as you want.

218
00:10:42,865 --> 00:10:46,430
In our next video, we are going to go over a few examples.

219
00:10:46,430 --> 00:10:47,705
I am going to show you how to write

220
00:10:47,705 --> 00:10:51,290
binary search trees and add into them and also going to

221
00:10:51,290 --> 00:10:57,760
go over two very important data types called Maybe and Either.