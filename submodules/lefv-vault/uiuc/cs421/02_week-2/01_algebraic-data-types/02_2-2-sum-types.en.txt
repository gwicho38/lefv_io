Hello, everyone. Welcome back. In this video we are going to talk about Sum Types, the second of the algebraic data types. So, your objectives are, of course, knowing the syntax and being able to declare these disjoint data types and using them to represent lists and expressions and exceptions. There are a couple of these disjoint data types that are used very commonly in Haskell. The Maybe, the List and the Either data types. So, you want to be able to understand those, be able use them in a program, because they are going to come up in class quite a bit. Also, we are going to show you an example of using disjoint data type to represent arithmetic. So, you can actually build a tree that represents some kind of arithmetic operation, with the pluses and times and whatnot and then write a function to evaluate them. So, here's a syntax. We use a data keyword as before and then after that, you have the name of the type that you want to declare. Then there's an equal sign and then there is, more than one usually, constructor and the constructors could take arguments, sometimes they don't, and sometimes also these constructors can have type parameters. So, let's look at these examples. So, the first one we have data Contest. So, Contest is the name of the type and there's three constructors, none of them which take any arguments, so we have Rock, Scissors and Paper. So, if you call these without arguments, they create something of this type. So, think of it like an integer. Like integer 27 is a constructor for an integer. So, you just write down 27, doesn't take any arguments, it just is. Same with Rock, Scissors, Paper here. You just write them down, then they just are and they will all have type Contest. Next, we have Velocity where we have MetersPerSecond as a constructor that accepts a Float and FeetPerSecond that also accepts a Float. Now, we can interpret this as being a unit attached to this floating point number. So, we have two kinds of velocities. If I ask you to give me a velocity, you might say 27 but then I usually expect you will say 27 feet per second or 27 meters per second. If you wanted to make it more complicated, you could add miles per hour to this or something. The next one is a little more complicated. We are declaring a data type called List and you see this a after it, this lower case a, that's a type parameter. So, we say we have a list of something called a. We don't know what a is, but we are going to insist that a be the same for everything in the structure. So, the first constructor is called Cons. It's a historical name from Lisp from over 60 years ago now. It stands for construct and basically builds a linked list node. So Cons takes two arguments. The first is the a. So, it could be an integer, could be a float. Second argument is another list of the same with the same type of parameter. Now, maybe you have seen generics in Java or templates in C++. This is the same kind of thing here. It's called Parametric Polymorphism. You are going to see this quite a bit in the course. Now, in order to provide a base case for this type. You notice this type is recursive. We need another constructor. So, we have Nil and that represents the empty list. Next on line six and seven, we have a data type called Tree, also taking a type parameter and there's two kinds of trees. There's nodes which have a piece of data and then two sub-trees. You can think of that as a left sub-tree and a right sub-tree, or it could be an empty tree with no data at all. So, let's look at how we can write programs that use this. So, I think you have probably heard of the rock, scissors, paper game where rock beats scissors, scissors beats paper, and paper beats rock. Two players say shake their fists and then they, on the count of three, they each pick one or the other. Well, so maybe that's too hard for us to figure out. So, let's write a Haskell program to do it for us. So, here we are going to have the winner for the first three of them. The first parameter beats a second parameter, so we are just going to return player one. Then four through six, the second parameter beats the first parameter, so we will return player two. And then line seven, you see we have these underscores. There are three more cases and all of them return Tie and we don't really care what the elements are at that point. The ones that we have already looked at had been the interesting cases, everything else is going to be a tie. So, we are not going to bother pattern matching against that or storing that in a variable. We are just going to throw away the parameters because you already know what's going to happen at this point. Lines 9 and 10, let's write a function that computes thrust for one kilogram. You want it to reach a certain speed. Here, we are using pattern matching, so feet per second to meters per second, both have parameters. They have that float parameter. So, you see here, we put parentheses around FeetPerSecond and an x. So, when you pass in a velocity to thrust, it's going to check which one of these two kinds of velocities you have and then extract out the floating point information and put that into the variable x. If you had a feet per second, it's going to take the clause, the first one on line nine and then divide that by 3.28. The proper number in Newton's and then in 10, we already have it in Newtons, so we just return it. So, being able to have a number and tag it with the proper unit is a very nice thing. We have actually lost spacecraft because the computers they had didn't have this and the number was communicated and units were confused. Haskell can save your space program. That's the motto here. So, a lot of these data types we are going to define in this course are going to be recursive because they are going to represent programming languages, programs in them. So, it's important that you be comfortable with this. So, here we are going to define our very own linked list and we are not going to bother with a type parameter this time. We are just going to say it's a list of ints. So, we have data List, we have Cons. The first parameter is a Int, the next one is another List, the other constructor is Nil. Again, we have this deriving shows so that we can print it out when we are interacting with this in the REPL. And I am going to write this insertSorted function. So, insertSorted takes a variable a and if we insert that into a Nil, that's on line four, then what I want to do is return Cons a Nil. So, I just write down the constructor and I write down the parameters I want to place into it. Next on five through seven, I am inserting a into a list that has two parts. b is the first element and bs is another list. You think it's following a pointer to the next elements of the list. If a is smaller than b then we have found the correct spot in the list. So, we return Cons a and then Cons b bs. Otherwise, what we are going to do is the b comes before the a in this list. So, we are going to say Cons b and then we are going to call insertSorted on a and bs to keep it going down the line. So, here you see an example of it running. So, I say let l1 equal insertSorted 3, Cons 2, Cons 4, Nil and then if I print out l1 then you see that the 2 then comes before the 3. It's put the 3 in the correct location. So, I encourage you to pause this and type this in and try it out. Make sure that you understand how it works. Now, one thing you really need to understand about how Haskell works is how memory is allocated when we do these things. Now, we have mentioned before that data types in Haskell are persistent, are immutable. Once something has been allocated in memory, that memory does not change. You cannot update it. It can go out of scope and be collected and reused, but as long as something has access to that data, it persists and this may seem very strange to you if you are not used to this paradigm but it has a lot of major advantages which you will see more of as we go through the course. So, here are the rules. If I write down a constructor like an integer or an empty list or a constructor like one we have defined, that allocates memory. So, line one I say x equal 4, you can see on the bottom there's a memory diagram. There's an x. So I put a little box with a 4 in it to represent that there's some memory that x is attached to. Line two, I say n is equal to the empty list. And so we put a box there. Line three though, if I say n2 equal n. So, all I have done is reference another variable, that does not allocate memory. What that does is make n2 and n point to the same thing. Now, this is safe because we know that n can never be changed. So, it's perfectly okay to say the n2 and n are actually aliases for the same memory address. Now, if I say l is equal to x:n, that's a built-in list notation, remember. Then l is going to point to this list node. The first part is going to point to x. The second part is going to point to this empty thing. Now, I should give you a disclaimer that Haskell has a lot of optimizations going on underneath the hood that are beyond the scope of this course. So, it might actually put the x, it's something called Unboxing, it could stick that into the list node itself instead of using a pointer. We are not really going to talk about that too much. So, this memory model is perfect for what we are doing. Now, I want you to see this was using the built-in types. If we use our own types like the Nil and the Cons that we defined and write the same code but using that, then the memory diagram looks identical. So, again whenever you write down a constructor, like on lines two and one and four, memory is allocated to store the thing that you wrote down. But if you just write down the name of a variable, all you get is a pointer that goes to that variable. So, again, we have this concept of parametric polymorphism. We have seen it with templates and C++, or generics in Java. What that allows us to do is say, we want to have a list of integers. So, x1 we say Cons 1, Cons 2, Cons 4 Nil. If you take the type, it will tell you it's List Int, just the way it will display that, to a list of integers is usually how we read that. If we put in strings, it will say List String or maybe list, list of character and we can have even lists of list, right? So, here in x3, this is a List of List Int. It's kind of complicated but you can nest these as much as you want. In our next video, we are going to go over a few examples. I am going to show you how to write binary search trees and add into them and also going to go over two very important data types called Maybe and Either.