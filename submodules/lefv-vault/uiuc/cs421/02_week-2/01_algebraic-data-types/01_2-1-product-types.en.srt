1
00:00:00,320 --> 00:00:03,225
Hello everyone and welcome back.

2
00:00:03,225 --> 00:00:05,130
In this couple of lectures,

3
00:00:05,130 --> 00:00:06,540
we're going to talk
about defining

4
00:00:06,540 --> 00:00:08,264
your own types in Haskell.

5
00:00:08,264 --> 00:00:10,005
It really makes it a much

6
00:00:10,005 --> 00:00:12,420
more useful language
when you can do that.

7
00:00:12,420 --> 00:00:15,030
There's two ways
to do this, well,

8
00:00:15,030 --> 00:00:18,255
there is called product types
and a called sum types.

9
00:00:18,255 --> 00:00:21,030
In this video, we're going
to talk about product types.

10
00:00:21,030 --> 00:00:22,620
Now these are both a class or

11
00:00:22,620 --> 00:00:24,390
something we call
algebraic data types,

12
00:00:24,390 --> 00:00:27,210
which is just a fancy way
of saying that we take

13
00:00:27,210 --> 00:00:31,380
other types and we combine
them together in various ways.

14
00:00:31,380 --> 00:00:33,495
So the product types,

15
00:00:33,495 --> 00:00:37,965
usually include things like
tuples or pairs, and records.

16
00:00:37,965 --> 00:00:39,510
So you think things
like coordinate

17
00:00:39,510 --> 00:00:41,505
pairs or Cartesian coordinates,

18
00:00:41,505 --> 00:00:43,810
or records like lines
from a database.

19
00:00:43,810 --> 00:00:47,080
These are all usually
considered product types.

20
00:00:47,080 --> 00:00:49,830
Sum types are a little
bit more complicated.

21
00:00:49,830 --> 00:00:52,300
We'll do that in the next video.

22
00:00:52,520 --> 00:00:54,745
So your objectives.

23
00:00:54,745 --> 00:00:57,320
You want to be able to explain
what a product type is,

24
00:00:57,320 --> 00:00:59,630
and you also want to be
able to use pairs and

25
00:00:59,630 --> 00:01:01,910
records with Haskell syntax to

26
00:01:01,910 --> 00:01:04,040
model a few different
data structures like

27
00:01:04,040 --> 00:01:07,410
dictionaries and database,
and complex numbers.

28
00:01:08,770 --> 00:01:11,810
So as I said earlier,
there are two kinds

29
00:01:11,810 --> 00:01:14,480
of product types
that we will use.

30
00:01:14,480 --> 00:01:16,385
The first one is called a tuple.

31
00:01:16,385 --> 00:01:18,515
So a tuple or an n-tuple,

32
00:01:18,515 --> 00:01:21,425
it's an order collection of
elements, the order counts.

33
00:01:21,425 --> 00:01:24,725
If n is equal to 2 it's
usually called a pair.

34
00:01:24,725 --> 00:01:27,770
So here's some syntax for you
to show you how it works.

35
00:01:27,770 --> 00:01:29,810
So in lines 1 and 2,
I defined variables

36
00:01:29,810 --> 00:01:32,285
x and y. X is an integer,

37
00:01:32,285 --> 00:01:35,075
10, y is a string "Hi".

38
00:01:35,075 --> 00:01:37,310
I can look at the types with the

39
00:01:37,310 --> 00:01:39,620
:t. Now one thing you'll notice

40
00:01:39,620 --> 00:01:44,600
with the type of y is said
to be a list of characters.

41
00:01:44,600 --> 00:01:47,000
The default setting
for Haskell is

42
00:01:47,000 --> 00:01:49,330
that that's how strings
are represented.

43
00:01:49,330 --> 00:01:53,220
There are other string
representations

44
00:01:53,220 --> 00:01:54,590
that Haskell has that are more

45
00:01:54,590 --> 00:01:56,630
efficient in certain
circumstances,

46
00:01:56,630 --> 00:01:58,880
but that's beyond the
scope of our course so

47
00:01:58,880 --> 00:02:00,980
we're not going to
worry about those.

48
00:02:00,980 --> 00:02:04,240
But you might see that if you
look at other Haskell code.

49
00:02:04,240 --> 00:02:06,870
Anyway, the magic comes in line

50
00:02:06,870 --> 00:02:09,440
7 when we actually define a pair.

51
00:02:09,440 --> 00:02:10,910
So we're going to set p to be

52
00:02:10,910 --> 00:02:13,265
equal to the pair of x and y.

53
00:02:13,265 --> 00:02:16,575
See the syntax, you just use
an open close parentheses,

54
00:02:16,575 --> 00:02:18,590
and you put all the elements you

55
00:02:18,590 --> 00:02:20,645
want in there
separated by commas.

56
00:02:20,645 --> 00:02:22,430
Now if I take the type of p,

57
00:02:22,430 --> 00:02:24,920
the type shows you
as being a pair,

58
00:02:24,920 --> 00:02:26,180
the first part's integer,

59
00:02:26,180 --> 00:02:29,074
the second part is a
list of characters.

60
00:02:29,074 --> 00:02:31,744
Now if you come from
other languages,

61
00:02:31,744 --> 00:02:33,380
it's a toss-up whether

62
00:02:33,380 --> 00:02:36,050
these things are built
into the language or not.

63
00:02:36,050 --> 00:02:38,240
Pretty much every
language has some kind of

64
00:02:38,240 --> 00:02:40,820
support for doing
something like this.

65
00:02:40,820 --> 00:02:43,115
C++, for instance,

66
00:02:43,115 --> 00:02:45,740
doesn't have pairs as
part of the basic syntax.

67
00:02:45,740 --> 00:02:47,600
But the standard template library

68
00:02:47,600 --> 00:02:49,640
define things that work for this.

69
00:02:49,640 --> 00:02:54,795
Some languages use vectors to
handle this sort of thing.

70
00:02:54,795 --> 00:02:58,690
Languages like Python
have pairs built in.

71
00:02:59,590 --> 00:03:02,900
So Haskell gives you a few
functions to work with

72
00:03:02,900 --> 00:03:06,095
pairs directly because
they're so common.

73
00:03:06,095 --> 00:03:08,629
The main two are
first and second,

74
00:03:08,629 --> 00:03:11,360
which take the first element
or the second element.

75
00:03:11,360 --> 00:03:15,050
Now these functions
only work with pairs.

76
00:03:15,050 --> 00:03:17,645
If you have a tuple with
three or five or whatever,

77
00:03:17,645 --> 00:03:19,220
these functions don't
work with that,

78
00:03:19,220 --> 00:03:20,860
you're going to have
to write your own.

79
00:03:20,860 --> 00:03:23,370
So here's just an example,
if I take first of p,

80
00:03:23,370 --> 00:03:25,230
I get the 10, if I
take second of p,

81
00:03:25,230 --> 00:03:27,280
I get the "hi" back.

82
00:03:29,840 --> 00:03:32,090
Now tuples are fun

83
00:03:32,090 --> 00:03:34,000
because you can put

84
00:03:34,000 --> 00:03:35,810
a pretty much anything
you want in them.

85
00:03:35,810 --> 00:03:39,115
So here I'm going to
define a variable p4.

86
00:03:39,115 --> 00:03:42,240
The first part's going
to be 10 of integer,

87
00:03:42,240 --> 00:03:44,960
the second is a string,
the third is a function.

88
00:03:44,960 --> 00:03:47,010
Remember we talked about
higher order functions,

89
00:03:47,010 --> 00:03:48,724
they're first class citizens,

90
00:03:48,724 --> 00:03:50,630
so we can just put one in there.

91
00:03:50,630 --> 00:03:53,995
Then the last element is
going to be another tuple.

92
00:03:53,995 --> 00:03:56,160
If we take the type of p4,

93
00:03:56,160 --> 00:03:59,100
we get a fairly
complicated type back.

94
00:04:03,170 --> 00:04:05,755
Now let's do an
example with these.

95
00:04:05,755 --> 00:04:08,960
Let's try to implement
complex numbers.

96
00:04:08,960 --> 00:04:11,165
Now you probably remember,

97
00:04:11,165 --> 00:04:12,710
and if you don't,
don't worry about it,

98
00:04:12,710 --> 00:04:15,030
it's not that important

99
00:04:15,030 --> 00:04:17,050
for our course, it's
just an example.

100
00:04:17,050 --> 00:04:18,920
We can pretend that take

101
00:04:18,920 --> 00:04:20,780
the square root of minus
1 and call that i,

102
00:04:20,780 --> 00:04:24,440
and any multiple of that is
called an imaginary number.

103
00:04:24,440 --> 00:04:26,990
So you have a plus bi,

104
00:04:26,990 --> 00:04:30,530
numbers of that form are
called complex numbers.

105
00:04:30,530 --> 00:04:32,300
If you think about what

106
00:04:32,300 --> 00:04:35,440
the properties of the square
root of minus 1 would be,

107
00:04:35,440 --> 00:04:38,720
you can quickly derive
that addition and

108
00:04:38,720 --> 00:04:41,360
multiplication would follow
these mathematical formula

109
00:04:41,360 --> 00:04:43,120
that you see up here.

110
00:04:43,120 --> 00:04:45,290
So in Haskell, if we want to use

111
00:04:45,290 --> 00:04:47,240
tuples to implement this,

112
00:04:47,240 --> 00:04:48,830
then we can say that

113
00:04:48,830 --> 00:04:51,035
the first element of the
pair is a real part,

114
00:04:51,035 --> 00:04:54,500
and the second element of the
pair is the imaginary part.

115
00:04:54,500 --> 00:04:57,950
So we have complex add
and complex multiply.

116
00:04:57,950 --> 00:05:00,110
We can use pattern matching in

117
00:05:00,110 --> 00:05:02,120
order to deconstruct
the pairs for us,

118
00:05:02,120 --> 00:05:04,160
which saves us a lot of typing.

119
00:05:04,160 --> 00:05:06,550
Then the output is just
going to be another tuple,

120
00:05:06,550 --> 00:05:08,210
where we combine the elements

121
00:05:08,210 --> 00:05:11,100
as in the mathematics above.

122
00:05:11,350 --> 00:05:13,610
Now this works pretty well

123
00:05:13,610 --> 00:05:15,815
and if you're writing
something small,

124
00:05:15,815 --> 00:05:17,750
and you're not going to be

125
00:05:17,750 --> 00:05:19,805
sharing that with
too many people,

126
00:05:19,805 --> 00:05:22,550
this is a pretty reasonable
way to go about it.

127
00:05:22,550 --> 00:05:26,359
But if you're going to make a
library of complex numbers,

128
00:05:26,359 --> 00:05:28,855
then this is probably
not a good idea.

129
00:05:28,855 --> 00:05:31,870
The reason for that is that,

130
00:05:31,870 --> 00:05:33,830
while we can certainly use

131
00:05:33,830 --> 00:05:36,275
tuples to represent
complex numbers,

132
00:05:36,275 --> 00:05:38,750
these functions they
take any tuple at all.

133
00:05:38,750 --> 00:05:41,870
Not every tuple can
be a complex number,

134
00:05:41,870 --> 00:05:45,085
but there's nothing to
distinguish that here.

135
00:05:45,085 --> 00:05:47,930
There are other ways
of communicating

136
00:05:47,930 --> 00:05:50,030
to the compiler what
our intentions are,

137
00:05:50,030 --> 00:05:52,285
so that the compiler
can give us more help.

138
00:05:52,285 --> 00:05:54,605
For that, we're going
to need the other kind

139
00:05:54,605 --> 00:05:57,720
of product type called a record.

140
00:06:00,810 --> 00:06:04,120
So here's how to define a record.

141
00:06:04,120 --> 00:06:05,995
You have a keyword called data,

142
00:06:05,995 --> 00:06:09,865
and then you have the
name of the type complex.

143
00:06:09,865 --> 00:06:11,680
Then we have the equal sign,

144
00:06:11,680 --> 00:06:13,600
then we have a constructor,

145
00:06:13,600 --> 00:06:15,490
which in this case happens to

146
00:06:15,490 --> 00:06:17,335
be the same name as the type.

147
00:06:17,335 --> 00:06:20,140
This is something you'll
see quite often in Haskell.

148
00:06:20,140 --> 00:06:23,440
After that, you're going to
have curly braces and then

149
00:06:23,440 --> 00:06:27,130
the names of all the fields
with their associated types.

150
00:06:27,130 --> 00:06:30,355
So here we have
complex as two fields,

151
00:06:30,355 --> 00:06:32,290
re for real, which
has type Float,

152
00:06:32,290 --> 00:06:34,600
and im, which also
has type Float.

153
00:06:34,600 --> 00:06:37,000
So now the fields have names,

154
00:06:37,000 --> 00:06:40,180
so it gives us a little
bit more flexibility.

155
00:06:40,180 --> 00:06:44,780
Now in line 2, you'll see
this thing deriving Show,Eq.

156
00:06:44,970 --> 00:06:47,770
We're not going to explain
that too much right now,

157
00:06:47,770 --> 00:06:50,020
except just to say that if

158
00:06:50,020 --> 00:06:52,420
you define your own
type like this,

159
00:06:52,420 --> 00:06:56,770
Haskell by default will
not print it out for you.

160
00:06:56,770 --> 00:06:58,135
If you try to print it,

161
00:06:58,135 --> 00:07:00,370
you have to define a
function called show,

162
00:07:00,370 --> 00:07:03,190
which tells it how to
convert these to strings.

163
00:07:03,190 --> 00:07:06,730
Now this deriving thing
tells Haskell basically,

164
00:07:06,730 --> 00:07:08,680
"Look, you know how
to print this out,

165
00:07:08,680 --> 00:07:09,925
just do it for me."

166
00:07:09,925 --> 00:07:13,675
Same with the Eq, we want
equality derived for this.

167
00:07:13,675 --> 00:07:16,000
In the lecture on
type classes we'll go

168
00:07:16,000 --> 00:07:17,890
into more detail on what this is

169
00:07:17,890 --> 00:07:19,780
doing and how you
can do it yourself

170
00:07:19,780 --> 00:07:22,790
if you don't want Haskell
to do it for you.

171
00:07:22,800 --> 00:07:25,120
So you've defined
the type and now we

172
00:07:25,120 --> 00:07:26,680
want to create elements of it.

173
00:07:26,680 --> 00:07:28,540
We have two choices.

174
00:07:28,540 --> 00:07:30,310
One, you can write
down the name of

175
00:07:30,310 --> 00:07:32,169
the constructor,
which is complex,

176
00:07:32,169 --> 00:07:34,210
and then write down the values at

177
00:07:34,210 --> 00:07:35,230
the field should have in

178
00:07:35,230 --> 00:07:36,730
the order that you declared them.

179
00:07:36,730 --> 00:07:38,485
So you write down the real part,

180
00:07:38,485 --> 00:07:40,675
and then you write down
the imaginary part.

181
00:07:40,675 --> 00:07:42,970
This is the first option you see.

182
00:07:42,970 --> 00:07:44,560
The second is you could be more

183
00:07:44,560 --> 00:07:47,275
explicit and specify
the field names.

184
00:07:47,275 --> 00:07:49,465
Again, you write
down the constructor

185
00:07:49,465 --> 00:07:51,760
and then you write
down the curly braces,

186
00:07:51,760 --> 00:07:57,415
and you say re equal
10.5, im equal 34.2.

187
00:07:57,415 --> 00:08:00,310
So both of these will
do the same thing.

188
00:08:00,310 --> 00:08:03,040
Now the cool thing
is you'll see in

189
00:08:03,040 --> 00:08:06,370
the next slide is field names
actually become functions,

190
00:08:06,370 --> 00:08:10,570
which can project
out the elements

191
00:08:10,570 --> 00:08:15,830
or select out the fields
of this particular record.

192
00:08:15,930 --> 00:08:19,030
Because these become functions,

193
00:08:19,030 --> 00:08:20,980
we have a serious limitation that

194
00:08:20,980 --> 00:08:23,410
field names have to
be unique in Haskell,

195
00:08:23,410 --> 00:08:25,630
at least within the same scope.

196
00:08:25,630 --> 00:08:28,900
Haskell has an advanced
feature that you can turn on,

197
00:08:28,900 --> 00:08:34,480
which allow you to relax that
restriction a little bit,

198
00:08:34,480 --> 00:08:38,095
but we're probably not going
to do that in this course.

199
00:08:38,095 --> 00:08:40,120
So here's some examples.

200
00:08:40,120 --> 00:08:43,390
I cannot call re on
c and get 10.54,

201
00:08:43,390 --> 00:08:45,520
im on c, get 34.2.

202
00:08:45,520 --> 00:08:48,190
This is like the dot
notation in other languages.

203
00:08:48,190 --> 00:08:50,530
You can have c.re or

204
00:08:50,530 --> 00:08:53,320
c.im to do the same thing
in other languages.

205
00:08:53,320 --> 00:08:55,360
This is how we do it in Haskell.

206
00:08:55,360 --> 00:09:01,975
Having the field access or
things be actual functions,

207
00:09:01,975 --> 00:09:04,075
gives us some flexibility.

208
00:09:04,075 --> 00:09:07,850
We can use these, you're
like an argument to map.

209
00:09:08,310 --> 00:09:11,140
Maybe we have a list
of complex numbers,

210
00:09:11,140 --> 00:09:13,240
so we map re over
that list and we're

211
00:09:13,240 --> 00:09:16,120
going to get all of
the real parts back.

212
00:09:16,120 --> 00:09:20,455
Anyway now, here are the
complex number functions.

213
00:09:20,455 --> 00:09:24,895
So I have chosen to write
it out in the long format.

214
00:09:24,895 --> 00:09:27,010
You probably should too,

215
00:09:27,010 --> 00:09:28,300
if you're writing library code

216
00:09:28,300 --> 00:09:29,860
that other people
are going to read.

217
00:09:29,860 --> 00:09:31,420
If you're feeling lazy

218
00:09:31,420 --> 00:09:33,880
and you're not going to
show it to too many people,

219
00:09:33,880 --> 00:09:35,785
you could use the
shorthand notation.

220
00:09:35,785 --> 00:09:38,350
I feel like this is a
little bit easier to read,

221
00:09:38,350 --> 00:09:39,775
until a little bit
clearer and near.

222
00:09:39,775 --> 00:09:42,160
Six months later when you come
back to look at your code,

223
00:09:42,160 --> 00:09:44,660
this is going to make more sense.

224
00:09:46,590 --> 00:09:51,320
Here's another example, we
can make database records.

225
00:09:52,020 --> 00:09:55,030
We're going to create a
data type called person,

226
00:09:55,030 --> 00:09:57,310
which has a first name and
last name, and an age.

227
00:09:57,310 --> 00:09:58,780
Again, we're going
to derive to show

228
00:09:58,780 --> 00:10:01,870
an equality and I can
make a list of people.

229
00:10:01,870 --> 00:10:04,090
Here I'm going to use
the short notation just

230
00:10:04,090 --> 00:10:07,510
because it's a lot
of typing otherwise.

231
00:10:07,510 --> 00:10:08,560
So we have person,

232
00:10:08,560 --> 00:10:11,065
we have ''Bilbo''
''Baggins'' who's 111,

233
00:10:11,065 --> 00:10:13,910
and ''Harry''
''Potter'' who's 19.

234
00:10:13,950 --> 00:10:16,330
He was 19 when I
wrote these slides.

235
00:10:16,330 --> 00:10:18,320
He's older than that now.

236
00:10:22,860 --> 00:10:26,695
So here's some things I'd
like you to try doing.

237
00:10:26,695 --> 00:10:28,615
Now that you've seen this syntax,

238
00:10:28,615 --> 00:10:30,565
play with these
examples a little bit,

239
00:10:30,565 --> 00:10:34,165
and then see if you
can do things here.

240
00:10:34,165 --> 00:10:36,070
There's a sync on an
associative list,

241
00:10:36,070 --> 00:10:38,770
which is very common in
functional programming languages.

242
00:10:38,770 --> 00:10:41,860
You have a list of
pairs, and in the pair,

243
00:10:41,860 --> 00:10:44,530
the first part is a key,
the second part is a value,

244
00:10:44,530 --> 00:10:46,675
think like hash tables.

245
00:10:46,675 --> 00:10:48,490
So we could have

246
00:10:48,490 --> 00:10:51,055
this example here where
we have a phone book,

247
00:10:51,055 --> 00:10:53,575
or the "emergency" is 911,

248
00:10:53,575 --> 00:10:55,945
and "Jenni", well, that's
her famous phone number.

249
00:10:55,945 --> 00:10:58,810
So try writing a
function called add.

250
00:10:58,810 --> 00:11:00,640
I'll take a key and a value,

251
00:11:00,640 --> 00:11:02,860
and one of these
associative list and

252
00:11:02,860 --> 00:11:05,350
return a new one
with that new key,

253
00:11:05,350 --> 00:11:08,540
and add and value added into it.

254
00:11:08,540 --> 00:11:10,635
If you want to extra challenge,

255
00:11:10,635 --> 00:11:12,030
you can try to make it so that

256
00:11:12,030 --> 00:11:14,675
the key is sorted in that list.

257
00:11:14,675 --> 00:11:17,214
Then write another
function called mylookup,

258
00:11:17,214 --> 00:11:19,330
which will take a key
in associative list,

259
00:11:19,330 --> 00:11:21,490
and return the
corresponding value.

260
00:11:21,490 --> 00:11:23,890
There is a built-in
function called lookup,

261
00:11:23,890 --> 00:11:25,570
which does this already.

262
00:11:25,570 --> 00:11:27,670
So you can play
with that if you're

263
00:11:27,670 --> 00:11:30,700
wondering what exactly
I'm asking you to do.

264
00:11:30,700 --> 00:11:34,615
Then if you want
some more practice,

265
00:11:34,615 --> 00:11:38,155
then try doing a record type
with a key and value field,

266
00:11:38,155 --> 00:11:41,005
and then try writing the
functions with those.

267
00:11:41,005 --> 00:11:43,105
I'll play with that
for a little bit.

268
00:11:43,105 --> 00:11:44,860
The solutions to this will be

269
00:11:44,860 --> 00:11:46,450
posted on the course website,

270
00:11:46,450 --> 00:11:48,160
but don't pick at

271
00:11:48,160 --> 00:11:50,485
that until you've
given this a good try.

272
00:11:50,485 --> 00:11:52,705
So the next video,
we're going to talk

273
00:11:52,705 --> 00:11:56,000
about the sum types.