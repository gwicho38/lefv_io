Hello, everyone and welcome back. In our last video, we built an interpreter which is very simple. All I had was integers and arithmetic operations like plus and times, and when we ended, we asked you to think about how you go about adding Boolean style operations to it. So, connectives like 'and' and 'or' which take two Booleans to produce another Boolean and also relational operations which take an integer and return Booleans as a result. So, the first thing we're going to do as always is we're going to think about what the type should be in Haskel, the community. That's our sense of what the best practices is. Think through the types first and then start writing the code. So, here we've added three new constructors to the EXP datatype. We have RelOpExp, which is going to represent our relational operators like less than and greater than. We have BoolOpExp, which is going to represent 'and' and 'or'. We're going to have Bool expressions to represent Booleans themselves because we're going to need those to get started. Also, in val, we need to have BoolVal because some of our results will be Boolean and that's how we're going to represent those. Now, to get started, let's do BoolOps first, 'and' and 'or' because it's a little bit simpler. So, we're going to need a dictionary that takes the strings and maps them into their corresponding Boolean operations and this is going to look just like the ones we did in the last video where we had plus and times mapping to the Haskell equivalence. Only, we have to creating a dictionary because the types of these are different. So, we can't just mix them together. It's just a little unfortunate. There are some convoluted ways around that, but they're beyond the scope of what we're going to do in this course. We have our lifting operation as before, where we take a Haskell function F, and then take two Boolean values with i1 and i2 in them, extracting those out, feed those to F and then wrapping the result back into a new BoolVal. For Eval, we have two things we need to evaluate. We need to evaluate Boolean expressions and create Boolean values out of it and this is just like the integer expression being evaluated into an integer value before. Finally, we have a BoolOpExp. So, we have our operation. We have e1 and e2, and the first thing we want to do is evaluate e1 and e2 to get our corresponding v1 and v2. Then we're going to lookup the operation in our boolup's dictionary to get F. Then finally, we're going to lift F and feed it as v1 and v2 to get our final result. So, that looks very similar to the integer operation expression that we evaluated in the last time. There are six relational operations that we care about this time, here they are. Just like the last one, we have built this dictionary with them. We have a lifting function to take these operators and apply to integers to that and get a corresponding Boolean value. Then the eval, the code looks very similar. So, now that we've done that, it's time to add some variables to our language. The way we're going to do that is we're going to rely exclusively on let expressions. So, we have an example here where we have this let x equal two plus three and x times x, rather than doing it the Haskell label where we use indentation. The parses for that are a little bit trickier to write. So, we're going to have a keyword 'end' that tells us when the let expression or the body of the let expression has ended. So, here in this let expression, we are defining a variable x. We're setting it to the value two plus three. So, that needs to be evaluated till it's five, and then we're going to evaluate the body of the let, and it's x times x. Inside this body, x is going to have value five. So, that, of course, is going to turn into the value 25, which is then going to be added to the three to get 28. To update the expression type, we need two things. First, we need variables. So, we have a VarExp which takes a string parameter and we have a LetExp for the let expression which takes the three parameters. The string contains the name of the variable, the first exp is the initial value of that and the second exp is the body of the let. Now, we get to write Eval now that we have our typeset. So, to evaluate a VarExp, we finally get to use this E and V parameter that we've been parsing around a lot. We're going to lookup var in side of E and V. Now, remember E and V is just the list of ordered pairs. The first part of the pair is a string. The second part is the value. So, we're going to call lookup on that and it's just going to compare a var to everything until it finds what we're looking for. If it finds it, we have line three with just val, and we just return the val part. If we don't find it, we're going to simply return a zero instead, and more realistic language we would introduce error handling, but we'll do that later. Now, for the code for let, this is slightly more complicated. You want to make sure that you understand this because what is going to happen is we have to actually modify an environment because let creates a new variable and we have to have a way of recording that new variable and its mean value. So, the first thing we need to do is take that e1, which is the value of the variable and evaluate it in our current environment and we're going to save that into this variable v1. The next thing we want to do is create a new environment that has the variable VAR bound to the value v1. So, we're going to use the insert function to do that. Now, all insert does is take a key and a value, puts them into a tuple and adds that to the beginning of the list which is E and V. We can have other implementations where we use hash tables or something like that and the MPs. We will, in fact, do things like that. But for now, we're just using a linked list. So, anyway with added var being V1 into the environment in V, and that's creating a new environment that sharing the old one. Then we pass that into a recursive call to Eval V2. So, during that recursive call, our environment now has this new value added into it and it feels very much like pushing this value onto a stack. All we've done is really add something to the beginning of the linked list, but the function calls themselves Implement A Stack Frame. So, we are actually leveraging the fact that our language has this built-in stack for recursive calls and we're using that for our own data. The nice thing is, is when this call to the var returns, our variable E and V is unchanged. So, it feels like we pushed it onto the stack, made the call and when we returned, we popped it back off. Now, this is all implicit. This is a very common pattern and sometimes you'll hear functional programmers say that, "Oh yes, we pushed var onto E and V and then made this call. Didn't really?" But it has the same effect. So, it's sometimes easier to express it as if we are using stacks even though we are not exactly doing that. So, this should give you a few extra things in your interpreter to play with and the reference implementation isn't i4. I've added one other thing there and not implemented it just to give you something to do. There's an if expression there which you should be able to right now. So, see if you can do that. Then the next time what we're going to do is talk about functions and function calls because those are the most interesting data structure that we're going to talk about in this course. Well, there's a lot of interesting data structures, but this one is called a Closure and it really is one of the most interesting things we're going to discuss.