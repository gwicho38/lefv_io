Hello everyone. Welcome to CS 421. You've now seen the definition of the State Monad, and in this video we'll give you a short example of how to use it. When you're done with this video, you'll be able to define get and put to allow direct manipulation of the stateful part of the Monad and you'll be able to use a State Monad to write a stateful computation. So, as a reminder here's the definition of the State Monad. We've left off the functor and applicative definitions since we're not going to use them here anyway. Now, to gain proficiency with this again, it'll be helpful if you can reproduce this from memory before proceeding. We'll use the State Monad in a future lecture as well. Now, if you need to, pause the video here and resume when you're ready. Now to get started, let's look at what's involved in manipulating the state type directly. Suppose we wanted to write a function called incState that increments the state variable part of the result. Now remember, our state type has a state constructor that contains a function and the input to that function is the incoming state variable and the output is a tuple. The first part is a value of some kind and the second is the final state. Now, if we have a state s that contains a function from s0 to x, s1, we'd like ink status to return a state containing a function from s0 to x and s1+1. So try pausing the video and see if we can write this, and resume when you're ready to see the results. Here's the solution. We take in our state variable s0, and pass it to f to get out x and s1, and we simply return the tuple of x and s1. Did you initially try to use run state? We only need that to extract the function part out of a state, in this case we use pattern matching to do the same thing. Here's a second version that uses run state for reference. There's a sample run here to show how it work in practice. We create an initial state e1 that returns its state and a value five, and after running incState on it we return the incremented state and a value five. We taken the state variable s and then pass it to f to get out the tuple of x and s0. Then we simply return the tuple of x and s0+1. Now here are two very common functions used to manipulate states. The get function says that whatever input the state function gets it is going to be copied into the value portion of the tuple. The put function is the opposite. It takes an input x and uses it to replace the incoming state variable s. Here's a sample run showing what happens if we take an initial state and bind it to either get or put. See that the result of get is, it copies the state we pass into the result portion of the tuple and put takes a result portion of the tuple and copies it into the state portion. So, let's trace these out in a little more detail. To start off here's a state with a value five and we bind it to get. Since bind requires a function that returns a state, we add a lambda V to the front, this V will end up capturing the five from the previous state. By expanding out the definition of bind, we would have the second part. We're going to call run state on the first argument to extract out the function and pass in the s1 state variable and return the tuple five and s. This turns into the tuple of five and s1. Now we turn our attention to the next line, s2 is the same as s1 and x has the value five so we substitute those in. The lambda v will consume the five in return get which expands out to this function here after we play runState to it. Finally, the lambda s consumes the s1 leaving us with the final result. You might want to pause and work through the sequence yourself before continuing. Resume when you're ready to see put. To trace put we start the same way as with get, put already takes an argument though, so we don't need a lambda v like we did with get, and we expand out bind as before and applying the function in the first let clause, we get the tuple five and s1, and we substitute those in for x and s2. Expanding out runState put five we get this lambda which consumes a state and discards it, putting the five and the state position of the tuple. Finally, applying the lambda s to the s1 gives us our end result. Again, it's probably best that you pause here to work this out for yourself and resume when you're ready. One of the nice features about Haskell is a built-in notation to hide all the binding operations, that Hadoop keyword indicates that everything after it is monadic. So, each line acts as if the computation that came before it is bound to the line afterwards. So, here the a is bound to a function that takes an x and xb is bound to a function that takes a y. Finally, the computation returns x times y. Notice how this looks like regular variable assignment. If we try to run this program, we see that it works out of the box with any Monad we apply it to. In this example you see lists and maybe. Here's an example of what this looks like for the State Monad. Each line is supposed to be the second argument to a bind operation. We did not need to augment put with a lambda so we can write it on a line by itself. Get needs a lambda, so you see it here with the z left arrow get. The only other special syntax here is the let y equal 10 part. It just creates a variable y and makes it available to the rest of the computation as you would expect. Below you'll see a sample run of this code. Now that's the State Monad. We could put more interesting things into the state component if we want such as a HashMap, and you're going to see a variation of the State Monad in a future lecture when we talk about parsing.