Hello everyone, welcome to CS 421. When Monads were first applied
to programming languages, they weren't made simply to do
interesting things with lists. The things that got everything excited was
that they could be used to model stateful computations in a purely
functional setting. When you're done with this video, you'll
be able to describe the newtype keyword and the record type we use for
representing state. You'll be able to implement the pure
operation for the state monad. And you'll be able to implement the bind
operation for the state monad and trace an execution of it. This video has two parts and
next part we'll also define get and put that will allow you to directly
manipulate the stateful part of the monad. The first thing we need to do is
decide how to represent the state for computation. Now, stateful computation
starts with an input state and return some kind of result,
possibly modifying that state. So we can represent that as a function
of type a arrow as comma a. Where a is the state type,
when s is the result type. So as an example,
check out this ex1 function. It takes a state, s, and returns
a computation two times s as a result, and increments the state s in the process. Now to represent states more explicitly so
that they're type checker can keep us from mixing things up,
we'll use this record syntax. Here, we're creating a type
called State with two parameters, we have s as the output type and
a as the state type as before. The order is important,
we'll explain why in a few minutes. The constructor's called state as well,
and inside it, we have the record with one field,
runState. The newtype keyword in Haskell causes
the types to be synonyms of each other internally. The result is, we don't have to use pattern matching to
extract the record part of a state value. Now here's an example to make this clear. The long form way to declare a state
value might be here, where I define ex2a. It's just like ex1 from
the previous slide, but notice I have created the record and
set the runState field explicitly. But you can also declare a state value
like ex2b just by passing the function in, this will save us some typing. The runState field name accesses
the function part of the record. It's a little bit weird to name it this
way, most people would have thought to call it function or the computation or
something like that. But in Haskell,
label names are also functions, so it looks more natural when we use it
to extract the function out of the state. You should probably try typing all this
in to be sure you understand how it works before going to the next slide. Now to write a monad,
there must be functor and applicative class already defined. For functors, we want to pretend that
the state contains a value that we want to fmap a function across all those values,
returning new states in the process. So here's that ex2 function
with increment in a sample run. Now we can define our functor type class. And remember how I said earlier that
the state type parameters had to be in a certain order, the state type has to
come first, and then the result type. Now, we have two things that we want to
call State, the constructor, or type, spelled S-T-A-T-E, and also
the representation of the State in type s. Now to avoid confusion,
when I refer to the variable, I'll try to call it State s,
using State as an adjective. And when I want to refer to
the entire encapsulated function, I'll say state using it as a noun. But when I want to talk about constructor,
I'll call it the state constructor. Right, so back to why the state type has
to come first in the type definition. The reason is that functors
need a container type. If we have a state s a,
then we can say that the State is a container that
has values of type a within it. If we had to put the result type first,
then the function type class would want to map over state values, not result values,
and that's not what we want. So our task now is to write fmap. Here, f is the function from a arrow b and
g is a State s a. What we want is to output a State s b. It's much easier to do this kind of thing
if you think explicitly about the types. Notice that fmap needs to return a state,
so we go ahead and write down the state constructor. That constructor needs to have a function
in it that takes an initial State value and returns a pair. So let's take in an initial State s1. Variable g contains a State, so we call
runState on it and the State value s1. This gives us a result x,
and a new State value, s2. Finally, we apply f to the result x, and
return the correct tuple, and that's it. Again, you should try typing all this in
to be sure you understand how the states and results flow in the program. Now similar reasoning gives us a
definition of the applicative type class. We need to define pure which takes
an element and wraps it into a state. This may seem weird because
what we get is something that takes in a state variable and then returns
a result without even consulting it. But when we say that something is pure,
that is exactly what we mean in this context,
that is not contaminated by the state. Where the star operation,
we have two States f1 and x1. We know that f1 contains
a function of some kind and that x1 contains a value
to get to that function. But both of them
are contained within a State. But further we have to turn
our own State as a result. So following the types,
we emit a State constructor and take an initial State variable s. To get the function out of f1,
we runState f1 s and this gives us f in a new State s2,
which we then use to runState x1 and get our value x in the final State s3. We can then return f of
x in s3 as a result. That's all there is to applicative. Again, before you continue, you should
pause the video, and be sure you understand this definition, and
resume when you're ready to see the monad. Now we can show you the monad. The return definition is the same
as pure from applicative, this is the usual situation. But now we want to discuss bind. The first parameter is simply a State, the second parameter is a function
that takes the content of a State and returns a new State possibly with
a different type of context. That's why the type of f is
listed as a arrow State s b. Finally, the output should
be of type State s b. Now, since we're returning a state,
you can write down the state constructor in a lambda to accept
the incoming state variable s. Now what we have to do is extract
the contents of x, so let's call that y. Once we have y, we can feed that to f. Now think for a second though,
what will be the type of f applied to y? I hope you thought, it will be a State. But now, we have more work to do because
we're already returning a State and we have this results State
from f applied to y. So we take the state variable
result from s2 from the previous runState where we extracted x from y or
y from x. We use that to runState f y which yields a
new result z and a new state variable s3. Now, we can simply return that tuple
as a result of our top level state. Now this is the end of
this particular video but we've one more where we show
you how to use the state monad. But before you watch that,
it would be good for you to work through this code to be
sure you understand how it works. It's true we haven't shown
you any examples yet but just from knowing the types of the parts,
you can derive this particular definition. So see if you can get to the point where
you can write this definition out without consulting any sources and it will
help you understand what comes next.