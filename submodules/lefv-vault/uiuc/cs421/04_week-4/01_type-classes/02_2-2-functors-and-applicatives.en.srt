1
00:00:02,090 --> 00:00:05,835
Hello, welcome to CS 421.

2
00:00:05,835 --> 00:00:08,070
Now that you've seen some basic type classes,

3
00:00:08,070 --> 00:00:10,170
we're going to introduce three more type classes that have

4
00:00:10,170 --> 00:00:13,515
a profound effect on how Haskell programs are written.

5
00:00:13,515 --> 00:00:16,560
These classes are called Functor, Applicative, and Monad.

6
00:00:16,560 --> 00:00:21,880
We're going to introduce functor and applicative and leave monad for a little bit later.

7
00:00:22,580 --> 00:00:25,065
When you're done with this video,

8
00:00:25,065 --> 00:00:27,570
you'll be able to use the functor and applicative type classes

9
00:00:27,570 --> 00:00:30,030
to generalize the map higher-order function,

10
00:00:30,030 --> 00:00:32,955
and you'll build and implement them for your own datatypes.

11
00:00:32,955 --> 00:00:35,790
So by now you will have use the map function to apply

12
00:00:35,790 --> 00:00:38,640
a function to elements of a list in your own programming,

13
00:00:38,640 --> 00:00:41,900
and it's super convenient that lists have this function.

14
00:00:41,900 --> 00:00:44,020
But take a look at these example types.

15
00:00:44,020 --> 00:00:46,760
We have a tree type that implements rose trees,

16
00:00:46,760 --> 00:00:50,120
and a maybe type that's the same as the one that comes with Haskell.

17
00:00:50,120 --> 00:00:54,565
So, wouldn't it be convenient if we could use map on these as well.

18
00:00:54,565 --> 00:00:58,085
After all, these are types are just containers like lists

19
00:00:58,085 --> 00:01:01,490
and it makes sense that we might want to map an operation over them.

20
00:01:01,490 --> 00:01:03,890
So, this is where functor and applicative come in.

21
00:01:03,890 --> 00:01:07,520
The Functor Typeclass gives us a function fmap,

22
00:01:07,520 --> 00:01:10,555
which takes a function from a to b and a container f

23
00:01:10,555 --> 00:01:14,015
containing a's and returns a container containing b's.

24
00:01:14,015 --> 00:01:15,860
It's just like regular map,

25
00:01:15,860 --> 00:01:21,315
but now we've generalized it by making the container itself a parameter.

26
00:01:21,315 --> 00:01:24,240
I hope you are absorbing this technique of

27
00:01:24,240 --> 00:01:26,810
making things set parameters that once were fixed.

28
00:01:26,810 --> 00:01:30,050
You saw this first in the lecture about higher-order functions when we

29
00:01:30,050 --> 00:01:33,950
parameterize the operation we wanted to perform on a list.

30
00:01:33,950 --> 00:01:36,985
But now we've parameterized the list too.

31
00:01:36,985 --> 00:01:40,160
You've also seen this with continuation passing style,

32
00:01:40,160 --> 00:01:44,240
when we used a parameter instead of the built-in function return mechanism.

33
00:01:44,240 --> 00:01:47,705
So, here are the instances of functor from maybe enlist types.

34
00:01:47,705 --> 00:01:50,240
These are loaded by default when you start Haskell so,

35
00:01:50,240 --> 00:01:52,340
you don't actually need to type them in yourself.

36
00:01:52,340 --> 00:01:55,250
So, let's see how we can use this.

37
00:01:55,250 --> 00:01:59,330
Remember the inclus function from the higher-order functions lecture.

38
00:01:59,330 --> 00:02:02,170
Let's write a new version called incAnything,

39
00:02:02,170 --> 00:02:04,440
which uses fmap instead of map.

40
00:02:04,440 --> 00:02:07,820
We can pass it a list and it works like regular map.

41
00:02:07,820 --> 00:02:10,565
We can pass it a maybe works on that as well.

42
00:02:10,565 --> 00:02:12,740
So, in fact, anything for which we provided

43
00:02:12,740 --> 00:02:16,055
a functor instance will work on this function now.

44
00:02:16,055 --> 00:02:19,025
Now, let's move this up one level.

45
00:02:19,025 --> 00:02:21,245
Here's a definition of applicative.

46
00:02:21,245 --> 00:02:23,390
The first function is called pure,

47
00:02:23,390 --> 00:02:26,450
and serves to take a value and put it into a container.

48
00:02:26,450 --> 00:02:30,575
Second operation is this less than star greater than operation.

49
00:02:30,575 --> 00:02:31,850
It takes two containers,

50
00:02:31,850 --> 00:02:34,760
one with a function from a to b and one with an a.

51
00:02:34,760 --> 00:02:37,430
The output is a container with a b.

52
00:02:37,430 --> 00:02:41,320
This is called a lifted function application.

53
00:02:41,320 --> 00:02:44,000
Some people call this operator app as a result.

54
00:02:44,000 --> 00:02:46,265
Contrast this with fmap.

55
00:02:46,265 --> 00:02:49,295
Fmap, the function we are applying is on ground level.

56
00:02:49,295 --> 00:02:51,335
It's a bear function. But for app,

57
00:02:51,335 --> 00:02:54,260
the function starts off in the container instead.

58
00:02:54,260 --> 00:02:56,470
So, let's look at an example.

59
00:02:56,470 --> 00:02:59,270
Let's declare a type Foo that contains an a.

60
00:02:59,270 --> 00:03:04,670
To declare fmap, we just apply the given function to the contents of a given Foo.

61
00:03:04,670 --> 00:03:08,540
For the applicative, pure just puts its value into a Foo,

62
00:03:08,540 --> 00:03:11,930
and the app function takes a Foo with a function and a Foo with an argument

63
00:03:11,930 --> 00:03:15,650
and yields a new Foo with the result of the application.

64
00:03:15,650 --> 00:03:18,020
You might want to pause here and look at these definitions or

65
00:03:18,020 --> 00:03:20,460
type them in yourself to become more familiar with them,

66
00:03:20,460 --> 00:03:24,750
resuming you're ready to see how we can make use of this.

67
00:03:26,290 --> 00:03:28,990
Here's a sample run,

68
00:03:28,990 --> 00:03:32,580
we can define a function inc that increments its argument index.

69
00:03:32,580 --> 00:03:36,590
We can use fmap to increment an integer contained within the Foo.

70
00:03:36,590 --> 00:03:39,590
Here's an alias for fmap you'll see a lot,

71
00:03:39,590 --> 00:03:41,740
this dollar sign in angle brackets.

72
00:03:41,740 --> 00:03:44,270
It's supposed to remind you of the regular dollar sign,

73
00:03:44,270 --> 00:03:46,415
which represents function application.

74
00:03:46,415 --> 00:03:49,355
So, I'm just going to call it the fmap operator.

75
00:03:49,355 --> 00:03:52,880
So next, let's put inc into a Foo,

76
00:03:52,880 --> 00:03:59,360
in that situation we can use the app operator to apply Foo inc to Foo 20 to get Foo 21.

77
00:03:59,360 --> 00:04:00,755
But you may be wondering,

78
00:04:00,755 --> 00:04:04,130
why would we put an inc into a Foo in the first place?

79
00:04:04,130 --> 00:04:07,340
To answer that, let's define another function plus,

80
00:04:07,340 --> 00:04:09,800
which just adds two arguments together.

81
00:04:09,800 --> 00:04:12,370
How can we use this with Foo?

82
00:04:12,370 --> 00:04:15,090
Well, we could use the fmap operator.

83
00:04:15,090 --> 00:04:17,205
If we apply plus to Foo 20,

84
00:04:17,205 --> 00:04:18,795
using the fmap operator,

85
00:04:18,795 --> 00:04:21,890
what do we get back is a Foo with a function in it.

86
00:04:21,890 --> 00:04:24,470
This is how a function gets into a Foo,

87
00:04:24,470 --> 00:04:26,950
and why we need an applicative operator?

88
00:04:26,950 --> 00:04:29,295
Here's the rest of the example,

89
00:04:29,295 --> 00:04:32,265
we can use fmap to apply plus to Foo 20,

90
00:04:32,265 --> 00:04:34,740
which results in Foo of plus 20.

91
00:04:34,740 --> 00:04:39,550
The app operator then takes that and applies it to Foo 30 to get Foo 50.

92
00:04:39,550 --> 00:04:43,740
If you'd written plus 20 30 you would get 50 out.

93
00:04:43,740 --> 00:04:46,020
But by introducing these operations,

94
00:04:46,020 --> 00:04:50,360
you can apply plus to any container and get the same functionality.

95
00:04:50,360 --> 00:04:53,155
We refer to this as lifting plus.

96
00:04:53,155 --> 00:04:54,830
Here's a few details,

97
00:04:54,830 --> 00:04:56,170
we need to mention.

98
00:04:56,170 --> 00:04:59,530
There are some mathematical laws that applicatives should follow,

99
00:04:59,530 --> 00:05:02,215
otherwise things just will not make sense.

100
00:05:02,215 --> 00:05:05,000
These laws just say that the normal properties

101
00:05:05,000 --> 00:05:07,460
of functions such as identities and composition,

102
00:05:07,460 --> 00:05:10,385
work with the applicatives the same way they work normally.

103
00:05:10,385 --> 00:05:14,570
It would actually require some effort on your part to make it not follow these laws.

104
00:05:14,570 --> 00:05:18,410
You should know however that Haskell does not enforce them at all.

105
00:05:18,410 --> 00:05:20,240
Or giving credit the sources,

106
00:05:20,240 --> 00:05:26,180
I should say that many of these examples were stolen from the Haskell Wikibooks page.