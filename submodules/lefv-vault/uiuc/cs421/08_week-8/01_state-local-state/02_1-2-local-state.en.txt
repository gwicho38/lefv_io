Hello, and welcome back. In the last video, we used the global variable to keep track of the current value of a counter, but this time we're going to use a much more sophisticated way of dealing with the state variable. When you're done with this video, you'll be able to use lead and function declarations to control precisely when a variable is created and initialized. You'll also be able to completely encapsulate a stateful variable within a function. Now, to use this technique, it's very important that you understand what a variable gets created. So, take a look at this code. Here, we define a function foo with one parameter x. Inside of foo, we define a variable a and set it equal to 10 plus 20, and then finally, the body of the let returns the value a plus x. If we call foo twice and assume that the compiler does not optimize this away for us, how many times will the 10 plus 20 be computed? The answer is twice. Each time the function is run, the lead is evaluated. This creates a brand new variable a, which is then discarded when the function returns. Now consider this example where a is a global variable. It's declared outside the scope of foo, so it doesn't matter how many times foo gets called. The a is only made one time. Now, let's modify the first example. Notice that I declare a variable called foo and then declare a variable called a, and the body of the lab returns a function that is inbound to foo. You will recognize this as a closure I hope. I call foo twice, the a is still only computed once for the same reason that the global version of a is only computed once. The a is created outside of the scope of the function nagging no internally the data structure that makes it possible for foo's function to access a is called a closure. Now, we're going to use this with state. We define a variable counter and then use a let to declare a variable CT initialized as a reference to zero. The let then returns a function that increments CT and returns its value. We now have a version of counter that works as before except CT only exists inside the function, where outside of the let now, so, CT is out of scope for the rest of the program. This leads to the following horrible Pun. Remember that the higher order function twice is really the church numeral for two. We can apply twice to counter a few times and see that it always creates different results, you know what this means, right? This is why you should never mix church and state. Here's a semi practical application of this technique. By swapping out what we do at the state, we can use to local state as a seed for a pseudorandom number generator. In this function, we allow the user to parse in the initial via the state, so, it acts like the seed in their random number generator. By swapping out what we do at the state, we can use a local state as a seed for a pseudorandom number generator, and this function we allow the user to parse in the initial value of the state. So, this acts like the random number generator seed. Another interesting trick is this one. We can create a tuple of functions instead of just creating one. Here, both functions have access to the local state CT. Now, we have a function counter and another function that can reset the counter. Perhaps this idea of a local state accessible only to a few related functions will remind you of something, we'll talk about that in our next video.