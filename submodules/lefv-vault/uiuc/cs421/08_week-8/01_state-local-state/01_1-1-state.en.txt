Hello everyone, welcome to CS 421. We've been avoiding talking about this for the whole course. We've either been doing without it altogether, assimilating with monads, but it's timely address state directly. Haskell is a little unusual in that it forbid state, but most languages allow it. So we need to be able to discuss what effect state has on our languages. When this video is done, you'll be able to describe the property of referential transparency, and explain the complication that state brings to programs, and when you use a similar language called OCaml, and use references to model state. Here's a rule of referential transparency given in a small step semantics format. It says here that if e_1 evaluates to v and e_2 also evaluates to v, then we can replace e_1 with e_2 and some other context and get the same final result. Here I've used to f applied to e_1 to represent that. This rule does not hold for all systems but when it does, you can use what we call the equational reasoning to think about our programs. One of the benefits of equational reasoning is that you can use mathematics to modify your program, and it possibly could make it more efficient. For example, this equation says that if f is applied to an if expression, we can move f inside the branches of the f expression. So, in this case here with x multiplied by this if, moving the multiplication inside the branches makes the code more efficient since we no longer have to deal with the division. Of course we're assuming that x is in zero here but never mind that. You can drive a lot of complication, you can drive a lot of optimizations this way if you can be sure that moving expressions around will not change the meaning of your program. But there is a complication when state is introduced. Since Haskell doesn't have state, we're going to use a similar language called OCaml for this lecture and the next few. To the hash symbol you see is a prompt for the ripple and statements are terminated with two semicolons. Anyway in OCaml, it's possible to create a function like this one. Every time you call counter, it returns a number one more than the one you gave it before. So the question is does equational reasoning still work? Well, I like puns, so let's just call this the counter example. Before we can say that f of x plus f of x is equal to two times the f of x, but it clearly does not work, if f of x is called the counter. So let's break down the semantics of state in OCaml. First, we start off with the Transition Semantics. We have four operations to introduce The first is rough, it takes a value for an argument and creates a state $i, initialized to the value v. We don't get the address itself but we get a representation of it that we can compare for equality with other states. To access the contents of a state, we use exclamation point, it's kind of like the pointer in direction operator in C++. We also have assignment operator colon equal, it updates a state and returns a value called unit, which we represent with open and closed parentheses. Finally, we have semicolon, which allows us to separate operations and return the value of the last operation as a value of the whole chain. Here are the Natural Semantics, are big steps semantic rules for the same operations. I'm just going to let you look at them and read them to you. Okay. So, let's look how we can use state to write counter function. Here's the first way we're going to try. We'll create a global variable called CT and initialize it as a reference to zero. Next, we're going to define a function counter and increment CT and returns it. We can test it out and see that counter does what we wanted it to do. There are a few bad things about this though. First, CT is globally defined. If someone else had already defined a variable named CT, there could be a collision. But this problem is solved easily enough by using modules or some other namespacing mechanism. The other problem is if a user gets a hold of this variable, they could change it themselves which might break the functionality of the counter especially if we changed a representation of it in the future. We haven't even mentioned what happens if you decide you want more than one counter. So, we could conclude that state is bad because it breaks equational reasoning and it does make programs significantly more difficult to reason about. In fact many people do conclude that, and that's why we have languages like Haskell. But there are algorithms and constructs that really do need state to be handled efficiently. Many graph algorithms for example, and since our world is stateful, sometimes state is the most natural way to model things. In the next video, we will present another way of writing counter that makes use of local variables to hide the state.