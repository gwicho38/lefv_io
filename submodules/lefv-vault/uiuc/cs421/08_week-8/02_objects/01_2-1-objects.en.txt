Hello everyone, welcome to CS 421. The last time we talked about encapsulating state inside of functions. So, this time what we're going to do is make use of that to implement their own objects system. When you're done with this video you'll be able to relate the concept of objects to functions with state, and you'll also implement two objects systems when using records and when using message dispatch. It'll be very helpful to have a running example for this. So, we'll start with this one. Again, this is OCaml syntax but you should be able to read it since you already know Haskell. I've created two functions pi1 and pi2 known as projection functions. We're going to treat pairs as cartesian coordinates. We also have a function report that takes a pair and prints it out. Finally, there's a function movept which takes a point and a Delta, and adds Delta to the point. Now, let's make a point class using the local state technique from last time. We have an object constructor mktPoint that takes an initial value for the location and uses that to create a local state myloc. Then, we return a five tuple with the reference in the four functions the same for from the last slide, except we capture the result of movept and update myloc with it. Now, the problem with this method is whenever we want a point object we must assign it to the five tuple of names capturing the state and the functions. We wanted a dozen of these it would get cumbersome very quickly. One way we can improve on this is to use records. Like in Haskell, OCaml will let you define the names and types of the fields and now every time you create a point you get a record object back that's easy to access, like this one. Difference with OCaml and Haskell is that OCaml's lead are not recursive by default, but then there's this letRec keyword. We can define a variable this to capture the value of the entire record. Then, we can use the this variable inside of our method definitions just like you could in a language like C++ or Java. For the two example we have here, it's probably not worth the effort but if we need it to be able to pass the whole object to something else, this would make it much simpler. So, the idea of extending a record with functions and fields and encapsulated state is a common one, you'll see it in languages like C++. But the original idea of objects used a different model, that is of sending messages to objects and the objects that act on those messages. This is similar to languages like Smalltalk. So, let's create an object that uses message dispatch. We'll use strings to represent messages and the function that receives the string will return the matching function to us. Now, here's mkPoint again, this time using a message dispatcher. We create references for x and y separately this time, and then return a function that accepts a string st. It matches st to one of getx, gety, movx, or movy. If the string is not one of those it emits an error message. Not a dynamically typed language like Python or scheme this technique is very powerful, though unnecessary in Python since objects already built in. In OCaml and in Haskell, if Haskell allowed state, this technique suffers from one very painful limitation, all the methods must have the same type. But even given that limitation the message passing technique opens up another feature of objects, namely subclassing. So, to warm up, you might want to think about how you would add a report method to this object. It's fairly easy, right? You just match on the string report in return an appropriate function. You'll have to take a dummy argument and return a dummy value but it would work. Now, suppose we wanted a subclass, fastpoint that moves twice as fast as point. A fastpoint should respond to all the same messages that a point would respond to, overwriting some of it wants, adding some if it wants. To do that with message-passing fastpoint needs to access points data. Here's how it works. We have two entities, a superclass point, and a subclass fastpoint. When we create a fastpoint the first thing it will do is create an instance of its superclass point. Then fastpoint will return a message dispatcher to handle the messages, and if it gets a message it doesn't want to handle, it sends it to point. Here's the code for point. We call this function mkSuperPoint because it's only meant to be used to create superclass points, not normal ones. It's same as the original but it also returns a tuple of references so that fast point will have direct access to the local state. Now, here's the code for fastpoint. It first calls the superclass constructor in much the same way as you would do in Java, or C++, or Python, then message dispatcher handles movx, movy, but the getx and gety messages it passes to the superclass, so now we have actual inheritance. This is not very efficient if we have long chains of inheritance though but it's very flexible. To make this fast in real life, the language C++ creates a table for every class type called the V table. It has what amounts to a lookup table for its methods. Each entry of the V table points to an appropriate version of the objects methods, and each object will have a pointer to the corresponding V table. This does not work by default though, to use this in C++ you need to tell the compiler that you want to use virtual methods, the virtual keyword. Otherwise, the compiler will look at the type of the variable in hardcode that class's method at compile time which will cause it to ignore the actual type of the variable contains. So, in summary, we can use message passing to simulate objects and a few languages use this. Doing this in a strongly typed language is difficult and this language provides extra support for objects. One important idea about object is set of polymorphism. You've seen it before with parametric polymorphism for things like lists and with type classes in Haskell, objects and inheritance gives you another way of implementing polymorphism. We could spend a whole semester just on objects but we're going to stop here except for one more lesson, and that is, what is the relationship between the objects subclasses and subtypes?