Hello. Welcome to CS 421. You've seen quite a few different semantic systems up to now and you'll notice how each have their own way of modeling what's happening with the program. In this semantics, we're going to focus on the effect of program has on the state, the goal of being able to tell that the program does the right thing. When this video is done, you'll be able to write down Hoare Triples and explain how they're different from small steps semantics. You'll also be able to use some to show the correctness of a single program. We'll also show you an important concept called The weakest precondition. Remember the simple imperative programming language? It's back. Let's make a simple change though. That we can leave off the else branch of an if statement if the branches skip. It'll also be useful to define these two functions overstatements, var of S is a set of variables that appear in S and change of S is a set of variable names that appear on the left-hand side of an assignment statement in S. To provide good contrast, I want to be sure you remember the small step semantics. We have a configuration which is a program together with its state, and we transition to another configuration depending on what the next step of the program should be. We're concerned with two things. Exact values of the variables in the states and the next step that occurs in the program. This is good for what it does, but sometimes, there's a lot to be gained by allowing for variation. Here, we introduce Hoare Triples. There are two assertions p and q placed in curly brackets around the program S. The Hoare Triple asserts that if p is true before the program S runs, q will be true afterwards. We call p the precondition, q the post-condition. p and q can be a list of variables and their values, but they can also be more general than that and frequently are. We also want to distinguish between partial correctness and total correctness. If we have partial correctness, we guarantee a correct answer, but only if the program terminates. We don't guarantee termination. Suppose you had a program that would go through the digits of pi and look for your social security number, you might be able to generate as many digits of pi as you want and be able to indicate if your Social Security number shows up. But at any stage that number hasn't been found, you cannot say that it's not there. You just have to keep looking. Total correctness, on the other hand, guarantees both correctness and termination. These Hoare Triple that we're writing here, we always assume partial correctness on these. Here are some examples to illustrate. The first example says that, if x equals 0 before we run our program, x will be 1 afterwards. The second example is less precise. It just says that x will be greater than 0. The third one says, true for the post-condition which means nothing at all about the program except that it has terminated. The fourth and fifth assertions are false. We have false as our post condition. Since false can never be true, but we are asserting is that the program never terminates. If we have false as our post-condition, since false can never be true, what we're asserting is at the program never terminates. Okay. So, let's define the axioms for Hoare Triples in the simple imperative programming language. First one is skip. If p is true before you skip, you will be true after you skip. The assignment axiom often surprises people. It says that, for p to be true after an assignment of t to u, then p will have to be true before with all the u's replaced with t's. The example should help. Suppose I want x to be greater than 10 after we assign y to x. The only way that happens is if I replace x by y for the precondition, y needs to be greater than 10. Composition is easy. If we have p run S1 to get r, and then take r run S2 to get q, then we can start with p run S1 and S2 and get q. The conditional rule is special. There are some insights that happened in the development of computer science that cause things to be possible that otherwise would not have been possible, and you're looking at one of them right now. Imagine you had 10 S statements in a row, and you wanted to understand the effect of program could have. There are 2 to the 10 paths through that program. A thousand and twenty-four different things that can happen. Edsger Dijkstra realized that we could instead think of an if as having a single precondition in a single post-condition. Both S1 and S2 should cause q to be true. If you have the time, I highly recommend reading this EWD 264. There will be a link on the course website. In that paper, Dijkstra spells out his idea. The Loop Rule is similar to if, but the precondition and post-condition both share a common term p, and the post-condition had said B is negated when the loop is done. We will have a separate lesson about loops. The rule of consequences isn't about a specific construct instead, it tells us what we can get away with. Suppose that we have specification p1 S q1, and then we find a p that implies q1, and q that is implied by q1, and we can also say that p S q. I like to think of this is how we advertise software. If our program needs 5 gigabytes to run, but we tell people it needs 10, we're not going to get into too much trouble. The program will still run. We are allowed to strengthen the precondition and still have a true statement. For the output, if our program can produce more than 10 results in an hour, but we advertise that it produces more than five results in hour, then we still won't have a false statement. We're allowed to weaken the post-condition and still have a true statement. Here's an example proved that uses assignment and sequence. To do a proof, you can either write out a proof tree-like structure, or you can interleave assertions with your program like you see on the right. Typically, you will start with your post-condition, x equal 20 and y equal 10 in this case, and go backwards, you derive your preconditions. So, we would look at the y equal t, and derive that t had to be equal to 10. Then we look at the x going to equal y, derive that y had to be 20. Finally, we would use t is going to equal x, to write that x has to be 10. So, we have as a proof that this program exchanges the values of x and y. If x starts with 10 and y starts at 20, we'll have our desired result that x will be 20 and y will be 10. For if proofs, we add some assertions to the branches to derive that if q is true after S1 or S2, then p and B or p and not B must be true before the branch executes. For proofs that use consequence, we can just write both assertions down, the stronger one followed by the weaker one. As an example, here's a program that asserts that m will be the maximum of x and y in all cases. That's what the pre-condition of true means. There is a handout with all the rules if you want. Look at that and see if you can work out, but the proof for this program might look like. And since you haven't seen many examples yet, feel free to just watch the derivation. We start off by putting our post-condition in desired precondition in their places. Next, we put the post-condition at the end of the branch of the second if statement in user rules to derive the preconditions for them. After that, we use the if rule to derive the precondition for the whole if statement. We are going to use p to represent all this because it's about to get messy. But notice what has to be true at this point of the program where we define the capital p. Between the two if statements. x should be less than y, and y is the max, or x is greater than y and m is already equal to the max. We do the same thing with the first if statement deriving the branches. To save space, I'm not actually going to write it all out. Next, we combine the branches to make the ultimate pre-condition of the two statements. Expanding everything out, we see that if x is less than y, or y is less than x, we're fine, but if they are equal, then this program is only going to work if m happens to be the max of x and y already. This is not a weaker precondition than true. So, this is a disproof of the program. I like this example because when I was an undergrad, I made the mistake of forgetting the case where two numbers could be equal during a comparison. In our next video, we'll talk about loops.