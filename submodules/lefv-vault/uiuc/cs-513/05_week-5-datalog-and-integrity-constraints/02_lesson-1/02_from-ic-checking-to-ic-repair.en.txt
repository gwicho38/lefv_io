So we go back to one of our readings. The article by Bertossi and Bravo. So you recall, we were looking at that same example, dataset with students and enrollments, we had functional dependencies, and now, we also looked at, for example, referential integrity constraints. I just mentioned that foreign key of a child table references the parent key. Just to remind you quickly what this is here. If you look here at the Enrollment table, the Enrollment table here you can think of it as having a pointer to the Students table. So for example, the Enrollment table has a student number of 104. Then we look over here, well, who is that? That's Claire Stevens. So that's why the first column of the Enrollment table acts as a foreign key to the primary key for the Students table. Okay? So, we can see, is there an integrity violation? For example, 105 doesn't show up here. That would be a violation and we can write a simple rule, either in data log or in SQL that finds us the quote and quote, "bad guys", and then we can try and repair this manually, typically. Here is a foreign key violation or an inclusion dependency violation. And over here, we see here for example, two different students apparently John Bell and Joe Logan have the same student number, that's a functional dependency that's violated, because we are hoping that the student name uniquely identifies a role, key constraint or functional dependency. This is not the case, so this is broken. We need to fix that. Over here, that's not a problem because the Enrollment table, again, the first column is not the key here, it's just the combination of two things should be a key. So what really this is, is a bridge table, when we're talking about ER model, you might recall there were entities and relationships, this Enrollment table really represents a relationship where we link students with courses. So this Enrollment table here, has really two pointers: one to the Students table, for each row it points to the Student table; and then another point, are not shown here in the figure, to the Course table where we learn more about courses. So, we check integrity constraints but now we want to repair them. So there's this notion of a minimal repair. Basically, the idea of repair is, if we have an inconsistent database that violates some constraints, we basically look at other instances -- what changes could I make to the database so that the integrity constraint is satisfied again? That's a basic notion of a repair. Sometimes you can delete the whole database and say, "Oh, look! No integrity constraint is violated." I have the entire database but that's sort of minimal repair. Just because you do nothing, or in this case, I have no information in the database -- yeah, maybe formerly, you're not violating any of the integrity constraints but you're violating another very big informal constraint that says, you should keep your database as close to what you had before only make minimal changes. So, that's why this notion of minimality is crucial here. Among all the space of changes that we can do to the database, we want to find the ones that keep, as much as possible, the database as is and only change hopefully a few tuples that then satisfy the constraint. And we're going to jump into a hands-on session, I'm going to switch gears in a moment and now work with this dataset. So let's have first a quick look of what's happening here, and see whether we can understand this. So, we have our Student table. First column is the ID, second column is the Name. So, this is a functional dependency, where we say the same rule that we saw before -- if I have a student (tuple X, Y) and another student (tuple X,Z ), but Y is different from Z, we have a problem. So we report the key for which this is a problem, and the Y and Z value where there's sort of disagreement. Let's look at this for example, here we have Bell, Ball, and Logan, all sharing the ID 101 -- that's a problem. So hopefully, a rule like this will tell us that 101 is a problem, and it would also tell us what the names are of the students that are here in conflict anyway. And then we come to the actual repair part, and so let me give you a first flavor about this already. And if you look in section three-one of the Bertossi paper, you might have seen this a few weeks ago, we can do the following. And this is the whole trick of these repair rules when we encode them in this language and you just did a look as follows. If we have a violation where the key X could either stand for Y or for Z which it shouldn't, Y and Z should be the same; but if it's in this table here and this auxiliary relation, we know Y and Z are different, otherwise it would not have ended up there. So if it does that, then we can execute two hypothetical operations, we can say well, either Y has to go, or Z has to go. If there's Y and Z, two different names for the same key X, then either Y or Z has to be deleted. And this little v here in the head of the rule, that's where all the power comes from from this particular system. So, in the regular data log system, I cannot say in the head of a rule either this or that. Same in SQL, you write a query to define what the result is, there's no or, but this little v, this logical or gives you all the power of this language so the system that we're going to use here is one that can sort of keep the two different possibilities in mind and calculate with them, and do this for all kinds of other possibilities as well. So this is why this underlying data log system is really more like a constraint solver, it's more of a fancy, more expressive system, has also repercussions in terms of efficiency. It's not terribly efficient because of that, because it needs to try out a lot of combinations, but it is a very powerful tool in the right hand. So with a lot power comes also responsibility. All right. So, how would we use that? We can then say well, in the new student relation, if you have previously used student X, Y, and it just not the case that the student has been deleted, then in the new student relation that student will be there. What is the effect of that? That creates a new copy of the Student table. But since the deletion has these choices, we get different copies, how the world might be. In logic, we call this different possible worlds. There's something called possible world semantics. So just like we, in the abstract, saw previously maybe different repairs. For example here, here are two different repairs of an inconsistent database. The system will not generate these different worlds for us. So in one world, the student ID 101 belongs to John Bell, and in the other world it belongs to Joe Logan. Both of these repairs make some sense. They also both now, are consistent with respect to integrity constraints. Which one it is? We might not know, but maybe we have other rules that tell us which one is more likely. But the point is that, the system can generate those repairs automatically for us, which is nice.