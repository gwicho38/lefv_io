1
00:00:00,215 --> 00:00:08,568
[సంగీతం]

2
00:00:08,568 --> 00:00:12,190
Hello and welcome back to Theory and
Practice of Data Cleaning.

3
00:00:12,190 --> 00:00:14,620
Last week we looked at
the relational data model and

4
00:00:14,620 --> 00:00:17,790
provided a brief introduction
to relational queries.

5
00:00:17,790 --> 00:00:21,240
This week we will continue our work with
the relational model and delve further

6
00:00:21,240 --> 00:00:24,720
into relational queries and integrity
constraints, specifically in Datalog.

7
00:00:25,820 --> 00:00:29,590
Now that we have left syntax and pattern
based data quality issues behind us,

8
00:00:29,590 --> 00:00:34,090
the key idea going forward is to operate
at the logical or semantic level.

9
00:00:34,090 --> 00:00:37,590
Now dirty data means
logically inconsistent data.

10
00:00:37,590 --> 00:00:40,850
And we will use relational queries to
check whether integrity constraints

11
00:00:40,850 --> 00:00:41,720
are satisfied or not.

12
00:00:42,780 --> 00:00:45,590
Specifically we will write
queries in denial form,

13
00:00:45,590 --> 00:00:49,739
that is in a form that describes the bad
situations that we want to avoid.

14
00:00:50,820 --> 00:00:53,020
First we will look at common
relational constraints,

15
00:00:53,020 --> 00:00:57,620
that is, functional dependencies or
key constraints as they're also called.

16
00:00:57,620 --> 00:00:59,740
And inclusion dependencies, for example,

17
00:00:59,740 --> 00:01:03,730
foreign keys in relational
databases are a special case.

18
00:01:03,730 --> 00:01:06,680
While these constraints can be
understood as formulas in first order

19
00:01:06,680 --> 00:01:07,760
predicate logic.

20
00:01:07,760 --> 00:01:09,030
It is much more convenient and

21
00:01:09,030 --> 00:01:12,600
practical to write them down in
the form of executable Datalog rules.

22
00:01:14,020 --> 00:01:17,120
Datalog rules consist of a head
to the left-hand side and

23
00:01:17,120 --> 00:01:18,410
a body to the right-hand side.

24
00:01:18,410 --> 00:01:21,010
And we can think of it as follows,

25
00:01:21,010 --> 00:01:26,250
the body of a rule specifies various
query conditions and is evaluated first.

26
00:01:26,250 --> 00:01:29,325
Then, for those variable
bindings that satisfy the body or

27
00:01:29,325 --> 00:01:33,520
right-hand side of the rule, the head or
left-hand side can be asserted.

28
00:01:33,520 --> 00:01:35,080
That is, new answers are generated.

29
00:01:36,450 --> 00:01:38,390
After having worked through
this week's materials and

30
00:01:38,390 --> 00:01:42,450
the associated assignment, you should be
able to formulate and execute queries and

31
00:01:42,450 --> 00:01:43,955
integrity constraints in Datalog.

32
00:01:45,110 --> 00:01:48,870
You will also be able to recognize and
deal with common Datalog pitfalls, for

33
00:01:48,870 --> 00:01:51,640
example rules that are not safe.

34
00:01:51,640 --> 00:01:52,960
For a rule to be safe,

35
00:01:52,960 --> 00:01:57,040
every variable must occur positively
at least once in the body.

36
00:01:57,040 --> 00:02:00,830
In other words, if a variable only
occurs in the head of the rule or

37
00:02:00,830 --> 00:02:04,950
only negatively in the body then we
cannot limit this variable's range.

38
00:02:04,950 --> 00:02:07,920
That is we cannot enumerate
its possible values and

39
00:02:07,920 --> 00:02:09,620
the Datalog system will report an error.

40
00:02:11,010 --> 00:02:14,820
In the assignment you will practice how to
write simple relational queries in Datalog

41
00:02:14,820 --> 00:02:17,620
and how to express logical
integrity constraints as Datalog

42
00:02:17,620 --> 00:02:18,940
queries in denial form.

43
00:02:20,050 --> 00:02:23,400
Learning a bit of Datalog allows you to
see more directly the underlying logic

44
00:02:23,400 --> 00:02:27,020
patterns used to express and
check relational data integrity.

45
00:02:27,020 --> 00:02:30,940
In subsequent lectures we will then
also go more mainstream by employing

46
00:02:30,940 --> 00:02:34,030
SQL queries for
similar integrity constraint checks.

47
00:02:34,030 --> 00:02:38,270
While highly relevant in practice, a skill
sometimes obscures the underlying logical

48
00:02:38,270 --> 00:02:41,310
kernel of queries and
integrity constraints.

49
00:02:41,310 --> 00:02:43,970
Which is why we look at Datalog first.

50
00:02:43,970 --> 00:02:46,900
Okay, let's jump right
into the first lecture.

51
00:02:46,900 --> 00:02:56,674
[సంగీతం]

52
00:02:56,674 --> 00:03:00,097
[SOUND]