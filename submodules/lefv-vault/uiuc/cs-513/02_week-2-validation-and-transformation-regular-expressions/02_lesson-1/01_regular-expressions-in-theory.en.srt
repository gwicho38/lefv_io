1
00:00:00,000 --> 00:00:07,095
[MUSIC]

2
00:00:07,095 --> 00:00:10,900
Welcome to Theory and
Practice of Data Cleaning.

3
00:00:10,900 --> 00:00:13,590
In this video I will give
an introduction to regular expressions.

4
00:00:13,590 --> 00:00:17,370
So first we will have a video on
the theory of regular expressions,

5
00:00:17,370 --> 00:00:20,270
that is a brief introduction where
regular expressions come from.

6
00:00:20,270 --> 00:00:24,160
In a separate video I will then talk
about practice of regular expressions.

7
00:00:24,160 --> 00:00:27,144
What you need to know to get started
with regular expressions and practice.

8
00:00:27,144 --> 00:00:30,423
And then finally I'll have a video
demonstrating the use of regular

9
00:00:30,423 --> 00:00:32,490
expressions on an actual website.

10
00:00:32,490 --> 00:00:34,950
But first why should we
study regular expressions?

11
00:00:34,950 --> 00:00:36,899
Regular expressions
are widely used in practice.

12
00:00:36,899 --> 00:00:38,620
So they're a little bit like wildcards.

13
00:00:38,620 --> 00:00:43,504
For example you might have seen
expression such as *.csv to match all csv

14
00:00:43,504 --> 00:00:45,169
files maybe in a folder.

15
00:00:45,169 --> 00:00:48,500
But unlike wildcards regular
expressions are much more powerful.

16
00:00:48,500 --> 00:00:50,910
So you can think of them
as wildcards on steroids.

17
00:00:50,910 --> 00:00:54,460
Regular expressions are also used
to match, extract and then find and

18
00:00:54,460 --> 00:00:55,560
replace data.

19
00:00:55,560 --> 00:00:58,210
For example in text editors but
also in scripting and

20
00:00:58,210 --> 00:01:02,430
programming languages such as Bash,
Python, Perl, R, and so on.

21
00:01:02,430 --> 00:01:06,790
And also for screen scraping and
other data extraction applications.

22
00:01:06,790 --> 00:01:10,280
So why do we study regular expressions
specifically for data cleaning?

23
00:01:10,280 --> 00:01:14,690
Well first of all regular expression
are useful to match and transform data.

24
00:01:14,690 --> 00:01:16,960
So during the phrases of assessing and

25
00:01:16,960 --> 00:01:20,380
then cleaning the data in a larger
data creation life cycle.

26
00:01:20,380 --> 00:01:24,205
Now in particular we will see that the
open refine tool that we're going to work

27
00:01:24,205 --> 00:01:27,217
with has a regular expression
language call GREL built in.

28
00:01:27,217 --> 00:01:29,560
And this will be useful to
understand how it works.

29
00:01:29,560 --> 00:01:33,256
And then of course also if you want to do
data cleaning on your own using scripting

30
00:01:33,256 --> 00:01:33,880
languages.

31
00:01:33,880 --> 00:01:37,674
And for automating workflows you might
then also want to use regular expressions

32
00:01:37,674 --> 00:01:39,660
in those scripting languages.

33
00:01:39,660 --> 00:01:44,144
On the right you see the cartoon that
I found previously from xkcd that

34
00:01:44,144 --> 00:01:48,484
advertises the use of a standard
date format called ISO 8601.

35
00:01:48,484 --> 00:01:51,675
So the ISO 8601 date
format looks like this.

36
00:01:51,675 --> 00:01:56,335
It has first a couple of letters,
four letters specifically for the year.

37
00:01:56,335 --> 00:01:59,485
Followed by a dash and
two letters for the month and

38
00:01:59,485 --> 00:02:03,695
then again two letters for
the day, again with a dash.

39
00:02:03,695 --> 00:02:08,340
Those what I call letters are technically
actually really numbers between zero and

40
00:02:08,340 --> 00:02:09,940
nine so we'll see that shortly.

41
00:02:09,940 --> 00:02:13,853
Now these formats however are not
the only ones that are commonly used.

42
00:02:13,853 --> 00:02:18,304
In the US for example you often have
a date format that looks like this,

43
00:02:18,304 --> 00:02:21,258
month followed by a slash,
followed by a day.

44
00:02:21,258 --> 00:02:23,030
And again a slash and then the year.

45
00:02:23,030 --> 00:02:26,620
And in Europe it might be the other way
around for example you start with a day.

46
00:02:26,620 --> 00:02:30,180
And then instead of a slash as
a separator you'll use maybe a period and

47
00:02:30,180 --> 00:02:32,280
then the month, and then the year.

48
00:02:32,280 --> 00:02:35,957
So clearly when you have data in
these different formats you have

49
00:02:35,957 --> 00:02:38,899
to first match and
find out what form that you have.

50
00:02:38,899 --> 00:02:41,807
And then maybe transform it into
the right standard format so

51
00:02:41,807 --> 00:02:45,570
you can integrate it and
then do your data analysis subsequently.

52
00:02:45,570 --> 00:02:48,420
Now let's continue with the theory
of regular expressions.

53
00:02:48,420 --> 00:02:51,880
So I want to give you a brief introduction
where regular expressions come from.

54
00:02:51,880 --> 00:02:55,250
And then in a separate video we'll look
at the practice of regular expressions.

55
00:02:55,250 --> 00:02:57,000
So in theoretical computer science and

56
00:02:57,000 --> 00:03:01,300
in particular in formal language theory
these are expressions, formal expressions

57
00:03:01,300 --> 00:03:06,300
that define a search pattern that is
used to match or recognize strings.

58
00:03:06,300 --> 00:03:07,900
Let's look in more detail.

59
00:03:07,900 --> 00:03:11,946
In a formal definition there are some
base elements, the empty set,

60
00:03:11,946 --> 00:03:15,456
the empty string and
then an alphabet sigma of characters.

61
00:03:15,456 --> 00:03:19,601
And then the main construct to construct
regular expression is an inductive or

62
00:03:19,601 --> 00:03:20,930
recursive definition.

63
00:03:20,930 --> 00:03:24,100
So assume you already have
a regular expression R and

64
00:03:24,100 --> 00:03:25,660
another regular expression S.

65
00:03:25,660 --> 00:03:29,160
Then you can define a new regular
expression by composing R and

66
00:03:29,160 --> 00:03:31,090
S in one of several ways.

67
00:03:31,090 --> 00:03:34,740
So for example you can say R and
then vertical bar S and

68
00:03:34,740 --> 00:03:36,390
that denotes an alternation.

69
00:03:36,390 --> 00:03:41,603
So if R denotes a regular expression and
S denotes a regular expression

70
00:03:41,603 --> 00:03:47,097
when you say R bar S what you're saying
is that you're looking into text.

71
00:03:47,097 --> 00:03:51,430
Or data that matches either R or
S so it's either or.

72
00:03:51,430 --> 00:03:55,381
Another expression you can build
from R and S is the concatenation.

73
00:03:55,381 --> 00:03:57,552
Sometimes just denoted by putting R and

74
00:03:57,552 --> 00:04:00,570
then followed by S without
anything in between.

75
00:04:00,570 --> 00:04:05,330
Sometimes a certain operation is put
to denote concatenation maybe a circle.

76
00:04:05,330 --> 00:04:06,310
And what does that match?

77
00:04:06,310 --> 00:04:11,340
Well if you have R denoting a regular
expression and S, then R concatenated

78
00:04:11,340 --> 00:04:15,790
with S denotes the concatenation of
the corresponding matching words.

79
00:04:15,790 --> 00:04:20,395
Then finally we have this very powerful
construct called the Kleene star named

80
00:04:20,395 --> 00:04:24,454
after the person who popularized it and
invented it and that's R*.

81
00:04:24,454 --> 00:04:28,559
So if R is a regular expression
our star matches zero or

82
00:04:28,559 --> 00:04:31,761
more occurrences of whatever R matches.

83
00:04:31,761 --> 00:04:36,470
And then finally we will sometimes use
parentheses to indicate precedence

84
00:04:36,470 --> 00:04:38,720
between the different operators.

85
00:04:38,720 --> 00:04:43,740
So we know how to read an expression, how
it can be decomposed into alternations,

86
00:04:43,740 --> 00:04:45,680
concatenations, and Kleene stars.

87
00:04:45,680 --> 00:04:49,330
Sometimes you can omit the parentheses
if you have precedence rules.

88
00:04:49,330 --> 00:04:53,928
Here is a small digression
into theory land if you like.

89
00:04:53,928 --> 00:04:58,180
So there is a whole hierarchy of languages
of which regular languages form in

90
00:04:58,180 --> 00:04:59,740
some sense the lowest layer.

91
00:04:59,740 --> 00:05:01,800
This hierarchy is called
the Chomsky Hierarchy,

92
00:05:01,800 --> 00:05:07,030
named after Noam Chomsky who proposed
this in the 1950's, so quite a while ago.

93
00:05:07,030 --> 00:05:11,217
The hierarchy consists of these
languages of Type-0, Type-1, Type-2.

94
00:05:11,217 --> 00:05:15,860
And finally the most restricted
language class is called Type-3 or

95
00:05:15,860 --> 00:05:17,140
regular language.

96
00:05:17,140 --> 00:05:19,960
This is where the regular comes
from in regular expression.

97
00:05:19,960 --> 00:05:24,670
On the right hand side you see that these
languages are nested inside one another.

98
00:05:24,670 --> 00:05:27,210
So every regular language or
Type-3 language

99
00:05:27,210 --> 00:05:31,346
is also a Type-2 language which is
also known as a context-free language.

100
00:05:31,346 --> 00:05:35,083
Context-free languages themselves
are also context-sensitive languages.

101
00:05:35,083 --> 00:05:39,260
So context-sensitive languages again
are a larger class, more expressive,

102
00:05:39,260 --> 00:05:39,990
more powerful.

103
00:05:39,990 --> 00:05:45,053
And finally Type-0 languages are known
as recursively innumerable languages.

104
00:05:45,053 --> 00:05:48,656
And here you have now really the full
computational power of a computer of

105
00:05:48,656 --> 00:05:49,695
a touring machine.

106
00:05:49,695 --> 00:05:52,293
We're not quite interested in
this as part of this class.

107
00:05:52,293 --> 00:05:56,889
But I want to give you this context that
the regular languages that we can match

108
00:05:56,889 --> 00:06:01,710
with the regular expression are part of
a larger higher key that is used to study.

109
00:06:01,710 --> 00:06:06,490
For example expressive power, languages
and formalism's in computer science.

110
00:06:06,490 --> 00:06:10,381
So this resource here that you can
find on Wikipedia we will see for

111
00:06:10,381 --> 00:06:13,853
example the type-0 computations
are turing incomplete

112
00:06:13,853 --> 00:06:16,460
they can express any turing computation.

113
00:06:16,460 --> 00:06:19,380
For example if you want to recognize
whether a number is a prime number

114
00:06:19,380 --> 00:06:21,100
you can not use a regular expression for
that.

115
00:06:21,100 --> 00:06:23,909
That will not be possible, of course
you could use a regular expression to

116
00:06:23,909 --> 00:06:25,831
find whether a number is
a floating point number.

117
00:06:25,831 --> 00:06:29,698
Or an integer or a negative number but
not whether it has certain properties for

118
00:06:29,698 --> 00:06:32,960
that we would need a much more
powerful language formula.

119
00:06:32,960 --> 00:06:37,060
So let's look at an example,regular
languages can be defined using regular

120
00:06:37,060 --> 00:06:37,830
grammars.

121
00:06:37,830 --> 00:06:40,570
For example let's assume
we want to match a certain

122
00:06:40,570 --> 00:06:42,660
string let's say a floating point number.

123
00:06:42,660 --> 00:06:46,650
So this floating point number might
be generated using a grammar.

124
00:06:46,650 --> 00:06:49,030
And for regular languages we have so

125
00:06:49,030 --> 00:06:52,850
called regular grammars in this case
a right recursive regular grammar.

126
00:06:52,850 --> 00:06:54,310
What does a grammar consist of?

127
00:06:54,310 --> 00:06:56,350
Well it has a number of symbols.

128
00:06:56,350 --> 00:06:58,970
N is the number of non-terminal symbols.

129
00:06:58,970 --> 00:07:01,366
Those can be replaced in
the grammar formalism.

130
00:07:01,366 --> 00:07:04,720
And then there's an alphabet sigma
that we talked about before.

131
00:07:04,720 --> 00:07:08,841
Here our alphabet of characters that we
use are the digits zero through nine.

132
00:07:08,841 --> 00:07:13,477
Then a plus and a minus symbol denoting
positive and negative numbers.

133
00:07:13,477 --> 00:07:17,240
And then e for denoting the exponent
in a floating point number.

134
00:07:17,240 --> 00:07:21,220
And then as you see it's a somewhat
tedious to describe the language

135
00:07:21,220 --> 00:07:24,760
of floating point numbers
using a regular grammar.

136
00:07:24,760 --> 00:07:27,650
We will see shortly that
a regular expression can do a much

137
00:07:27,650 --> 00:07:29,340
better job that in practice.

138
00:07:29,340 --> 00:07:32,280
But in theory you can create all
the floating point numbers using

139
00:07:32,280 --> 00:07:33,540
a grammar as follows.

140
00:07:33,540 --> 00:07:35,105
So you have these production rules p.

141
00:07:35,105 --> 00:07:39,195
You start with the non-terminal symbol s,
s stands for starting symbol.

142
00:07:39,195 --> 00:07:42,714
And then you can apply the rules starting
from s according to any of these

143
00:07:42,714 --> 00:07:43,720
production rules.

144
00:07:43,720 --> 00:07:46,970
You can for example decide you want to
create a negative floating point

145
00:07:46,970 --> 00:07:48,610
number like the example given.

146
00:07:48,610 --> 00:07:52,170
So from s you would
then produce -a because

147
00:07:52,170 --> 00:07:54,890
you decided to create a negative
floating point number.

148
00:07:54,890 --> 00:07:59,766
So since the minus symbol is part
of the alphabet you then cannot

149
00:07:59,766 --> 00:08:01,888
replace the minus symbol.

150
00:08:01,888 --> 00:08:05,860
The only next symbol you can replace
is a which is a non-terminal symbol.

151
00:08:05,860 --> 00:08:08,110
That means you can still be replaced for
something.

152
00:08:08,110 --> 00:08:09,320
So now you have to make a decision.

153
00:08:09,320 --> 00:08:11,940
You have all these choices
what you want to do with a.

154
00:08:11,940 --> 00:08:15,530
So maybe first you want to
produce the number zero.

155
00:08:15,530 --> 00:08:17,980
So a can be replaced with zero.

156
00:08:17,980 --> 00:08:20,430
So now you've produced the number zero

157
00:08:20,430 --> 00:08:23,100
which is after the negative sign
that you already had before.

158
00:08:23,100 --> 00:08:25,775
So starting from a you have minus a.

159
00:08:25,775 --> 00:08:29,705
And then maybe you decided
to produce the zero a.

160
00:08:29,705 --> 00:08:34,194
And then you can say okay maybe that's
enough I want to now produce a decimal

161
00:08:34,194 --> 00:08:34,708
point.

162
00:08:34,708 --> 00:08:36,709
So you have a rule for that,

163
00:08:36,709 --> 00:08:40,365
you can replace the a with
a period followed by a b.

164
00:08:40,365 --> 00:08:45,084
And now you're deciding that you come to
the part after the period in the small

165
00:08:45,084 --> 00:08:48,400
representation of a floating point number.

166
00:08:48,400 --> 00:08:50,430
Now you have lots of choices
of what you want to do next.

167
00:08:50,430 --> 00:08:55,504
Again the symbol b now can
also be replaced by any number

168
00:08:55,504 --> 00:09:00,043
from zero to nine followed
by a non-terminal c.

169
00:09:00,043 --> 00:09:01,730
So you're moving over here.

170
00:09:01,730 --> 00:09:04,870
So let's say you want to
produced a number three, say.

171
00:09:04,870 --> 00:09:07,980
So you have minus 0.3 now.

172
00:09:07,980 --> 00:09:14,659
After you've produced a three you can now
continue on and produce further numbers.

173
00:09:14,659 --> 00:09:18,660
Again with c any sequence really
of digits you can produce.

174
00:09:18,660 --> 00:09:22,200
And when you're tired and fed up with
this then you might decide that you

175
00:09:22,200 --> 00:09:25,780
optionally want to pre use an e for
exponent.

176
00:09:25,780 --> 00:09:28,810
Or you can just eliminate the c and
say you're done.

177
00:09:28,810 --> 00:09:32,350
And that will be with the m,
t word here with absolon.

178
00:09:32,350 --> 00:09:34,964
Let's say we want to create an exponent,
so

179
00:09:34,964 --> 00:09:37,948
we replace the c with
a small e with a character e.

180
00:09:37,948 --> 00:09:42,340
And then we go to the next phase,
so we go to the letter d.

181
00:09:42,340 --> 00:09:43,800
So we're almost done here.

182
00:09:43,800 --> 00:09:44,800
So we go with the letter d.

183
00:09:44,800 --> 00:09:49,660
We can decide whether we have either
a positive or a negative exponent.

184
00:09:49,660 --> 00:09:52,540
Or we might decide to not
say whether it's positive or

185
00:09:52,540 --> 00:09:54,670
negative which implies
that it is positive.

186
00:09:54,670 --> 00:09:58,207
So we might have the plus sign or
the negative sign,

187
00:09:58,207 --> 00:10:00,810
the negative sign or nothing.

188
00:10:00,810 --> 00:10:05,512
And once we have the symbol e we can now,
again generate a sequence of

189
00:10:05,512 --> 00:10:10,647
numbers as we did before until we find
finally go through our last phase f.

190
00:10:10,647 --> 00:10:13,556
And then again for
f we can produce more numbers and

191
00:10:13,556 --> 00:10:15,850
finally replace it with epsilon.

192
00:10:15,850 --> 00:10:17,210
Now this is extremely tedious,

193
00:10:17,210 --> 00:10:20,060
you've noticed how tedious this is,
trying to follow me along here.

194
00:10:20,060 --> 00:10:24,080
But this is the formal way by which
we can produce floating point numbers

195
00:10:24,080 --> 00:10:25,840
using a regular grammar.

196
00:10:25,840 --> 00:10:29,800
Now regular grammars are used
to generate regular languages.

197
00:10:29,800 --> 00:10:34,810
They can also be used In backwards mode
in some sense to accept the recognized or

198
00:10:34,810 --> 00:10:37,320
pass irregular language.

199
00:10:37,320 --> 00:10:39,500
However since these languages
are really used for

200
00:10:39,500 --> 00:10:43,050
studying theoretical aspects of
languages in computer science

201
00:10:43,050 --> 00:10:46,500
as you see easily see here
they're not very practical.

202
00:10:46,500 --> 00:10:50,950
For that we will have regular
expressions that we use in practice.

203
00:10:50,950 --> 00:10:55,050
And I will show you one example of that
as a preview for what's coming next.

204
00:10:55,050 --> 00:10:58,566
So as I mentioned regular grammars and
regular expressions even which

205
00:10:58,566 --> 00:11:01,138
are somewhat more concise
than regular grammars.

206
00:11:01,138 --> 00:11:04,890
But even the theoretical regular
expressions are not very handy,

207
00:11:04,890 --> 00:11:07,320
not very convenient in practice.

208
00:11:07,320 --> 00:11:12,247
So instead the following notation is used
in practice for regular expressions.

209
00:11:12,247 --> 00:11:15,990
Okay, so let's see how a floating point
number looks as a regular expressions.

210
00:11:15,990 --> 00:11:20,440
You see here there's a negative and
a positive sign here to indicate that we

211
00:11:20,440 --> 00:11:24,810
might have a minus or a plus character at
the beginning of a floating point number.

212
00:11:24,810 --> 00:11:28,960
The fact that we put it in brackets
followed by a question mark

213
00:11:28,960 --> 00:11:30,030
means that this is optional.

214
00:11:30,030 --> 00:11:33,130
So we may or may not have a sign,
a positive or

215
00:11:33,130 --> 00:11:35,230
negative sign in front of a number.

216
00:11:35,230 --> 00:11:40,120
Then we have next a number or
a digit rather between zero and nine.

217
00:11:40,120 --> 00:11:44,020
And as you see we put it again
in these brackets to indicate

218
00:11:44,020 --> 00:11:47,800
we have a class of characters any
character between zero and nine.

219
00:11:47,800 --> 00:11:50,180
And then we have the clean star here.

220
00:11:50,180 --> 00:11:52,900
The star indicating that we have zero or
more repetitions of that.

221
00:11:54,070 --> 00:11:57,040
We are then following this with a period.

222
00:11:57,040 --> 00:12:01,784
Now the period is also a meta character so
it can match any kind of characters.

223
00:12:01,784 --> 00:12:06,201
Which is why we have to use this escape
character here to indicate that we mean

224
00:12:06,201 --> 00:12:08,180
the period literally.

225
00:12:08,180 --> 00:12:09,940
And then that can be optional.

226
00:12:09,940 --> 00:12:10,720
And so it goes on.

227
00:12:11,730 --> 00:12:15,520
So in the next video I
will go into details

228
00:12:15,520 --> 00:12:20,540
how regular expressions like these
are actually used and what they mean.

229
00:12:20,540 --> 00:12:25,067
But you see clearly here that what
our theoretical computer scientists

230
00:12:25,067 --> 00:12:27,261
are doing for regular languages.

231
00:12:27,261 --> 00:12:31,916
And regular grammars is not as practical
as what we want to use here to get rid of

232
00:12:31,916 --> 00:12:35,240
the job done in data matching and
data cleaning.

233
00:12:35,240 --> 00:12:40,043
So in summary we have seen
that regular expressions

234
00:12:40,043 --> 00:12:44,852
can be used to define
formally regular languages.

235
00:12:44,852 --> 00:12:49,828
And in the next video we'll then see how
the practice of regular expression works

236
00:12:49,828 --> 00:12:54,823
by using a much more reasonable approach
to define and match regular languages.

237
00:13:00,970 --> 00:13:10,970
[MUSIC]