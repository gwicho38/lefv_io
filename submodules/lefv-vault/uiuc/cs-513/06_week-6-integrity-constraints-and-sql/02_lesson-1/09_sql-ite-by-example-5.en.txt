[MUSIC] Let's push this a little further. Let's say we want to calculate
the difference between each individual radiation reading and
the average of all the radiation readings. So as a SQL novice we might
have the following idea. Let's put our idea forward. So we want to report from survey,
the readings and subtract the average reading, right? Because average readings
we've computed before. What do we get? Whoops, I think I have
the wrong codes here, Mm-hm, It looks a little suspicious. First of all, there's remarkable values. This doesn't look good. Okay, again, let's do SELECT reading FROM survey WERE quant = 'rad', right? So there are how many values? I can just say count,
how many values are there? 8 values. So when I say reading
minus average reading, I should get a value, shouldn't I? The difference to the average, some values
will be above, some will be below average. And an average,
there will be just like average, okay? But that's not what's happening. So what this query is doing, it calculates
the difference between some value from the readings field and
we don't know which one, and the average of all radiation settings and
this is pretty useless. So SQLite, as much as we like it,
it's a little bit too permissive when it comes to aggregation, it allows us to do
things that I find slightly problematic. Let me actually make another example for
that. Before, Let's say before we had a bunch of queries,
let's do a simple one. So let's say we want to do look
at radiations, group by person. Okay, So what's going on here? We have, so
every table we look at which persons have. Let's look at again at
the whole table one more time. This is the whole table, right? We have taken person,
quantity and reading. And here in the aggregate query we've
said okay, let's group by person. So for example, dialect and so on, and let's count how many readings there
are and what's the average reading. Now, SQLite allows us to do
something a little weird. It allows us to put in the SELECT clause, not just the GROUP BY attribute,
which is fine, because for each group, we want to report what is
the value of the GROUP BY attribute. And the aggregate of the rows
which are in this group for this person, which is also good. It also allows us to put something
which I find highly problematic. And this is for example,
I could report taken. Yeah, this is an identifier,
yeah, but which one would I take? So for example if I look at
the quantity radiation by dyer. Dyer has 619 radiation and 622. Well, which one is it? Another SQL database system will
tell you this query is incorrect, because you're asking for
something that's non-deterministic. Normally we don't think
of this as a feature, it's pick either one,
let's see what's going to happen. So this is going to be
exciting because I don't know myself what's going to happen, okay? For dyer 622 was picked. For lake 837 was picked. So let's look at lake,
we're looking at radiation readings, like had two radiations. Let's look at pb,
pb had three radiation readings, so where are the radiations in pb? That's one, 735, there is another one, 751, and there's another one? Okay, so there's three of them, and this is their average, but here we picked
just randomly one of the taken attributes. So other database systems will not allow
you to select the taken attribute here. You could do something deterministic, you could say how many values
are they account, for example. Okay, not surprisingly this number agrees
here with the count of the readings or we could slightly more silly compute the average taken value,
okay, it's a little silly. Or we could take the minimum, The minimum of the possible values,
that's deterministic. Or we can take the maximum,
that's also deterministic. But if we don't give an aggregation
function because we're looking at the group of values and we just say taken,
SQLite just picks one of the values. Again, I don't know what the apologists
say for SBLI for this behavior, but most other data base systems
will say this query is not allowed. So if you enter this
query say in Oracle or any of these other databases,
it will say there's a problem. Because to take an attribute if you group
by taking them then, we're good, although in this case it computes something
that's not particularly interesting. Now, it's not really an aggregation
if you group by this taken thing. But then, at least it would be a legal
query, when I remove this here, I cannot have taken here,
I have to have an aggregate. Count, min, max, average,
one of those things. Which is exactly what we do for
example, here with the reading, we count the reading or
we compute the average of the reading. Person, on the other hand, since we
grouped by person, we can report that because we're going to return for
each person an aggregate value. So first, we select for
a particular person, all the rows for this person, and then we aggregate
the values into single row. And the aggregating into single
row is what makes it problematic to randomly choose a taken value here. Okay, so I wanted to point it
out first because this will help us understand what happened
with our other query here. So here, We wanted to compute readings and
subtract from them the average reading. There's again the wrong quotes here,
hard to see. So because we save average reading, Yeah? What is the average reading for radiation? That's a meaningful query. What's the average reading, For
quantities radiation, right? Let's just say SELECT *
FROM Survey WHERE quan = 'rad'. If these are radiation,
I can compute the average of that. Let's just calculate a few more things. Let's say count (reading), MIN(reading), MAX(reading), avg(reading), actually we can also do the sum(reading),
why not? Okay, so
we go lots of aggregate functions here. So that's pretty neat, yeah,
we've got eight values. The minimum is 1.46. The maximum is 11.25. The sum is 52.5 divided by eight,
hopefully gives us the average of 6.5. That's all great. So we aggregate the whole
table into a single row. But when we then say reading minus this,
which reading are we talking about? Not meaningful. Some reading [LAUGH]
minus the average cell. Not very helpful. So what do we need to do here instead? If we want to calculate a difference
between each individual radiation reading and the average,
we need to use a sub-query. We have to kind of do it in two steps. So first, we have to compute the average
and then, we can go through the table one more time if you like and then look
at the reading minus the average, okay? So how do we get all the readings? So select reading,
From survey where quant = 'rad', right? That's what we want. So these are the readings, but now want to sort of subtract from
each of them the average, okay? So we need to nest inside a subquery and
we can, actually, in SQL there's multiple
places where we can nest and in particular, we can even nest it
right here within the SELECT clause. Minus, I will just stick
in the sub query there. SELECT avg(reading) from, seems a little tedious, yeah, but it'll work, WHERE quant + 'rad'. Okay, so please notice this
highlighting of the cursor. So I have my original query that
just selects the average and my other original query that just
asks about the readings, and I nest them inside of one another. So this takes a little moment to
understand here, so this query, which is highlighted here
computes exactly one number, you might recall what
that number was up here. Look at this, select average ready from
survey where quantity equals radiation. That's a number, 6.5. So it feels like,
in a programming language, I would probably just store it in
a variable and then, use that value later. Here in SQL, I just take
the whole expression by itself and I stick it right here as part
of that SELECT statement. And we can think of this as the sub
quarter being executed first for this to work. And there we go and
now these are the values, and you see some values are above and
some values are below. Maybe we could also do, maybe just put
the reading and then, The difference. Now notice, by the way,
how long the column name here is. Again, that's sort of very informative,
maybe too much information, maybe we should just say as Delta, yeah? And now we're having a table that's
a little bit more meaningful, so we see these other readings and
this is our Delta. So this value 7.22 is pretty close to the average, these values here are below average and the other values are above average. [MUSIC]