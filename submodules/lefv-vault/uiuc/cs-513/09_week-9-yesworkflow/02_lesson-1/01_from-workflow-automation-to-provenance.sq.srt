1
00:00:00,173 --> 00:00:08,482
[Muzikë]

2
00:00:08,482 --> 00:00:11,998
So we had seen before that using
provenance is important for

3
00:00:11,998 --> 00:00:14,262
transparency and reproducibility.

4
00:00:14,262 --> 00:00:17,424
If we want to explain how a certain
data product was arrived at,

5
00:00:17,424 --> 00:00:18,445
how we came to that.

6
00:00:18,445 --> 00:00:21,193
We want to explain the origin,
what are the input data,

7
00:00:21,193 --> 00:00:24,800
what are the processing steps,
and we want to do that.

8
00:00:24,800 --> 00:00:27,790
Now a lot of workflows
are created using scripts.

9
00:00:27,790 --> 00:00:31,940
So if you have a script, it's kind of
a not obvious what the workflow is

10
00:00:31,940 --> 00:00:36,080
underlying it, and looking at the code
itself is often not that helpful.

11
00:00:36,080 --> 00:00:40,780
So if you compare workflows with
scripts with respect to some of these

12
00:00:40,780 --> 00:00:44,670
properties that we've talked about before,
automation, scaling, abstraction and

13
00:00:44,670 --> 00:00:45,700
provenance.

14
00:00:45,700 --> 00:00:47,880
It appears that scripts are,
in particular,

15
00:00:47,880 --> 00:00:50,650
not well suited from
abstraction point of view.

16
00:00:50,650 --> 00:00:54,050
I mean there's executable code,
it might be nicely written,

17
00:00:54,050 --> 00:00:57,790
it might be nicely documented, but
it still does not provide a high-level

18
00:00:57,790 --> 00:01:00,590
overview of what the method is,
how it works.

19
00:01:00,590 --> 00:01:04,650
In particular what it does not do is it
does not explain the output products of

20
00:01:04,650 --> 00:01:08,590
a script, in terms of the inputs and
in terms of the computational steps.

21
00:01:08,590 --> 00:01:10,750
It really doesn't do that job.

22
00:01:10,750 --> 00:01:14,070
There is a tool called noWorkflow, I'm
going to mention it again briefly today.

23
00:01:14,070 --> 00:01:18,650
But even that tool, although it traces
the actual execution history of a Python

24
00:01:18,650 --> 00:01:22,870
script, it is not that well suited
to give you the high level overview.

25
00:01:22,870 --> 00:01:27,062
And also not that well suited to
explain how output depend on inputs.

26
00:01:27,062 --> 00:01:30,140
It will do that at the scripting level,
at the code level, but

27
00:01:30,140 --> 00:01:32,600
not at the more foundational level.

28
00:01:32,600 --> 00:01:35,960
So that was one of the goals of this
tool that I'm, again, summarizing here,

29
00:01:35,960 --> 00:01:37,240
called YesWorkflow.

30
00:01:37,240 --> 00:01:41,220
So abstraction and provenance is really
what we wanted to provide for scripts.

31
00:01:42,530 --> 00:01:46,120
So the big question then, is how do you
go from a script to a workflow diagram?

32
00:01:46,120 --> 00:01:51,000
Because this workflow diagram that you see
here on the lower right is one that would

33
00:01:51,000 --> 00:01:55,770
allow you precisely to explain the outputs
in terms of computational steps.

34
00:01:55,770 --> 00:01:58,570
Those are the green boxes,
and then input items,

35
00:01:58,570 --> 00:02:01,420
those would be sort of towards the top,
the notes on the top.

36
00:02:01,420 --> 00:02:06,635
So again, we have the green nodes or boxes
to represent steps, computational steps,

37
00:02:06,635 --> 00:02:10,920
and then the yellow rounded boxes
to represent data elements.

38
00:02:10,920 --> 00:02:13,570
And you don't have to worry
what they right now mean, but

39
00:02:13,570 --> 00:02:17,300
you see there's sort of a overall
data flow created that way.

40
00:02:17,300 --> 00:02:19,860
And it's not quite clear how
you would get it from a script,

41
00:02:19,860 --> 00:02:21,480
unless you yourself would declare it.

42
00:02:21,480 --> 00:02:23,700
So that's the YesWorkflow approach.

43
00:02:23,700 --> 00:02:26,820
The script author declares sort of
these dependencies, and then we have

44
00:02:26,820 --> 00:02:30,840
this artifact that we can share with
others and that we can also query.

45
00:02:30,840 --> 00:02:31,615
So how do we do that?

46
00:02:31,615 --> 00:02:37,060
We've seen this previously, we have code,
if we have the script already existing.

47
00:02:37,060 --> 00:02:41,540
And then we put annotations that mark
the beginning and end of steps, and

48
00:02:41,540 --> 00:02:44,070
that mark the input and output of steps.

49
00:02:44,070 --> 00:02:47,160
You could write this model
also next to the script.

50
00:02:47,160 --> 00:02:50,030
The fact that we embed it
in scripts often leads to

51
00:02:50,030 --> 00:02:52,430
some sort of misunderstanding
that we're documenting the code.

52
00:02:52,430 --> 00:02:54,900
So let me say it just one more time,
maybe for

53
00:02:54,900 --> 00:02:56,960
the fun of it,
write it into a separate file.

54
00:02:56,960 --> 00:03:00,220
Then nobody will think that's
a comment of the code,

55
00:03:00,220 --> 00:03:04,070
it is really a new model that you create
for your application or for your script.

56
00:03:05,230 --> 00:03:10,160
So I showed this example in the past,
we call it the YesWorkflow Recon.

57
00:03:10,160 --> 00:03:14,650
This is an example where we use the
workflow diagram on the left, to explain

58
00:03:14,650 --> 00:03:17,710
and reconstruct some of the provenance
that was left behind by the script.

59
00:03:18,900 --> 00:03:22,260
So scripts often read and
write files from various folders,

60
00:03:22,260 --> 00:03:24,630
and often there's underlying organization.

61
00:03:24,630 --> 00:03:29,145
So this particular script, for example,
takes inputs from the run folder.

62
00:03:29,145 --> 00:03:32,660
There's kind of raw data or
input data sub folder,

63
00:03:32,660 --> 00:03:35,020
it's not called input data,
it's called raw.

64
00:03:35,020 --> 00:03:38,310
And then there are sort of
these nested folder structures.

65
00:03:38,310 --> 00:03:42,270
Something representing what
is called a cassette ID.

66
00:03:42,270 --> 00:03:45,730
This has to do with samples that
are organized into cassettes.

67
00:03:45,730 --> 00:03:49,165
And then these cassettes are put
on an instrument, and sort of,

68
00:03:49,165 --> 00:03:51,465
images are taken with an x-ray approach.

69
00:03:51,465 --> 00:03:55,707
And there's different electrons
volts being used, 10,000 or 11,000.

70
00:03:55,707 --> 00:03:57,910
And these are sort of the raw images.

71
00:03:57,910 --> 00:04:01,310
But as part of the data processing
workflow, in this case the script,

72
00:04:01,310 --> 00:04:05,210
transformed images are generated,
sort of, they are processed.

73
00:04:05,210 --> 00:04:08,860
And the outputs end up in a data folder,
further down here, called data.

74
00:04:08,860 --> 00:04:11,870
And then you see there's
some sort of correspondence,

75
00:04:11,870 --> 00:04:14,700
actually these are the cassettes, Q55.

76
00:04:14,700 --> 00:04:18,460
But this level, Q55 is no longer
here in the processed data.

77
00:04:18,460 --> 00:04:20,970
Then we only care about the sample ID.

78
00:04:20,970 --> 00:04:25,460
So I may have spoken before,
I think Q55 is the cassette ID, and

79
00:04:25,460 --> 00:04:27,830
DRT240 is the sample ID.

80
00:04:27,830 --> 00:04:30,390
And then once we've processed it,
we kind of don't care about the cassettes.

81
00:04:30,390 --> 00:04:34,470
That was kind of an artifact of
the actual physical x-ray imaging.

82
00:04:34,470 --> 00:04:37,070
But the sample ID allows
us to really talk about

83
00:04:37,070 --> 00:04:38,980
the particular sample
that we're looking at.

84
00:04:38,980 --> 00:04:41,560
And so
these show up in the transformed images.

85
00:04:41,560 --> 00:04:45,640
But if you had only the script, and
if you had only these products on disk,

86
00:04:45,640 --> 00:04:48,930
it would be really hard to understand
how they relate to one another.

87
00:04:48,930 --> 00:04:52,640
If on the other hand,
you have created this graph model here,

88
00:04:52,640 --> 00:04:55,960
you can now understand how the outputs
are derived from the inputs.

89
00:04:55,960 --> 00:04:56,980
Yeah, so you see for example,

90
00:04:56,980 --> 00:05:01,510
here the corrected image came from the raw
image via a step called transform images.

91
00:05:01,510 --> 00:05:04,549
And there's, in particular,
these little expressions in here,

92
00:05:04,549 --> 00:05:05,840
that we call URI templates.

93
00:05:05,840 --> 00:05:10,100
And again, that's explained in some more
detail in the reading, how that works.

94
00:05:10,100 --> 00:05:13,180
But fundamentally, every expression
here that's in curly braces,

95
00:05:13,180 --> 00:05:16,750
you can think of it as a parameter or
a template variable.

96
00:05:16,750 --> 00:05:19,120
And you can then find
the corresponding values for

97
00:05:19,120 --> 00:05:22,520
that variable by looking on disk
in the corresponding places.

98
00:05:22,520 --> 00:05:26,380
So, for example, here we see
the corrected image says, data/, and

99
00:05:26,380 --> 00:05:33,930
then we have a variable sampleID/, another
variable called sampleID_energyLevel.

100
00:05:33,930 --> 00:05:35,660
So if you look in the output data,
check this out.

101
00:05:35,660 --> 00:05:41,468
So you have DRT240 and
then we have DRT240_10000 electron volt.

102
00:05:41,468 --> 00:05:46,000
So that makes that file name also
itself kind of self-contained, right?

103
00:05:46,000 --> 00:05:49,210
So we have not just an image number 137,
and so

104
00:05:49,210 --> 00:05:53,285
on, we have that all-important sample
ID right there in the file name.

105
00:05:53,285 --> 00:05:58,360
So if this file goes traveling somewhere,
that sample ID is still with it,

106
00:05:58,360 --> 00:06:00,010
if the file name isn't changed.

107
00:06:00,010 --> 00:06:02,620
And so we declare, in some sense,
in our conceptual model,

108
00:06:02,620 --> 00:06:07,140
if we want to think of that as
a conceptual model, the corrected image to

109
00:06:07,140 --> 00:06:12,590
be on disk in a certain file that has
these certain variables embedded.

110
00:06:12,590 --> 00:06:15,810
Both in the file path as well
as in the file name itself.

111
00:06:15,810 --> 00:06:20,340
And once we have that, we can then really
answer questions about the provenance.

112
00:06:20,340 --> 00:06:24,920
So for example, here is again,
the overall approach, when we say

113
00:06:24,920 --> 00:06:28,740
first we annotate the script using begin,
end, in, and out declarations.

114
00:06:28,740 --> 00:06:30,780
And we can look at the graphs.

115
00:06:30,780 --> 00:06:36,240
But then we can also run the script,
look what artifacts are left behind.

116
00:06:36,240 --> 00:06:40,838
And then use a special reconstruction step
to collect the run time provenance, and

117
00:06:40,838 --> 00:06:44,068
link it to perspective provenance
to the workflow graph.

118
00:06:44,068 --> 00:06:47,430
And then this allows us to answer
the user's provenance queries.

119
00:06:47,430 --> 00:06:51,730
And I'm going to show this hopefully in
a little demo in a while, to see how that

120
00:06:51,730 --> 00:06:56,000
actually works on a demonstration
prototype that we've put together.

121
00:06:56,000 --> 00:06:58,570
So again, here is the example
that I just showed you.

122
00:06:58,570 --> 00:07:01,100
I want to just quickly go
through this one more time.

123
00:07:01,100 --> 00:07:05,860
So if you want to know what samples did
the script run collect images from?

124
00:07:05,860 --> 00:07:10,760
The sample ID is found here, for
example, in the input folder.

125
00:07:10,760 --> 00:07:12,300
And this is, if you look here,

126
00:07:12,300 --> 00:07:16,590
raw image, we see that raw
image has this URI template.

127
00:07:16,590 --> 00:07:21,290
And we see that the sample ID is below
the cassette ID, so we go to run,

128
00:07:21,290 --> 00:07:24,310
raw, and then comes cassette ID,
and then sample ID.

129
00:07:24,310 --> 00:07:27,411
So run, raw, cassette ID,
and then sample ID.

130
00:07:27,411 --> 00:07:31,451
So in this case there were two samples,
240 and 322.

131
00:07:31,451 --> 00:07:33,510
And how do we know that those are samples?

132
00:07:33,510 --> 00:07:36,483
Because we've said so,
the script author has said so.

133
00:07:36,483 --> 00:07:39,030
Now if we want to know well
what energies were used,

134
00:07:39,030 --> 00:07:41,590
again this information is available.

135
00:07:41,590 --> 00:07:45,670
So the original raw image that
was first taken, had for example,

136
00:07:45,670 --> 00:07:50,620
in this case for 322, image number
one is was used with 10,000 volts.

137
00:07:50,620 --> 00:07:54,580
And then there's another image
which that was taken with 11,000.

138
00:07:54,580 --> 00:07:57,030
So apparently here the frame
numbers are not unique.

139
00:07:57,030 --> 00:08:00,945
They are only sort of unique
relative to the given sample and

140
00:08:00,945 --> 00:08:02,940
to the given electron volts.

141
00:08:02,940 --> 00:08:05,200
Okay, so
you have to be a little bit careful.

142
00:08:05,200 --> 00:08:07,840
Maybe you could use also
globally unique image ID.

143
00:08:07,840 --> 00:08:10,440
Maybe that would be
another way to model this.

144
00:08:10,440 --> 00:08:11,120
But again,

145
00:08:11,120 --> 00:08:15,770
this information has been declared by
the user as part of the YesWorkflow model.

146
00:08:15,770 --> 00:08:20,200
Another one, where's the raw image of
the corrected image with this file name?

147
00:08:20,200 --> 00:08:23,410
Again, because we understand
the structure of files names,

148
00:08:23,410 --> 00:08:27,730
because we've declared it, we can kind of
read this out and it becomes an artifact.

149
00:08:27,730 --> 00:08:31,100
And we can look up where
the raw images for those.

150
00:08:31,100 --> 00:08:35,030
And maybe if we see some strange artifact,
for example, in the transformed images,

151
00:08:35,030 --> 00:08:38,920
we can then look at the raw images to see
whether those artifacts are there as well.

152
00:08:38,920 --> 00:08:42,540
Maybe they were introduced as a problem
in the transform images step.

153
00:08:42,540 --> 00:08:44,100
Or maybe they were in the original image,

154
00:08:44,100 --> 00:08:47,300
which indicates our problem
is further upstream.

155
00:08:47,300 --> 00:08:51,210
So again, this information would be
known because we have these variables in

156
00:08:51,210 --> 00:08:51,910
our model.

157
00:08:51,910 --> 00:08:53,760
And therefore, we can query them.

158
00:08:53,760 --> 00:08:58,350
So this summarize what this
YesWorkflow approach gives us.

159
00:08:58,350 --> 00:09:01,100
So first of all,
we've talked about scientific workflows.

160
00:09:01,100 --> 00:09:04,220
Scientific workflows have as a goal,
many things.

161
00:09:04,220 --> 00:09:08,959
And I'll summarize briefly here as
automation, scaling, abstraction, and

162
00:09:08,959 --> 00:09:10,060
provenance.

163
00:09:10,060 --> 00:09:14,380
And in particular, we look at two kinds
of provenance information from workflows.

164
00:09:14,380 --> 00:09:19,150
One we called prospective provenance, and
that was the workflow diagram itself.

165
00:09:19,150 --> 00:09:21,660
The workflow itself is a form
of prospective provenance.

166
00:09:21,660 --> 00:09:26,240
It gives us a recipe how we can
understand a method in terms of steps and

167
00:09:26,240 --> 00:09:28,370
the data that flows between those steps.

168
00:09:28,370 --> 00:09:31,840
And in retrospective provenance,
we want to call all this information

169
00:09:31,840 --> 00:09:34,558
that might be available after the run or
during the run.

170
00:09:34,558 --> 00:09:37,070
This can include,
as we've seen, file names and

171
00:09:37,070 --> 00:09:41,120
folder names, but also events like
reading and writing of files.

172
00:09:41,120 --> 00:09:45,340
Possibly the time stamps,
although time stamps are sort of

173
00:09:45,340 --> 00:09:48,260
not an ideal sort of explanation
of what just happened.

174
00:09:48,260 --> 00:09:52,270
But they give you sometimes an indication,
if something might have gone wrong,

175
00:09:52,270 --> 00:09:56,760
if the time stamps don't seem to agree
with other provenance information.

176
00:09:56,760 --> 00:10:00,760
The YesWorkflow approach recognizes
that scripts can be workflows too.

177
00:10:00,760 --> 00:10:05,670
And what really the point of YesWorkflow
is to reveal the computational steps and

178
00:10:05,670 --> 00:10:09,820
the data dependencies of the output
data products on the inputs and

179
00:10:09,820 --> 00:10:11,660
on the computation steps themselves.

180
00:10:11,660 --> 00:10:13,660
So it is not about commenting your code.

181
00:10:13,660 --> 00:10:18,092
Instead, what it does is declare
the workflow model in a way that explains

182
00:10:18,092 --> 00:10:22,107
the relevant data dependencies,
outputs in terms of the inputs.

183
00:10:22,107 --> 00:10:32,107
[Muzikë]